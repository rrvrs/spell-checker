<!DOCTYPE article
PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD with MathML3 v1.3 20210610//EN" "JATS-archivearticle1-3-mathml3.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.3" xml:lang="en" article-type="research-article"><?properties open_access?><processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats"><restricted-by>pmc</restricted-by></processing-meta><front><journal-meta><journal-id journal-id-type="nlm-ta">Sensors (Basel)</journal-id><journal-id journal-id-type="iso-abbrev">Sensors (Basel)</journal-id><journal-id journal-id-type="publisher-id">sensors</journal-id><journal-title-group><journal-title>Sensors (Basel, Switzerland)</journal-title></journal-title-group><issn pub-type="epub">1424-8220</issn><publisher><publisher-name>MDPI</publisher-name></publisher></journal-meta>
<article-meta><article-id pub-id-type="pmid">40006343</article-id><article-id pub-id-type="pmc">PMC11859671</article-id><article-id pub-id-type="doi">10.3390/s25041115</article-id><article-id pub-id-type="publisher-id">sensors-25-01115</article-id><article-categories><subj-group subj-group-type="heading"><subject>Article</subject></subj-group></article-categories><title-group><article-title>A Node Generation and Refinement Algorithm in Meshless RPIM for Electromagnetic Analysis of Sensors</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Li</surname><given-names>Zihao</given-names></name></contrib><contrib contrib-type="author"><name><surname>An</surname><given-names>Siguang</given-names></name><xref rid="c1-sensors-25-01115" ref-type="corresp">*</xref></contrib><contrib contrib-type="author"><name><surname>Zou</surname><given-names>Guoping</given-names></name></contrib><contrib contrib-type="author"><contrib-id contrib-id-type="orcid" authenticated="true">https://orcid.org/0000-0003-4708-6764</contrib-id><name><surname>Han</surname><given-names>Jianqiang</given-names></name></contrib></contrib-group><contrib-group><contrib contrib-type="editor"><name><surname>Ramos</surname><given-names>Daniel</given-names></name><role>Academic Editor</role></contrib></contrib-group><aff id="af1-sensors-25-01115">College of Mechanical and Electrical Engineering, China Jiliang University, Hangzhou 310018, China</aff><author-notes><corresp id="c1-sensors-25-01115"><label>*</label>Correspondence: <email>annsg@cjlu.edu.cn</email></corresp></author-notes><pub-date pub-type="epub"><day>12</day><month>2</month><year>2025</year></pub-date><pub-date pub-type="collection"><month>2</month><year>2025</year></pub-date><volume>25</volume><issue>4</issue><elocation-id>1115</elocation-id><history><date date-type="received"><day>25</day><month>12</month><year>2024</year></date><date date-type="rev-recd"><day>02</day><month>2</month><year>2025</year></date><date date-type="accepted"><day>08</day><month>2</month><year>2025</year></date></history><permissions><copyright-statement>&#x000a9; 2025 by the authors.</copyright-statement><copyright-year>2025</copyright-year><license><ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref><license-p>Licensee MDPI, Basel, Switzerland. This article is an open access article distributed under the terms and conditions of the Creative Commons Attribution (CC BY) license (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>).</license-p></license></permissions><abstract><p>In sensor design, electromagnetic field numerical simulation techniques are widely used to investigate the working principles of sensors. These analyses help designers understand how sensors detect and respond to external signals during operation. One popular method for electromagnetic field computation is the meshless radial point interpolation method (RPIM), where the number and distribution of nodes are critical to ensuring both accuracy and efficiency. However, traditional RPIM methods often face challenges in achieving stable and precise results, particularly in complex electromagnetic environments. In order to enhance the stability and accuracy of electromagnetic numerical calculations, a node generation and adaptive refinement algorithm for the meshless RPIM is proposed. The proposed approach includes an initial node-generation method designed to optimize the balance between computational accuracy and efficiency, as well as a dynamic error threshold and hybrid node refinement method to precisely identify and adaptively refine areas requiring additional nodes, ensuring high precision in critical regions. The proposed method was validated through its application to electrostatic fields and multi-media magnetic fields, demonstrating significant improvements in both stability and accuracy compared with conventional RPIM approaches. These findings highlight the potential of the proposed algorithm to enhance the reliability and precision of electromagnetic field simulations in sensor design and related applications.</p></abstract><kwd-group><kwd>adaptive algorithms</kwd><kwd>domain decomposition</kwd><kwd>radial basis function</kwd><kwd>meshless method</kwd></kwd-group><funding-group><award-group><funding-source>Natural Science Foundation, China</funding-source><award-id>52077203</award-id><award-id>52377017</award-id></award-group><award-group><funding-source>State Key Laboratory of Transducer Technology Foundation</funding-source><award-id>SKT2305</award-id></award-group><funding-statement>This work was supported by the Natural Science Foundation, China, under Grant (No. 52077203, No. 52377017), and State Key Laboratory of Transducer Technology Foundation (SKT2305).</funding-statement></funding-group></article-meta></front><body><sec sec-type="intro" id="sec1-sensors-25-01115"><title>1. Introduction</title><p>In recent years, electromagnetic simulation has become increasingly important in sensor design. Modern sensors often contain complex magnetic and electronic components, making the understanding of magnetic field distribution within these components critical [<xref rid="B1-sensors-25-01115" ref-type="bibr">1</xref>]. This understanding helps optimize the sensor&#x02019;s sensitivity, power consumption, and overall performance. Sensors are typically composed of multiple components, and simulating how the electromagnetic field from one component affects others is essential. Magnetic elements, such as inductive coils, Hall effect sensors, and magnetoresistive materials, are at the core of many sensor operating principles [<xref rid="B2-sensors-25-01115" ref-type="bibr">2</xref>,<xref rid="B3-sensors-25-01115" ref-type="bibr">3</xref>]. Accurate electromagnetic simulation is crucial for predicting how these components interact with each other and with external magnetic fields. Without such simulations, it would be extremely difficult to design these components for optimal performance, as physical testing alone cannot deeply explore the complex electromagnetic behavior within the sensor.</p><p>Electromagnetic compatibility (EMC) is another key factor that requires support from electromagnetic simulation [<xref rid="B4-sensors-25-01115" ref-type="bibr">4</xref>]. As electronic devices become smaller and more powerful, they often operate in environments with higher levels of electromagnetic noise. Therefore, sensors must be designed to function reliably even in the presence of electromagnetic interference. Electromagnetic simulation enables the optimization and customization of sensor designs to meet specific requirements. It provides flexibility in design adjustments, allowing simulations to refine designs to achieve desired performance goals.</p><p>For this reason, high-quality electromagnetic computational algorithms are vital to the sensor design process. These algorithms play a critical role in ensuring the sensor&#x02019;s optimal functionality and performance in real-world conditions. Meshless methods have been widely used in solving electromagnetic problems [<xref rid="B5-sensors-25-01115" ref-type="bibr">5</xref>,<xref rid="B6-sensors-25-01115" ref-type="bibr">6</xref>,<xref rid="B7-sensors-25-01115" ref-type="bibr">7</xref>,<xref rid="B8-sensors-25-01115" ref-type="bibr">8</xref>]. Among these methods, the meshless radial point interpolation method (RPIM) has emerged as a popular branch due to its simplicity and flexibility. The RPIM facilitates interactions between interpolation nodes distributed within the computational domain, whether uniformly or randomly, instead of relying on a mesh structure [<xref rid="B9-sensors-25-01115" ref-type="bibr">9</xref>]. As a result, the need to consider mesh quality is eliminated in the RPIM, providing advantages in solving electromagnetic problems. Given that in the RPIM, calculations are based on the interpolation nodes, the number and location of the nodes are critical. A significant challenge for the RPIM lies in precise node generation, both in terms of quantity and distribution. An excessive number of nodes will lead to an ill-conditioned and irreversible coefficient matrix with a high condition number [<xref rid="B10-sensors-25-01115" ref-type="bibr">10</xref>], while an insufficient number of nodes may decrease the computational accuracy. Therefore, an effective and efficient node-generation method is crucial for the RPIM.</p><p>Endeavors have been made to alleviate the condition number of the coefficient matrix and enhance the computational accuracy of the RPIM. The domain decomposition method is utilized to divide the computational domain into sub-domains, resulting in a sparse global coefficient matrix that facilitates the identification of the proper shape parameter. Additionally, domain decomposition can mitigate the impact of large condition number by reducing the number of degrees of freedom in the computational domain. When the entire domain is divided into multiple sub-domains, each sub-domain problem is transformed into a boundary value problem by imposing boundary conditions at the artificially created interfaces [<xref rid="B11-sensors-25-01115" ref-type="bibr">11</xref>,<xref rid="B12-sensors-25-01115" ref-type="bibr">12</xref>]. A lower condition number reduces the system&#x02019;s sensitivity to perturbations in the input data [<xref rid="B13-sensors-25-01115" ref-type="bibr">13</xref>]. Furthermore, computational accuracy can be improved by adding additional nodes [<xref rid="B14-sensors-25-01115" ref-type="bibr">14</xref>].</p><p>However, existing methods often struggle to achieve a balance between computational efficiency and accuracy, particularly in complex electromagnetic environments with multi-media interfaces [<xref rid="B15-sensors-25-01115" ref-type="bibr">15</xref>]. Domain decomposition and node-addition techniques may introduce new challenges, such as sudden jumps (Riccati-type) in electromagnetic fields, which can significantly impact the accuracy of numerical simulations. These discontinuities, which arise from the dynamic nature of electromagnetic fields, can lead to abrupt changes in field components, making it difficult to achieve precise results in affected domains [<xref rid="B16-sensors-25-01115" ref-type="bibr">16</xref>,<xref rid="B17-sensors-25-01115" ref-type="bibr">17</xref>]. To address these limitations, this study proposes an initial node-generation method and an adaptive node refinement algorithm. The proposed approach introduces a dynamic error threshold and a hybrid node refinement strategy, ensuring optimal node distribution and significantly improving the stability and accuracy of the RPIM in complex electromagnetic simulations.</p></sec><sec id="sec2-sensors-25-01115"><title>2. Implementation of RPIM for Electromagnetic Computation</title><sec id="sec2dot1-sensors-25-01115"><title>2.1. Radial Point Interpolation Method</title><p>A typical electromagnetic field problem is generally represented by a governing equation in the form of partial differential equations [<xref rid="B10-sensors-25-01115" ref-type="bibr">10</xref>]:<disp-formula id="FD1-sensors-25-01115"><label>(1)</label><mml:math id="mm1" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mfenced close="" open="{"><mml:mrow><mml:mtable equalrows="true" equalcolumns="true"><mml:mtr><mml:mtd><mml:mrow><mml:mi>L</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mo>&#x02003;</mml:mo><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi mathvariant="sans-serif">&#x003a9;</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi>B</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>u</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>g</mml:mi><mml:mo>&#x02003;</mml:mo><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi mathvariant="sans-serif">&#x00393;</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></disp-formula>
where, &#x003a9; represents the computational domain, while &#x00393; denotes the boundary, <italic toggle="yes">L</italic> is the linear partial differential operator, <italic toggle="yes">B</italic> is the boundary condition, and <italic toggle="yes">f</italic> and <italic toggle="yes">g</italic> are known functions of the independent variable <italic toggle="yes">x</italic>.</p><p>By placing nodes throughout the entire computational domain and establishing the function space at each node, the unknown coefficients <italic toggle="yes">u</italic>(<italic toggle="yes">x</italic>) in the computational domain can be obtained:<disp-formula id="FD2-sensors-25-01115"><label>(2)</label><mml:math id="mm2" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02248;</mml:mo><mml:msup><mml:mi>u</mml:mi><mml:mi>h</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>
where <italic toggle="yes">u<sup>h</sup></italic>(<italic toggle="yes">x</italic>) represents the approximate unknown coefficients, and <italic toggle="yes">a<sub>j</sub></italic> are the coefficients to be determined. This paper chooses the multiquadric (MQ) radial basis function for its superior performance; the MQ-RBF is expressed as follows:<disp-formula id="FD3-sensors-25-01115"><label>(3)</label><mml:math id="mm3" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mrow><mml:mfenced close="&#x02016;" open="&#x02016;"><mml:mrow><mml:mi>x</mml:mi><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:mfenced></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mi>c</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mn>0.5</mml:mn></mml:mrow></mml:msup><mml:mo>,</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>From the above equation, a system of <italic toggle="yes">N</italic> linear equations can be obtained for the unknown coefficients <italic toggle="yes">a<sub>j</sub></italic>:<disp-formula id="FD4-sensors-25-01115"><label>(4)</label><mml:math id="mm4" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mfenced close="}" open="{"><mml:mrow><mml:mtable equalrows="true" equalcolumns="true"><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mo>&#x022ef;</mml:mo></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mo>&#x022ef;</mml:mo></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>&#x022ee;</mml:mo></mml:mtd><mml:mtd><mml:mo>&#x022ee;</mml:mo></mml:mtd><mml:mtd><mml:mo>&#x022f1;</mml:mo></mml:mtd><mml:mtd><mml:mo>&#x022ee;</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mo>&#x022ef;</mml:mo></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mfenced close="]" open="["><mml:mrow><mml:mtable equalrows="true" equalcolumns="true"><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>&#x022ee;</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>N</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced close="]" open="["><mml:mrow><mml:mtable equalrows="true" equalcolumns="true"><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mn>1</mml:mn></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>&#x022ee;</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mi>N</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>,</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>The above equation can be expressed in matrix and vector notation, where<disp-formula id="FD5-sensors-25-01115"><label>(5)</label><mml:math id="mm5" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>K</mml:mi><mml:mo>=</mml:mo><mml:mfenced close="]" open="["><mml:mrow><mml:mtable equalrows="true" equalcolumns="true"><mml:mtr><mml:mtd><mml:mrow><mml:msup><mml:mstyle mathsize="normal"><mml:mi mathvariant="normal">&#x003a6;</mml:mi></mml:mstyle><mml:mi>T</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msup><mml:mstyle mathsize="normal"><mml:mi mathvariant="normal">&#x003a6;</mml:mi></mml:mstyle><mml:mi>T</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>&#x022ee;</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msup><mml:mi mathvariant="normal">&#x003a6;</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced close="}" open="{"><mml:mrow><mml:mtable equalrows="true" equalcolumns="true"><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mo>&#x022ef;</mml:mo></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mo>&#x022ef;</mml:mo></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>&#x022ee;</mml:mo></mml:mtd><mml:mtd><mml:mo>&#x022ee;</mml:mo></mml:mtd><mml:mtd><mml:mo>&#x022f1;</mml:mo></mml:mtd><mml:mtd><mml:mo>&#x022ee;</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mo>&#x022ef;</mml:mo></mml:mtd><mml:mtd><mml:mrow><mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>,</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula><disp-formula id="FD6-sensors-25-01115"><label>(6)</label><mml:math id="mm6" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi mathvariant="sans-serif">&#x003a6;</mml:mi><mml:mfenced><mml:mi>x</mml:mi></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mfenced close="]" open="["><mml:mrow><mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x003d5;</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfenced></mml:mrow><mml:mi mathvariant="normal">T</mml:mi></mml:msup><mml:mo>,</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula><disp-formula id="FD7-sensors-25-01115"><label>(7)</label><mml:math id="mm7" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mfenced close="]" open="["><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mi>N</mml:mi></mml:msub></mml:mrow></mml:mfenced></mml:mrow><mml:mi mathvariant="normal">T</mml:mi></mml:msup><mml:mo>,</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula><disp-formula id="FD8-sensors-25-01115"><label>(8)</label><mml:math id="mm8" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mfenced close="]" open="["><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>N</mml:mi></mml:msub></mml:mrow></mml:mfenced></mml:mrow><mml:mi mathvariant="normal">T</mml:mi></mml:msup><mml:mo>,</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>Therefore, the above equation can be represented as a matrix equation:<disp-formula id="FD9-sensors-25-01115"><label>(9)</label><mml:math id="mm9" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>A</mml:mi><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>From the above equation, the unknown coefficient vector can be obtained. Substituting it into the equation gives the approximate function expression at any node <italic toggle="yes">x</italic>:<disp-formula id="FD10-sensors-25-01115"><label>(10)</label><mml:math id="mm10" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mi>u</mml:mi><mml:mi>h</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mi mathvariant="sans-serif">&#x003a6;</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msup><mml:mstyle mathvariant="normal" mathsize="normal"><mml:mi>A</mml:mi></mml:mstyle><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mi>u</mml:mi><mml:mo>=</mml:mo><mml:mi>N</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>u</mml:mi><mml:mo>,</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p></sec><sec id="sec2dot2-sensors-25-01115"><title>2.2. Initial Node-Generation Method</title><p>There are two traditional methods for generating initial nodes: random distribution and uniform distribution. However, these two methods may result in an excessive or insufficient number of nodes, which may affect the effectiveness or accuracy of the algorithm. To control the quantity of initial nodes, a structured background grid is introduced here, and the computational domain is covered with equal-sized square grids. Based on the background grid, the number of nodes can be controlled by step length. The step length between two nodes is calculated as follows:<disp-formula id="FD11-sensors-25-01115"><label>(11)</label><mml:math id="mm11" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mi>l</mml:mi><mml:mrow><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mi>w</mml:mi><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfrac></mml:mstyle><mml:mo>,</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>
where <italic toggle="yes">w</italic> is the width of the background grid, <italic toggle="yes">n</italic> is the number of nodes between two vertices on the same side of the grid, <italic toggle="yes">n</italic> is an integer starting from zero and increasing in each iteration until <italic toggle="yes">l<sub>step</sub></italic> &#x02264; <italic toggle="yes">l</italic><sub>0</sub>, and <italic toggle="yes">l</italic><sub>0</sub> is the preferred maximum step length defined by the designer.</p><p>In the proposed initial node-generation method, the number of nodes can be controlled using step length. The larger <italic toggle="yes">l<sub>step</sub></italic> is, the fewer nodes are generated. Furthermore, the structured background grid is a decomposition of the computational domain, so the coefficient matrix has the merit of sparsity.</p></sec><sec id="sec2dot3-sensors-25-01115"><title>2.3. Adaptive Refinement Algorithm</title><p>In order to add nodes precisely and improve the accuracy of the RPIM, an adaptive refinement algorithm is proposed. Two-step iterations are used in the proposed node refinement algorithm. The first step is to determine the low-accuracy area; the second step is to add appropriate nodes in this area.</p><p>In the first step, a dynamic error threshold is proposed to mark the low-accuracy nodes. In each iteration, the errors of nodes are calculated and classified within the background grid. Maximum error in each background grid is chosen to represent its grid quality. The worst quality background grid with the largest maximum error is marked. Node refinement is performed only within the marked background grid, which helps reduce the complexity of the refinement process. The second largest maximum error is chosen as the error threshold for the current iteration, which ensures that the refinement is effectively confined to the relevant background grid, preventing excessive refinement caused by local anomalous errors. This approach maintains a balance between accuracy enhancement and computational efficiency. In the marked background grid, if the error of the node is larger than the error threshold, the node is marked. The error is calculated according to [<xref rid="B18-sensors-25-01115" ref-type="bibr">18</xref>]:<disp-formula id="FD12-sensors-25-01115"><label>(12)</label><mml:math id="mm12" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>&#x000ea;</mml:mi><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfenced close="|" open="|"><mml:mrow><mml:msub><mml:mi mathvariant="normal">&#x003a6;</mml:mi><mml:mi>h</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi mathvariant="normal">&#x003a6;</mml:mi><mml:mi>c</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfenced><mml:mo>,</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>
where &#x003a6;<italic toggle="yes"><sub>h</sub></italic> and &#x003a6;<italic toggle="yes"><sub>c</sub></italic> are high-precision and current solutions, respectively. In this paper, &#x003a6;<italic toggle="yes"><sub>h</sub></italic> is a solution obtained with 1/2 <italic toggle="yes">l</italic><sub>0</sub>.</p><p>In the second step, a hybrid method based on centroid [<xref rid="B19-sensors-25-01115" ref-type="bibr">19</xref>] and midpoints [<xref rid="B20-sensors-25-01115" ref-type="bibr">20</xref>] refinement is proposed to add nodes around the marked nodes found by the first step. New nodes are generated based on the position and number of the marked nodes. There are four basic node adding patterns, which are shown in <xref rid="sensors-25-01115-f001" ref-type="fig">Figure 1</xref>. The arrow illustrates the process of generating additional nodes through the marked nodes The pseudocode for the hybrid refinement algorithm is presented in Algorithm 1. Lines 1&#x02013;13 detail the process of marking the precision nodes, while lines 14&#x02013;38 outline four basic node adding patterns.</p><p>Case 1: Only one node is marked. A nearest neighbor search is used to find the closest node to the marked node. If the marked node has equal distances to its neighbor nodes, the node with the largest error is chosen as the closest node. The midpoint between the marked node and its closest node is added, as in <xref rid="sensors-25-01115-f001" ref-type="fig">Figure 1</xref>a and Algorithm 1, lines 15&#x02013;21.</p><p>Case 2: Two nodes are marked. A new node is added directly at the midpoint of the two marked nodes, as in <xref rid="sensors-25-01115-f001" ref-type="fig">Figure 1</xref>b and Algorithm 1, lines 22&#x02013;24.</p><p>Case 3: Three nodes are marked. It is checked as to whether the marked nodes can form a triangle or not. If a triangle cannot be formed, the midpoints of the marked node are generated as adding nodes, as in <xref rid="sensors-25-01115-f001" ref-type="fig">Figure 1</xref>c; otherwise, the centroid point of the triangle is added, as in <xref rid="sensors-25-01115-f001" ref-type="fig">Figure 1</xref>d and Algorithm 1, lines 25&#x02013;32.</p><p>Case 4: More than three nodes are marked. Three of the marked nodes are chosen and then Case 3 is implemented. The node with largest error among the marked nodes is identified and two neighbor marked nodes are located using nearest neighbor search, as in Algorithm 1, lines 15&#x02013;21.</p><p>The newly added node <italic toggle="yes">N<sub>A</sub></italic> of the midpoint and <italic toggle="yes">N<sub>B</sub></italic> of the centroid algorithm are defined as follows:<disp-formula id="FD13-sensors-25-01115"><label>(13)</label><mml:math id="mm13" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>A</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mn>2</mml:mn></mml:mfrac></mml:mstyle><mml:mo>,</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:msub><mml:mi>y</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msub></mml:mrow><mml:mn>2</mml:mn></mml:mfrac></mml:mstyle><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula><disp-formula id="FD14-sensors-25-01115"><label>(14)</label><mml:math id="mm14" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>B</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mn>3</mml:mn></mml:mfrac></mml:mstyle><mml:mo>,</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:msub><mml:mi>y</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>3</mml:mn></mml:msub></mml:mrow><mml:mn>3</mml:mn></mml:mfrac></mml:mstyle><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>
<array><tbody><tr><td colspan="2" align="left" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1"><bold>Algorithm 1:</bold> Adaptive Refinement for RPIM</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">1:</td><td align="left" valign="middle" rowspan="1" colspan="1"><bold>Initialize</bold> node and grid distribution, maximum iteration count <bold><italic toggle="yes">i<sub>max</sub></italic></bold></td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">2:</td><td align="left" valign="middle" rowspan="1" colspan="1"><bold>While</bold> (iteration &#x0003c; i<sub>max</sub>) <bold>do</bold></td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">3:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;Calculate errors for each node</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">4:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;<bold>for</bold> each background grid:</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">5:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;&#x02003;<bold><italic toggle="yes">E<sub>g</sub></italic></bold> &#x02190; maximum error of each grid</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">6:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;<bold>end</bold>
<bold>for</bold>
</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">7:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;Mark the background grid with the largest <bold><italic toggle="yes">E<sub>g</sub></italic></bold></td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">8:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;<bold>Error threshold</bold> &#x02190; second-largest <bold><italic toggle="yes">E<sub>g</sub></italic></bold></td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">9:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;<bold>for</bold> each node in the marked background grid:</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">10:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;&#x02003;<bold>If</bold> error (node) &#x0003e; error threshold:</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">11:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;&#x02003;&#x02003;Mark this node</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">12:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;&#x02003;<bold>end</bold>
<bold>if</bold>
</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">13:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;<bold>end</bold>
<bold>for</bold>
</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">14:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;<bold><italic toggle="yes">x</italic></bold> &#x02190; number of the marked node</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">15:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;<bold>If</bold> x = 1:</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">16:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;&#x02003;The closest node &#x02190; nearest neighbor search</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">17:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;&#x02003;<bold>If</bold> number of the closest node &#x02260; 1:</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">18:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;&#x02003;&#x02003;The closest node &#x02190; the closest node with the largest error</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">19:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;&#x02003;<bold>end</bold>
<bold>if</bold>
</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">20:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;&#x02003;Refined nodes = initial nodes + midpoint (the marked node, the closest node)</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">21:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;<bold>end</bold>
<bold>if</bold>
</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">22:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;<bold>If</bold> x = 2:</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">23:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;&#x02003;Refined nodes = initial nodes + midpoint (the marked node)</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">24:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;<bold>end</bold>
<bold>if</bold>
</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">25:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;<bold>If</bold> x = 3:</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">26:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;&#x02003;<bold>If</bold> the three nodes form a triangle:</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">27:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;&#x02003;&#x02003;Refined nodes = initial nodes + centroid (the marked node)</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">28:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;&#x02003;<bold>end</bold>
<bold>if</bold>
</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">29:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;&#x02003;<bold>else</bold>
</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">30:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;&#x02003;&#x02003;Refined nodes = initial nodes + midpoint (the marked node)</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">31:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;&#x02003;<bold>end else</bold>
</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">32:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;<bold>end</bold>
<bold>if</bold>
</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">33:</td><td align="left" valign="middle" rowspan="1" colspan="1"><bold>If</bold> x &#x0003e; 3:</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">34:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;&#x02003;The marked node with the largest error &#x02190; nearest neighbor search</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">35:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;&#x02003;Back to 25</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">36:</td><td align="left" valign="middle" rowspan="1" colspan="1">&#x02003;<bold>end</bold>
<bold>if</bold>
</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">37:</td><td align="left" valign="middle" rowspan="1" colspan="1"><bold>end while</bold></td></tr><tr><td align="left" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">38:</td><td align="left" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1"><bold>Return</bold> refined node distribution</td></tr></tbody></array></p></sec><sec id="sec2dot4-sensors-25-01115"><title>2.4. Algorithm Description</title><p>To demonstrate the proposed algorithm intuitively, a flow chart of the proposed algorithm is shown in <xref rid="sensors-25-01115-f002" ref-type="fig">Figure 2</xref>. The algorithm is explained in detail:</p><p>Step 1: Set model parameters, including the size of the domain, object material, and location.</p><p>Step 2: Set the minimum gap width between two materials as the width of the background grid.</p><p>Step 3: Calculate the <italic toggle="yes">l<sub>step</sub></italic> using Equation (11) to set uniformly-distributed nodes, and then proceed with the calculation using initial grids and nodes.</p><p>Step 4: Compute the errors on the nodes with Equation (12), determine the marked background grid and the error threshold of the current iteration, and determine the marked nodes.</p><p>Step 5: Check the number of marked nodes, and generate adding nodes according to the proposed hybrid refinement algorithm.</p><p>Step 6: Calculate the results with the new nodes using the RPIM. If the iteration number is higher than the preset iteration number <italic toggle="yes">i<sub>max</sub></italic>, go to Step 7; otherwise, go to Step 4.</p><p>Step 7: Stop the algorithm.</p></sec></sec><sec id="sec3-sensors-25-01115"><title>3. Numerical Results</title><p>To verify the performance of the proposed algorithm, it was implemented using MATLABR2021b to solve electromagnetic problems in electrostatic fields [<xref rid="B21-sensors-25-01115" ref-type="bibr">21</xref>] and multi-media magnetic fields [<xref rid="B22-sensors-25-01115" ref-type="bibr">22</xref>].</p><sec id="sec3dot1-sensors-25-01115"><title>3.1. Square Metal Box</title><p>The voltage potential of a 2-D square metal box was computed using the proposed method. The square metal box was 3 m long and 1 m wide. The width of the background grid <italic toggle="yes">w</italic> was 1 m, and <italic toggle="yes">l<sub>0</sub></italic> was 1/3 m. <xref rid="sensors-25-01115-f003" ref-type="fig">Figure 3</xref> demonstrates the background grids and initial and final node distribution. As shown in <xref rid="sensors-25-01115-f003" ref-type="fig">Figure 3</xref>a, three background grids were used and 40 initial nodes were obtained using the initial node-generation method. In <xref rid="sensors-25-01115-f003" ref-type="fig">Figure 3</xref>b, the red points represent the marked nodes, while the points marked <italic toggle="yes">x</italic> represent the added nodes through iterations. <xref rid="sensors-25-01115-f004" ref-type="fig">Figure 4</xref> shows the error distribution of results obtained by the proposed method. <xref rid="sensors-25-01115-f005" ref-type="fig">Figure 5</xref> displays the contour of voltage potential using the automatic adaptive scheme, demonstrating that the proposed method can obtain the voltage potential in the computational domain.</p><p><xref rid="sensors-25-01115-t001" ref-type="table">Table 1</xref> provides the key parameters in iterative processes. In <xref rid="sensors-25-01115-t001" ref-type="table">Table 1</xref>, <italic toggle="yes">i</italic> stands for the number of iterations, <italic toggle="yes">&#x000ea;<sub>max</sub></italic> represents the maximum error among all current nodes calculated by Equation (12), and <italic toggle="yes">error_th</italic> denotes the dynamic error threshold for each iteration. As shown in <xref rid="sensors-25-01115-t001" ref-type="table">Table 1</xref>, the maximum error decreases as the additional nodes are added, indicating that the proposed refinement algorithm can generate proper adding nodes to promote the calculation accuracy. <xref rid="sensors-25-01115-t002" ref-type="table">Table 2</xref> presents the comparison of the hybrid method in [<xref rid="B21-sensors-25-01115" ref-type="bibr">21</xref>], the RBF method in [<xref rid="B20-sensors-25-01115" ref-type="bibr">20</xref>], and the proposed method. The analytic solution of this benchmark problem is given in [<xref rid="B21-sensors-25-01115" ref-type="bibr">21</xref>]; <italic toggle="yes">E<sub>max</sub></italic> is the maximum absolute error between the numerical solution and analytic solution. As shown in <xref rid="sensors-25-01115-t002" ref-type="table">Table 2</xref>, the proposed method not only achieves the lowest <italic toggle="yes">E<sub>max</sub></italic> with a relatively small number of nodes but also demonstrates significant advantages in terms of both runtime and memory consumption. This highlights the method&#x02019;s ability to balance accuracy, efficiency, and computational resources effectively.</p></sec><sec id="sec3dot2-sensors-25-01115"><title>3.2. Static Iron Piece</title><p>The magnetic potential <italic toggle="yes">A<sub>Z</sub></italic> of a static iron piece was computed using the proposed method. The static iron piece is shown in <xref rid="sensors-25-01115-f006" ref-type="fig">Figure 6</xref>. In the iron piece, the current density in the coil was 250 A/cm<sup>2</sup> and the permeability of the coil and the iron were <italic toggle="yes">&#x003c6;</italic><sub>0</sub> and 4000 <italic toggle="yes">&#x003c6;</italic><sub>0</sub>, respectively [<xref rid="B22-sensors-25-01115" ref-type="bibr">22</xref>]. The width of the grid was set as 1 cm, and <italic toggle="yes">l<sub>o</sub></italic> was 1/2 cm, with a total of 64 background grids. The number of initial nodes was 289 and 7 additional nodes were added to solve this problem.</p><p>The equivalent lines of vector magnetic potential are given in <xref rid="sensors-25-01115-f007" ref-type="fig">Figure 7</xref>, which demonstrates that the proposed method can obtain the magnetic potential in the computational domain. The maximum error <italic toggle="yes">E<sub>max</sub></italic>, and condition number and <italic toggle="yes">A<sub>z</sub></italic> of four nodes are compared in <xref rid="sensors-25-01115-t003" ref-type="table">Table 3</xref>. <italic toggle="yes">E<sub>max</sub></italic> was calculated by comparison with the FEM results obtained from commercial software. The coordinates of four nodes were (1,1), (1,2), (1,3), and (0,5), which were selected randomly as represented nodes. From <xref rid="sensors-25-01115-t003" ref-type="table">Table 3</xref>, it can be seen that the background grids can decrease the condition number and promote the computational accuracy; adding additional nodes can enhance the computational accuracy, but the conditional number also increases. <xref rid="sensors-25-01115-t003" ref-type="table">Table 3</xref> demonstrates that the proposed method not only achieves a desired balance between condition number and computational accuracy but also offers significant advantages in terms of both runtime and memory usage. This further underscores the method&#x02019;s efficiency and effectiveness in handling computational resources while maintaining high accuracy.</p><p>The number of grids is determined by the width of grid <italic toggle="yes">w</italic>, and the number of nodes is determined by node generation step <italic toggle="yes">l<sub>step</sub></italic>. A comparison of different numbers of grids, nodes, and additional nodes is given. The parameters were set as follows: <italic toggle="yes">w</italic> = 1 cm, 0.5 cm, and 0.25 cm and <italic toggle="yes">l<sub>step</sub></italic> = 1/2<italic toggle="yes">w</italic>; therefore, the numbers of girds and nodes were 64 and 289, 256 and 1089, and 1024 and 4225. The number of additional nodes was set as 0, 3, 5, 7, and 15. <xref rid="sensors-25-01115-f008" ref-type="fig">Figure 8</xref> presents the condition number and the maximum error <italic toggle="yes">E<sub>max</sub></italic> with different numbers of grids, nodes, and additional nodes. The results show that the condition number was rising as the number of nodes increased. <italic toggle="yes">E<sub>max</sub></italic> was decreasing with the rising number of nodes when the total number of nodes was relatively small, as shown in <xref rid="sensors-25-01115-f008" ref-type="fig">Figure 8</xref>a,b. However, when the total number of nodes was relatively high, as shown in <xref rid="sensors-25-01115-f008" ref-type="fig">Figure 8</xref>b,c, <italic toggle="yes">E<sub>max</sub></italic> was increasing with more additional nodes. That is because too many nodes may cause the solving equation to be unstable.</p></sec></sec><sec sec-type="conclusions" id="sec4-sensors-25-01115"><title>4. Conclusions</title><p>In this paper, we propose a node generation and adaptive refinement algorithm within the meshless RPIM framework for electromagnetic computations. The simulation results demonstrate that the proposed method effectively generates high-quality nodes, achieving an optimal balance between computational accuracy and complexity. This method has also proved particularly advantageous for simulations in complex electromagnetic environments and multi-scale problems, enabling more accurate analysis of electromagnetic characteristics in sensor design. Its ability to handle intricate geometries and multi-material systems provides significant practical benefits, especially in sensor optimization. Overall, the proposed approach offers a promising tool for enhancing the design and performance of electromagnetic systems in real-world applications.</p></sec></body><back><fn-group><fn><p><bold>Disclaimer/Publisher&#x02019;s Note:</bold> The statements, opinions and data contained in all publications are solely those of the individual author(s) and contributor(s) and not of MDPI and/or the editor(s). MDPI and/or the editor(s) disclaim responsibility for any injury to people or property resulting from any ideas, methods, instructions or products referred to in the content.</p></fn></fn-group><notes><title>Author Contributions</title><p>Z.L. implemented the main code and wrote the initial draft of the manuscript; S.A. developed the framework of the algorithm and evaluated its performance; G.Z. constructed the model for the electromagnetic problem and conducted the data analysis; J.H. revised and polished the manuscript. All authors have read and agreed to the published version of the manuscript.</p></notes><notes><title>Institutional Review Board Statement</title><p>Not applicable.</p></notes><notes><title>Informed Consent Statement</title><p>Not applicable.</p></notes><notes notes-type="data-availability"><title>Data Availability Statement</title><p>No new data were created or analyzed in this study. Data sharing is not applicable to this article.</p></notes><notes notes-type="COI-statement"><title>Conflicts of Interest</title><p>The authors declare no conflicts of interest.</p></notes><ref-list><title>References</title><ref id="B1-sensors-25-01115"><label>1.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Zhao</surname><given-names>M.</given-names></name>
<name><surname>Zhou</surname><given-names>X.</given-names></name>
<name><surname>Chen</surname><given-names>Y.</given-names></name>
</person-group><article-title>A highly sensitive and miniature optical fiber sensor for electromagnetic pulse fields</article-title><source>Sensors</source><year>2021</year><volume>21</volume><elocation-id>8137</elocation-id><pub-id pub-id-type="doi">10.3390/s21238137</pub-id><pub-id pub-id-type="pmid">34884141</pub-id>
</element-citation></ref><ref id="B2-sensors-25-01115"><label>2.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Chen</surname><given-names>J.</given-names></name>
<name><surname>Guo</surname><given-names>Y.</given-names></name>
</person-group><article-title>Design and Non-Linearity Optimization of a Vertical Brushless Electric Power Steering Angle Sensor</article-title><source>Sensors</source><year>2024</year><volume>24</volume><elocation-id>2469</elocation-id><pub-id pub-id-type="doi">10.3390/s24082469</pub-id><pub-id pub-id-type="pmid">38676086</pub-id>
</element-citation></ref><ref id="B3-sensors-25-01115"><label>3.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Beato-L&#x000f3;pez</surname><given-names>J.J.</given-names></name>
<name><surname>Royo-Silvestre</surname><given-names>I.</given-names></name>
<name><surname>Algueta-Miguel</surname><given-names>J.M.</given-names></name>
<name><surname>Gomez-Polo</surname><given-names>C.</given-names></name>
</person-group><article-title>A combination of a vibrational electromagnetic energy harvester and a giant magnetoimpedance (GMI) sensor</article-title><source>Sensors</source><year>2020</year><volume>207</volume><elocation-id>1873</elocation-id><pub-id pub-id-type="doi">10.3390/s20071873</pub-id><pub-id pub-id-type="pmid">32230989</pub-id>
</element-citation></ref><ref id="B4-sensors-25-01115"><label>4.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Razek</surname><given-names>A.</given-names></name>
</person-group><article-title>Assessment of a Functional Electromagnetic Compatibility Analysis of Near-Body Medical Devices Subject to Electromagnetic Field Perturbation</article-title><source>Electronics</source><year>2023</year><volume>12</volume><elocation-id>4780</elocation-id><pub-id pub-id-type="doi">10.3390/electronics12234780</pub-id></element-citation></ref><ref id="B5-sensors-25-01115"><label>5.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Ji</surname><given-names>Y.</given-names></name>
<name><surname>Yu</surname><given-names>Y.</given-names></name>
<name><surname>Zhao</surname><given-names>X.</given-names></name>
</person-group><article-title>Characteristic research on electromagnetic response of two-dimensional complex structure targets based on meshless method</article-title><source>Radio Sci.</source><year>2023</year><volume>58</volume><fpage>1</fpage><lpage>13</lpage><pub-id pub-id-type="doi">10.1029/2022RS007636</pub-id></element-citation></ref><ref id="B6-sensors-25-01115"><label>6.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Ye</surname><given-names>L.</given-names></name>
<name><surname>Hu</surname><given-names>S.</given-names></name>
<name><surname>Xu</surname><given-names>G.</given-names></name>
<name><surname>Yan</surname><given-names>T.</given-names></name>
</person-group><article-title>A meshless regularized method of fundamental solution for electromagnetic scattering problems of three-dimensional perfect electric conductor targets</article-title><source>Eng. Anal. Bound. Elem.</source><year>2023</year><volume>155</volume><fpage>401</fpage><lpage>406</lpage><pub-id pub-id-type="doi">10.1016/j.enganabound.2023.05.050</pub-id></element-citation></ref><ref id="B7-sensors-25-01115"><label>7.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Zhang</surname><given-names>M.</given-names></name>
<name><surname>Farquharson</surname><given-names>C.G.</given-names></name>
<name><surname>Lin</surname><given-names>T.</given-names></name>
</person-group><article-title>3-D forward modelling of controlled-source frequency-domain electromagnetic data using the meshless generalized finite-difference method</article-title><source>Geophys. J. Int.</source><year>2023</year><volume>235</volume><fpage>750</fpage><lpage>764</lpage><pub-id pub-id-type="doi">10.1093/gji/ggad272</pub-id></element-citation></ref><ref id="B8-sensors-25-01115"><label>8.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Long</surname><given-names>J.</given-names></name>
</person-group><article-title>Meshfree modelling of magnetotelluric and controlled-source electromagnetic data for conductive earth models with complex geometries</article-title><source>Int. J. Appl. Electromagn. Mech. Front. Earth Sci.</source><year>2024</year><volume>12</volume><fpage>1432992</fpage><pub-id pub-id-type="doi">10.3389/feart.2024.1432992</pub-id></element-citation></ref><ref id="B9-sensors-25-01115"><label>9.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Nikan</surname><given-names>O.</given-names></name>
<name><surname>Avazzadeh</surname><given-names>Z.</given-names></name>
<name><surname>Machado</surname><given-names>J.T.</given-names></name>
<name><surname>Rasoulizadeh</surname><given-names>M.N.</given-names></name>
</person-group><article-title>An accurate localized meshfree collocation technique for the telegraph equation in propagation of electrical signals</article-title><source>Eng. Comput.</source><year>2023</year><volume>39</volume><fpage>2327</fpage><lpage>2344</lpage><pub-id pub-id-type="doi">10.1007/s00366-022-01630-9</pub-id></element-citation></ref><ref id="B10-sensors-25-01115"><label>10.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Saberi</surname><given-names>H.</given-names></name>
<name><surname>Nguyen</surname><given-names>C.T.</given-names></name>
<name><surname>Saberi</surname><given-names>H.</given-names></name>
<name><surname>Sabagh</surname><given-names>M.</given-names></name>
<name><surname>Nguyen</surname><given-names>M.N.</given-names></name>
<name><surname>Bui</surname><given-names>T.Q.</given-names></name>
</person-group><article-title>A computational meshfree RPIM approach for phase-field modeling of brittle fracture</article-title><source>Acta Mech.</source><year>2024</year><volume>235</volume><fpage>3721</fpage><lpage>3743</lpage><pub-id pub-id-type="doi">10.1007/s00707-024-03911-4</pub-id></element-citation></ref><ref id="B11-sensors-25-01115"><label>11.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Bartwal</surname><given-names>N.</given-names></name>
<name><surname>Shahane</surname><given-names>S.</given-names></name>
<name><surname>Roy</surname><given-names>S.</given-names></name>
<name><surname>Vanka</surname><given-names>S.P.</given-names></name>
</person-group><article-title>Simulation of heat conduction in complex domains of multi-material composites using a meshless method</article-title><source>Appl. Math. Comput.</source><year>2023</year><volume>457</volume><fpage>128208</fpage><pub-id pub-id-type="doi">10.1016/j.amc.2023.128208</pub-id></element-citation></ref><ref id="B12-sensors-25-01115"><label>12.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Rao</surname><given-names>X.</given-names></name>
<name><surname>Zhao</surname><given-names>H.</given-names></name>
<name><surname>Liu</surname><given-names>Y.</given-names></name>
</person-group><article-title>A novel meshless method based on the virtual construction of node control domains for porous flow problems</article-title><source>Eng. Comput.</source><year>2024</year><volume>40</volume><fpage>171</fpage><lpage>211</lpage><pub-id pub-id-type="doi">10.1007/s00366-022-01776-6</pub-id></element-citation></ref><ref id="B13-sensors-25-01115"><label>13.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Safari</surname><given-names>F.</given-names></name>
<name><surname>Duan</surname><given-names>Y.</given-names></name>
</person-group><article-title>A novel meshless method in conjunction with a regularization technique for solving the transient heat source with additive noise</article-title><source>Int. Commun. Heat Mass Transf.</source><year>2024</year><volume>158</volume><fpage>107949</fpage><pub-id pub-id-type="doi">10.1016/j.icheatmasstransfer.2024.107949</pub-id></element-citation></ref><ref id="B14-sensors-25-01115"><label>14.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Dang</surname><given-names>O.T.</given-names></name>
</person-group><article-title>An Improved Adaptive Meshless Refinement for the RBF-FD Method for 2D Elliptic Equations</article-title><source>Vietnam. J. Math.</source><year>2024</year><volume>53</volume><fpage>365</fpage><lpage>387</lpage><pub-id pub-id-type="doi">10.1007/s10013-023-00678-4</pub-id></element-citation></ref><ref id="B15-sensors-25-01115"><label>15.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Peng</surname><given-names>J.</given-names></name>
<name><surname>Feng</surname><given-names>R.</given-names></name>
<name><surname>Xue</surname><given-names>M.</given-names></name>
<name><surname>Zhou</surname><given-names>E.</given-names></name>
<name><surname>Wang</surname><given-names>J.</given-names></name>
<name><surname>Zhong</surname><given-names>Z.</given-names></name>
<name><surname>Ku</surname><given-names>X.</given-names></name>
</person-group><article-title>Research Progress and Engineering Applications of Viscous Fluid Mechanics</article-title><source>Appl. Sci.</source><year>2025</year><volume>15</volume><elocation-id>357</elocation-id><pub-id pub-id-type="doi">10.3390/app15010357</pub-id></element-citation></ref><ref id="B16-sensors-25-01115"><label>16.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Marcinkevicius</surname><given-names>R.</given-names></name>
<name><surname>Telksniene</surname><given-names>I.</given-names></name>
<name><surname>Telksnys</surname><given-names>T.</given-names></name>
<name><surname>Navickas</surname><given-names>Z.</given-names></name>
<name><surname>Ragulskis</surname><given-names>M.</given-names></name>
</person-group><article-title>The step-wise construction of solitary solutions to Riccati equations with diffusive coupling</article-title><source>AIMS Math.</source><year>2023</year><volume>8</volume><fpage>30683</fpage><lpage>30703</lpage><pub-id pub-id-type="doi">10.3934/math.20231568</pub-id></element-citation></ref><ref id="B17-sensors-25-01115"><label>17.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Ershkov</surname><given-names>S.</given-names></name>
<name><surname>Leshchenko</surname><given-names>D.</given-names></name>
</person-group><article-title>Solving procedure for the dynamics of charged particle in variable (time-dependent) electromagnetic field</article-title><source>Z. F&#x000fc;r Angew. Math. Phys.</source><year>2020</year><volume>71</volume><fpage>1</fpage><lpage>8</lpage><pub-id pub-id-type="doi">10.1007/s00033-020-01298-5</pub-id></element-citation></ref><ref id="B18-sensors-25-01115"><label>18.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Li</surname><given-names>Q.</given-names></name>
<name><surname>Lee</surname><given-names>K.M.</given-names></name>
</person-group><article-title>An adaptive meshless method for magnetic field computation</article-title><source>IEEE Trans. Magn.</source><year>2006</year><volume>42</volume><fpage>1996</fpage><lpage>2003</lpage><pub-id pub-id-type="doi">10.1109/TMAG.2006.876126</pub-id></element-citation></ref><ref id="B19-sensors-25-01115"><label>19.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Kaennakham</surname><given-names>S.</given-names></name>
<name><surname>Chuathong</surname><given-names>N.</given-names></name>
</person-group><article-title>An automatic node-adaptive scheme applied with a RBF-collocation meshless method</article-title><source>Appl. Math. Comput.</source><year>2019</year><volume>348</volume><fpage>102</fpage><lpage>125</lpage><pub-id pub-id-type="doi">10.1016/j.amc.2018.11.066</pub-id></element-citation></ref><ref id="B20-sensors-25-01115"><label>20.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Cavoretto</surname><given-names>R.</given-names></name>
<name><surname>De Rossi</surname><given-names>A.</given-names></name>
</person-group><article-title>A two-stage adaptive scheme based on RBF collocation for solving elliptic PDEs</article-title><source>Comput. Math. Appl.</source><year>2020</year><volume>79</volume><fpage>3206</fpage><lpage>3222</lpage><pub-id pub-id-type="doi">10.1016/j.camwa.2020.01.018</pub-id></element-citation></ref><ref id="B21-sensors-25-01115"><label>21.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Zou</surname><given-names>Y.</given-names></name>
<name><surname>Lei</surname><given-names>G.</given-names></name>
<name><surname>Shao</surname><given-names>K.</given-names></name>
</person-group><article-title>Hybrid approach of radial basis function and finite element method for electromagnetic problems</article-title><source>IEEE Trans. Magn.</source><year>2015</year><volume>51</volume><fpage>1</fpage><lpage>4</lpage><pub-id pub-id-type="doi">10.1109/TMAG.2014.2354371</pub-id><pub-id pub-id-type="pmid">26203196</pub-id>
</element-citation></ref><ref id="B22-sensors-25-01115"><label>22.</label><element-citation publication-type="confproc"><person-group person-group-type="author">
<name><surname>da Rocha Coppoli</surname><given-names>E.H.</given-names></name>
<name><surname>Ramdane</surname><given-names>B.</given-names></name>
<name><surname>Mar&#x000e9;chal</surname><given-names>Y.</given-names></name>
</person-group><article-title>Meshless Local Radial Point Interpolation Method for Electromagnetic Devices Modeling</article-title><source>Proceedings of the 19th International Symposium on Electromagnetic Fields in Mechatronics, Electrical and Electronic Engineering (ISEF)</source><conf-loc>Nancy, France</conf-loc><conf-date>29&#x02013;31 August 2019</conf-date><fpage>1</fpage><lpage>2</lpage></element-citation></ref></ref-list></back><floats-group><fig position="float" id="sensors-25-01115-f001"><label>Figure 1</label><caption><p>Different node-adding patterns in hybrid refinement method.</p></caption><graphic xlink:href="sensors-25-01115-g001" position="float"/></fig><fig position="float" id="sensors-25-01115-f002"><label>Figure 2</label><caption><p>Flow chart of the proposed algorithm.</p></caption><graphic xlink:href="sensors-25-01115-g002" position="float"/></fig><fig position="float" id="sensors-25-01115-f003"><label>Figure 3</label><caption><p>The initial and final node and grid distribution.</p></caption><graphic xlink:href="sensors-25-01115-g003" position="float"/></fig><fig position="float" id="sensors-25-01115-f004"><label>Figure 4</label><caption><p>Error distribution of results based on the improved error indicator.</p></caption><graphic xlink:href="sensors-25-01115-g004" position="float"/></fig><fig position="float" id="sensors-25-01115-f005"><label>Figure 5</label><caption><p>Contour of potential using the proposed method.</p></caption><graphic xlink:href="sensors-25-01115-g005" position="float"/></fig><fig position="float" id="sensors-25-01115-f006"><label>Figure 6</label><caption><p>A static iron piece.</p></caption><graphic xlink:href="sensors-25-01115-g006" position="float"/></fig><fig position="float" id="sensors-25-01115-f007"><label>Figure 7</label><caption><p>Equivalent lines of vector magnetic potential.</p></caption><graphic xlink:href="sensors-25-01115-g007" position="float"/></fig><fig position="float" id="sensors-25-01115-f008"><label>Figure 8</label><caption><p>Comparison of calculation results with different parameters.</p></caption><graphic xlink:href="sensors-25-01115-g008" position="float"/></fig><table-wrap position="float" id="sensors-25-01115-t001"><object-id pub-id-type="pii">sensors-25-01115-t001_Table 1</object-id><label>Table 1</label><caption><p>Parameters in iterative processes.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">
<italic toggle="yes">i</italic>
</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">
<italic toggle="yes">&#x000ea;<sub>max</sub></italic>
</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">No. Nodes</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">
<italic toggle="yes">Error_th</italic>
</th></tr></thead><tbody><tr><td align="center" valign="middle" rowspan="1" colspan="1">0</td><td align="center" valign="middle" rowspan="1" colspan="1">8.677 &#x000d7; 10<sup>&#x02212;3</sup></td><td align="center" valign="middle" rowspan="1" colspan="1">40</td><td align="center" valign="middle" rowspan="1" colspan="1">6.25 &#x000d7; 10<sup>&#x02212;3</sup></td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">1</td><td align="center" valign="middle" rowspan="1" colspan="1">5.908 &#x000d7; 10<sup>&#x02212;3</sup></td><td align="center" valign="middle" rowspan="1" colspan="1">41</td><td align="center" valign="middle" rowspan="1" colspan="1">5.67 &#x000d7; 10<sup>&#x02212;3</sup></td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">2</td><td align="center" valign="middle" rowspan="1" colspan="1">5.718 &#x000d7; 10<sup>&#x02212;3</sup></td><td align="center" valign="middle" rowspan="1" colspan="1">42</td><td align="center" valign="middle" rowspan="1" colspan="1">5.56 &#x000d7; 10<sup>&#x02212;3</sup></td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">3</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">5.410 &#x000d7; 10<sup>&#x02212;3</sup></td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">42</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">----------</td></tr></tbody></table></table-wrap><table-wrap position="float" id="sensors-25-01115-t002"><object-id pub-id-type="pii">sensors-25-01115-t002_Table 2</object-id><label>Table 2</label><caption><p>Comparison of different methods.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Algorithm</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">
<italic toggle="yes">E<sub>max</sub></italic>
</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Runtime (s)</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Memory (MB)</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">No. Nodes</th></tr></thead><tbody><tr><td align="center" valign="middle" rowspan="1" colspan="1">Hybrid method in [<xref rid="B21-sensors-25-01115" ref-type="bibr">21</xref>]</td><td align="center" valign="middle" rowspan="1" colspan="1">9.80 &#x000d7; 10<sup>&#x02212;3</sup></td><td align="center" valign="middle" rowspan="1" colspan="1">0.84</td><td align="center" valign="middle" rowspan="1" colspan="1">1.23</td><td align="center" valign="middle" rowspan="1" colspan="1">40</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">RBF method in [<xref rid="B20-sensors-25-01115" ref-type="bibr">20</xref>]</td><td align="center" valign="middle" rowspan="1" colspan="1">7.65 &#x000d7; 10<sup>&#x02212;3</sup></td><td align="center" valign="middle" rowspan="1" colspan="1">2.61</td><td align="center" valign="middle" rowspan="1" colspan="1">2.31</td><td align="center" valign="middle" rowspan="1" colspan="1">110</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">The proposed method</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">4.95 &#x000d7; 10<sup>&#x02212;3</sup></td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">0.93</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">1.87</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">43</td></tr></tbody></table></table-wrap><table-wrap position="float" id="sensors-25-01115-t003"><object-id pub-id-type="pii">sensors-25-01115-t003_Table 3</object-id><label>Table 3</label><caption><p>Comparison of different strategies and FEM.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Method</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Nodes</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Condition Number</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Runtime<break/>(s)</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Memory<break/>(MB)</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">
<italic toggle="yes">E<sub>max</sub></italic>
</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1"><italic toggle="yes">A<sub>z</sub></italic>1<break/>(Wb/m)</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1"><italic toggle="yes">A<sub>z</sub></italic>2<break/>(Wb/m)</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1"><italic toggle="yes">A<sub>z</sub></italic>3<break/>(Wb/m)</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1"><italic toggle="yes">A<sub>z</sub></italic>4<break/>(Wb/m)</th></tr></thead><tbody><tr><td align="center" valign="middle" rowspan="1" colspan="1">FEM</td><td align="center" valign="middle" rowspan="1" colspan="1">365</td><td align="center" valign="middle" rowspan="1" colspan="1">----------</td><td align="center" valign="middle" rowspan="1" colspan="1">----------</td><td align="center" valign="middle" rowspan="1" colspan="1">----------</td><td align="center" valign="middle" rowspan="1" colspan="1">----------</td><td align="center" valign="middle" rowspan="1" colspan="1">0.3194</td><td align="center" valign="middle" rowspan="1" colspan="1">0.5899</td><td align="center" valign="middle" rowspan="1" colspan="1">0.7414</td><td align="center" valign="middle" rowspan="1" colspan="1">0.8510</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">Without grids</td><td align="center" valign="middle" rowspan="1" colspan="1">289</td><td align="center" valign="middle" rowspan="1" colspan="1">1.5826 &#x000d7; 10<sup>9</sup></td><td align="center" valign="middle" rowspan="1" colspan="1">11.23</td><td align="center" valign="middle" rowspan="1" colspan="1">13.76</td><td align="center" valign="middle" rowspan="1" colspan="1">1.8 &#x000d7; 10<sup>&#x02212;2</sup></td><td align="center" valign="middle" rowspan="1" colspan="1">0.3163</td><td align="center" valign="middle" rowspan="1" colspan="1">0.5877</td><td align="center" valign="middle" rowspan="1" colspan="1">0.7295</td><td align="center" valign="middle" rowspan="1" colspan="1">0.8331</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">Without refinemen</td><td align="center" valign="middle" rowspan="1" colspan="1">289</td><td align="center" valign="middle" rowspan="1" colspan="1">1.2638 &#x000d7; 10<sup>&#x02212;5</sup></td><td align="center" valign="middle" rowspan="1" colspan="1">2.01</td><td align="center" valign="middle" rowspan="1" colspan="1">1.97</td><td align="center" valign="middle" rowspan="1" colspan="1">9.8 &#x000d7; 10<sup>&#x02212;3</sup></td><td align="center" valign="middle" rowspan="1" colspan="1">0.3199</td><td align="center" valign="middle" rowspan="1" colspan="1">0.5943</td><td align="center" valign="middle" rowspan="1" colspan="1">0.7378</td><td align="center" valign="middle" rowspan="1" colspan="1">0.8426</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Proposed method</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">296</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">2.5120 &#x000d7; 10<sup>&#x02212;5</sup></td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">7.39</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">2.01</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">7.9 &#x000d7; 10<sup>&#x02212;3</sup></td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">0.3207</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">0.5954</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">0.7385</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">0.8431</td></tr></tbody></table></table-wrap></floats-group></article>