<!DOCTYPE article
PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD with MathML3 v1.3 20210610//EN" "JATS-archivearticle1-3-mathml3.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.3" xml:lang="en" article-type="research-article"><?properties open_access?><processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats"><restricted-by>pmc</restricted-by></processing-meta><front><journal-meta><journal-id journal-id-type="nlm-ta">Sensors (Basel)</journal-id><journal-id journal-id-type="iso-abbrev">Sensors (Basel)</journal-id><journal-id journal-id-type="publisher-id">sensors</journal-id><journal-title-group><journal-title>Sensors (Basel, Switzerland)</journal-title></journal-title-group><issn pub-type="epub">1424-8220</issn><publisher><publisher-name>MDPI</publisher-name></publisher></journal-meta>
<article-meta><article-id pub-id-type="pmid">40006505</article-id><article-id pub-id-type="pmc">PMC11860518</article-id><article-id pub-id-type="doi">10.3390/s25041277</article-id><article-id pub-id-type="publisher-id">sensors-25-01277</article-id><article-categories><subj-group subj-group-type="heading"><subject>Article</subject></subj-group></article-categories><title-group><article-title>Quantum Variational vs. Quantum Kernel Machine Learning Models for Partial Discharge Classification in Dielectric Oils</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Monz&#x000f3;n-Verona</surname><given-names>Jos&#x000e9; Miguel</given-names></name><xref rid="af1-sensors-25-01277" ref-type="aff">1</xref><xref rid="af2-sensors-25-01277" ref-type="aff">2</xref><xref rid="c1-sensors-25-01277" ref-type="corresp">*</xref></contrib><contrib contrib-type="author"><name><surname>Garc&#x000ed;a-Alonso</surname><given-names>Santiago</given-names></name><xref rid="af2-sensors-25-01277" ref-type="aff">2</xref><xref rid="af3-sensors-25-01277" ref-type="aff">3</xref></contrib><contrib contrib-type="author"><name><surname>Santana-Mart&#x000ed;n</surname><given-names>Francisco Jorge</given-names></name><xref rid="af1-sensors-25-01277" ref-type="aff">1</xref><xref rid="af2-sensors-25-01277" ref-type="aff">2</xref></contrib></contrib-group><contrib-group><contrib contrib-type="editor"><name><surname>Calonico</surname><given-names>Davide</given-names></name><role>Academic Editor</role></contrib></contrib-group><aff id="af1-sensors-25-01277"><label>1</label>Electrical Engineering Department (DIE), University of Las Palmas de Gran Canaria, 35017 Las Palmas de Gran Canaria, Spain; <email>francisco.santana@ulpgc.es</email></aff><aff id="af2-sensors-25-01277"><label>2</label>Institute for Applied Microelectronics, University of Las Palmas de Gran Canaria, 35017 Las Palmas de Gran Canaria, Spain; <email>santiago.garciaalonso@ulpgc.es</email></aff><aff id="af3-sensors-25-01277"><label>3</label>Department of Electronic Engineering and Automatics (DIEA), University of Las Palmas de Gran Canaria, 35017 Las Palmas de Gran Canaria, Spain</aff><author-notes><corresp id="c1-sensors-25-01277"><label>*</label>Correspondence: <email>josemiguel.monzon@ulpgc.es</email></corresp></author-notes><pub-date pub-type="epub"><day>19</day><month>2</month><year>2025</year></pub-date><pub-date pub-type="collection"><month>2</month><year>2025</year></pub-date><volume>25</volume><issue>4</issue><elocation-id>1277</elocation-id><history><date date-type="received"><day>08</day><month>11</month><year>2024</year></date><date date-type="rev-recd"><day>14</day><month>1</month><year>2025</year></date><date date-type="accepted"><day>17</day><month>2</month><year>2025</year></date></history><permissions><copyright-statement>&#x000a9; 2025 by the authors.</copyright-statement><copyright-year>2025</copyright-year><license><ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref><license-p>Licensee MDPI, Basel, Switzerland. This article is an open access article distributed under the terms and conditions of the Creative Commons Attribution (CC BY) license (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>).</license-p></license></permissions><abstract><p>In this paper, electrical discharge images are classified using AI with quantum machine learning techniques. These discharges were originated in dielectric mineral oils and were detected by a high-resolution optical sensor. The captured images were processed in a Scikit-image environment to obtain a reduced number of features or qubits for later training of quantum circuits. Two quantum binary classification models were developed and compared in the Qiskit environment for four discharge binary combinations. The first was a quantum variational model (QVM), and the second was a conventional support vector machine (SVM) with a quantum kernel model (QKM). The execution of these two models was realized on three fault-tolerant physical quantum IBM computers. The novelty of this article lies in its application to a real problem, unlike other studies that focus on simulated or theoretical data sets. In addition, a study is carried out on the impact of the number of qubits in QKM, and it is shown that increasing the number of qubits in this model significantly improves the accuracy in the classification of the four binary combinations studied. In the QVM, with two qubits, an accuracy of 92% was observed in the first discharge combination in the three quantum computers used, with a margin of error of 1% compared to the simulation obtained on classical computers.</p></abstract><kwd-group><kwd>partial discharges</kwd><kwd>mineral oils</kwd><kwd>quantum machine learning</kwd><kwd>quantum variational model</kwd><kwd>quantum kernel model</kwd><kwd>image processing with AI</kwd></kwd-group><funding-group><funding-statement>This research received no external funding.</funding-statement></funding-group></article-meta></front><body><sec sec-type="intro" id="sec1-sensors-25-01277"><title>1. Introduction</title><p>Partial discharge (PD) detection in transformer dielectric oils is justified by the need to reduce costly transformer breakdowns, extend their lifespan, optimize preventive maintenance, and eliminate network failures, all of which can have significant economic impacts. A steady and sustained rise in the number of publications on PD source classification using machine learning algorithms can be seen in the period from 2010 to 2023 [<xref rid="B1-sensors-25-01277" ref-type="bibr">1</xref>].</p><p>PD occurs when high voltage is applied to materials in any state, whether solid, liquid, or gaseous. It is a complex physical process that exhibits randomly distributed properties and produces phenomena such as light, sound, and high-frequency electromagnetic waves, releasing electrical charges [<xref rid="B2-sensors-25-01277" ref-type="bibr">2</xref>].</p><p>In situ experimental images of transformer oil spaces are extremely complex. In this work, the tests have been performed in the laboratory with oil samples extracted from the transformer. Consider that the main objective of this work is to explore the feasibility and potential of quantum machine learning models for the classification of electrical discharges in dielectric oils, using a controlled laboratory environment.</p><p>Although our current work is not focused on in situ studies, it could lay the groundwork for future research in that direction. This laboratory setup offers the advantage of immunity to electromagnetic interference.</p><p>The most widely used AI-based machine learning algorithms currently used to identify PDs in electrical transformers are derived using support vector machines (SVMs) [<xref rid="B3-sensors-25-01277" ref-type="bibr">3</xref>], followed by artificial neural networks (ANNs) [<xref rid="B4-sensors-25-01277" ref-type="bibr">4</xref>] and convolutional neural networks (CNNs) [<xref rid="B5-sensors-25-01277" ref-type="bibr">5</xref>]. All these methods use classical computing. In ref. [<xref rid="B6-sensors-25-01277" ref-type="bibr">6</xref>], it is indicated that before machine learning algorithms are tested on specific problems, there are no inherent or predefined differences that allow us to affirm that one machine learning algorithm is better than another. Following the current trend in the use of SVM techniques for the analysis and search for patterns in difficult-to-classify environments, the so-called kernel trick is used; through it, an attempt is made to find a series of hyperplanes where it is easier to find certain values. Once these SVM techniques are known, the aim is to transfer this knowledge to quantum computing.</p><p>Below, we review the current state of quantum kernel models (QKMs), quantum variational models (QVMs), the use of currently employed fault-tolerant quantum computers, and their potential theoretical and experimental advantages as well as their limitations.</p><p>The QKM is an area of AI in which the advantage of quantum computing has been explored. According to ref. [<xref rid="B7-sensors-25-01277" ref-type="bibr">7</xref>], quantum kernels can be used for supervised learning, showing that a quantum computer can classify data in a high-dimensional feature space more efficiently than classical methods.</p><p>In ref. [<xref rid="B8-sensors-25-01277" ref-type="bibr">8</xref>], it is explained how QKMs can capture complex relationships and patterns in data that classical kernels might not be able to identify. In this way, an SVM using a quantum kernel can better classify new data and make more accurate predictions. This enables hybrid computing, where a quantum computer implements a quantum kernel that is then run on a classical computer.</p><p>In ref. [<xref rid="B9-sensors-25-01277" ref-type="bibr">9</xref>], it is noted that as the problem size increases, the differences between kernel values become smaller and smaller, and more measurements are required to distinguish between the elements of the kernel matrix.</p><p>In ref. [<xref rid="B10-sensors-25-01277" ref-type="bibr">10</xref>], the number of evaluations when solving the dual problem is quantified in a number of quantum circuit evaluations with an order of magnitude given by Equation (1), where M represents the size of the data set and &#x003f5; is the accuracy of the solution compared to the ideal result, which can only be obtained theoretically with exact values. That is, the time required to solve the dual problem using quantum circuits increases polynomially with the size of the data set <italic toggle="yes">M</italic> and is inversely proportional to the square of the accuracy &#x003f5;.</p><p>The dependence on <italic toggle="yes">M</italic> poses a major challenge for problems with large data sets. In ref. [<xref rid="B10-sensors-25-01277" ref-type="bibr">10</xref>], an improvement with the primal problem with the kernel is shown using a generalization of a classical algorithm known as Pegasos, resulting in a smaller number of evaluations which, using Landau notation, is shown in Equations (1) and (2).<disp-formula id="FD1-sensors-25-01277"><label>(1)</label><mml:math id="mm1" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>O</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac bevelled="true"><mml:mrow><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mn>4.67</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>&#x02208;</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mstyle></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></disp-formula><disp-formula id="FD2-sensors-25-01277"><label>(2)</label><mml:math id="mm2" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>O</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mfenced open="{" close="}" separators="|"><mml:mrow><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac bevelled="true"><mml:mrow><mml:msup><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>&#x02208;</mml:mo></mml:mrow><mml:mrow><mml:mn>6</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mstyle><mml:mo>,</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac bevelled="true"><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>&#x02208;</mml:mo></mml:mrow><mml:mrow><mml:mn>10</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mstyle></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>In ref. [<xref rid="B11-sensors-25-01277" ref-type="bibr">11</xref>], it is explained that the QKM approach is more natural and suitable for quantum theory compared to the attempt to adapt quantum theory to fit the structure of classical neural networks, which is a more popular but less natural approach.</p><p>Thus, instead of optimizing classical parameters with QVM, which presents certain complex problems such as the choice of ansatz and the appearance and treatment of sterile plateaus, the QKM approach avoids these problems, although it requires calculating pairwise distances between data points, which implies a high computational cost.</p><p>As shown by the results reported in ref. [<xref rid="B12-sensors-25-01277" ref-type="bibr">12</xref>], quantum algorithms can outperform classical algorithms in optimization problems, which are central to supervised learning. A review of several quantum optimization algorithms is also conducted in ref. [<xref rid="B12-sensors-25-01277" ref-type="bibr">12</xref>], and their potential to outperform classical methods in machine learning tasks is pointed out, highlighting certain practical applications and preliminary experiments.</p><p>In ref. [<xref rid="B13-sensors-25-01277" ref-type="bibr">13</xref>], it is shown how a quantum perceptron can be simulated on a quantum computer, suggesting that QVMs could be trained and run more efficiently than their classical counterparts in certain cases. In ref. [<xref rid="B14-sensors-25-01277" ref-type="bibr">14</xref>], it is suggested that a QVM with the ability to process classical and quantum data, trainable through supervised learning, could be run on an intermediate-scale quantum computer.</p><p>It is interesting to note that in ref. [<xref rid="B15-sensors-25-01277" ref-type="bibr">15</xref>], it is demonstrated that quantum computers can handle and process structured data more efficiently in some specific cases. The quantum algorithm can, in theory, outperform classical methods in performing principal component analysis (PCA) on large data sets.</p><p>Quantum computing is a technique based on random phenomena that occur at the atomic scale. This computing uses the properties of quantum mechanics such as quantum superposition and entanglement. Its basic unit of information is the qubit, similar to the bit in classical computing.</p><p>It is important to highlight the greater computational power of quantum computing because qubits can exist simultaneously in multiple states. In quantum computing, the computational power increases exponentially as the number of qubits increases, which can be compared to classical computing where this increase is linear as the number of bits increases.</p><p>The execution speed in quantum computing is greater than in classical computing due to the principles on which it is based, such as quantum superposition and entanglement, which give rise to parallel computing.</p><p>Therefore, the execution of these algorithms can be repeatedly invoked many times, obtaining an acceptable probabilistic response in certain practical problems.</p><p>Among these algorithms, the best known is Shor&#x02019;s algorithm [<xref rid="B16-sensors-25-01277" ref-type="bibr">16</xref>], which is a reference used in the factorization of prime numbers with a polynomial complexity <inline-formula><mml:math id="mm3" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>O</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>N</mml:mi></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></inline-formula> compared to the generalized prime number algorithm with a complexity <inline-formula><mml:math id="mm4" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>O</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi>e</mml:mi><mml:mi>x</mml:mi><mml:mi>p</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>N</mml:mi></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac bevelled="true"><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfrac></mml:mstyle></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>g</mml:mi><mml:mi>N</mml:mi></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac bevelled="true"><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:mfrac></mml:mstyle></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></inline-formula> [<xref rid="B17-sensors-25-01277" ref-type="bibr">17</xref>].</p><p>Another algorithm of great interest in quantum computing is Grover&#x02019;s algorithm [<xref rid="B18-sensors-25-01277" ref-type="bibr">18</xref>], which has been shown to be fundamentally useful in searching for a given element in an unstructured database with a theoretical complexity of <inline-formula><mml:math id="mm5" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>O</mml:mi><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:mrow></mml:math></inline-formula>, compared to <inline-formula><mml:math id="mm6" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>O</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></inline-formula>. The Long&#x02013;Grover algorithm [<xref rid="B19-sensors-25-01277" ref-type="bibr">19</xref>] is a variant of Grover&#x02019;s quantum search algorithm that is able to handle situations where the exact number of solutions in the unstructured database is not known. This new algorithm maintains the same theoretical efficiency <inline-formula><mml:math id="mm7" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>O</mml:mi><mml:msqrt><mml:mi>N</mml:mi></mml:msqrt></mml:mrow></mml:mrow></mml:math></inline-formula> for database dimension <italic toggle="yes">N</italic> as Grover&#x02019;s algorithm, but with a better ability to tolerate uncertainty in the proportion of solutions, making it more robust and practical for certain types of search problems.</p><p>In the analysis undertaken in ref. [<xref rid="B20-sensors-25-01277" ref-type="bibr">20</xref>], the question is raised as to whether and how quantum computing can actually boost machine learning using real-world classical data sets. The main technical limitations and challenges associated with noisy intermediate-scale quantum (NISQ) computers are then addressed.</p><p>An analysis of the quantum computing landscape is discussed in ref. [<xref rid="B21-sensors-25-01277" ref-type="bibr">21</xref>], where it is stated that current quantum computers are not perfect due to decoherence in qubits caused by environmental noise, but they can perform certain calculations or solve problems that are beyond the reach of the best classical computers available today. It is argued that the main limitation will be the ability to maintain precision in quantum operations as circuits become larger and more complex. In ref. [<xref rid="B22-sensors-25-01277" ref-type="bibr">22</xref>], it is explained how to experimentally extend the coherence time of logical qubits by almost an order of magnitude.</p><p>Another challenge that exists today is to maintain a large number of entangled qubits in a stable manner. Quantum computers that address this challenge include the IBM Kyoto [<xref rid="B23-sensors-25-01277" ref-type="bibr">23</xref>], IBM Brisbane [<xref rid="B24-sensors-25-01277" ref-type="bibr">24</xref>,<xref rid="B25-sensors-25-01277" ref-type="bibr">25</xref>], and Google&#x02019;s Sycamore quantum computer [<xref rid="B26-sensors-25-01277" ref-type="bibr">26</xref>], among others.</p><p>To our knowledge, the use of QKM and QVM techniques has not been applied in the analysis of real cases in PD image detection in transformer oils using optical sensors. In this paper, a comprehensive study of PDs originating from bubbles present in dielectric mineral oil is carried out. These discharges are precursors of the arc breakdown and therefore represent a method for diagnosing the state of mineral oil before such a breakdown occurs.</p><p>In this paper, images captured in a high-voltage laboratory are processed by selecting a number of significant features. For this purpose, the Scikit-image environment [<xref rid="B27-sensors-25-01277" ref-type="bibr">27</xref>] is used. Two quantum classifier models, QKM and QVM, are developed. These models are implemented in the Qiskit development environment [<xref rid="B28-sensors-25-01277" ref-type="bibr">28</xref>].</p><p>In this article, we focus on the use of quantum computing to address the problem of image classification in transformer dielectric oils. The images used in this article are classified into four categories: images with partial discharges, images without partial discharges, images with electric arc breaking, and images with gas bubbles after arc breaking.</p><p>The effectiveness of the trained QKM and QVM classifiers is evaluated with images not used during the training process.</p><p>These models were run on three fault-tolerant physical quantum computers, each with 127-qubit superconducting processors: IBM Osaka, IBM Brisbane, and IBM Kyoto. The measurements obtained using quantum computers were then compared with the results of simulations obtained using classical computing.</p><p>The main contribution of this paper is that for the first time, two quantum machine learning models, QVM and QKM, are applied and compared for the classification of electrical discharge images in dielectric oils, using real data obtained with a high-resolution optical sensor.</p><p>The novelty of this work can be summarized in the following points: The work is applied to a real problem, unlike other previous studies that focus on simulated or theoretical data sets. In addition, a study is carried out on the impact of the number of qubits in QKM, and it is shown that increasing the number of qubits in this model significantly improves the accuracy in the classification of the four binary combinations of the classes. On the other hand, real quantum computers are used, and the models are implemented and executed on three fault-tolerant IBM quantum computers, demonstrating their operation on real quantum hardware and providing results comparable to classical simulations. This work also provides transparency and reproducibility by creating a repository on Zenodo [<xref rid="B29-sensors-25-01277" ref-type="bibr">29</xref>], with a detailed README, where the images of the electrical discharges used, the Jupyter Notebooks 7.0.8 for the extraction of the features, and the Jupiter Notebooks with the Python 3.12.4 programming of QVM and QKM with the respective figures have been published, so that the scientific community can access and use them.</p><p>This article is divided into the following sections: <xref rid="sec2-sensors-25-01277" ref-type="sec">Section 2</xref>, Image Processing and Feature Extraction Method; <xref rid="sec3-sensors-25-01277" ref-type="sec">Section 3</xref>, Quantum Machine Learning with Variational Circuits (Quantum Variational Model, QVM); <xref rid="sec4-sensors-25-01277" ref-type="sec">Section 4</xref>, Support Vector Machine, SVM; <xref rid="sec5-sensors-25-01277" ref-type="sec">Section 5</xref>, Quantum Kernel Model, QKM; <xref rid="sec6-sensors-25-01277" ref-type="sec">Section 6</xref>, Overall Flowchart. Finally, in <xref rid="sec7-sensors-25-01277" ref-type="sec">Section 7</xref>, Conclusions, the main conclusions are presented.</p></sec><sec id="sec2-sensors-25-01277"><title>2. Image Processing and Feature Extraction Method</title><p>In this work, an analysis of the PDs originated from bubbles present in dielectric mineral oils is performed. For this purpose, a high-resolution image sensor is used. The PDs detected with this sensor were validated using a standard electrical detection system using a discharge capacitor, according to the IEC60270 standard [<xref rid="B30-sensors-25-01277" ref-type="bibr">30</xref>]. All images used in this paper were previously obtained by the authors [<xref rid="B31-sensors-25-01277" ref-type="bibr">31</xref>]. These images were used to characterize and train the quantum circuits in <xref rid="sec3-sensors-25-01277" ref-type="sec">Section 3</xref> and <xref rid="sec5-sensors-25-01277" ref-type="sec">Section 5</xref>.</p><p>From the extraction of features in machine learning, relevant values are obtained from the obtained experimental images, speeding up the computing process without losing information. This reduces the required memory and computing time and improves the accuracy of the model.</p><p>In ref. [<xref rid="B1-sensors-25-01277" ref-type="bibr">1</xref>], the main techniques used to date are summarized. Those based on statistical characteristics are highlighted, as well as the technique based on principal component analysis (PCA) due to its capacity to reduce dimensionality and identify key variables, among others. This is crucial when working with a limited number of qubits that correspond to the current limitations of quantum technology. The method used in this article is explained below.</p><p><xref rid="sensors-25-01277-f001" ref-type="fig">Figure 1</xref>a presents four images, each corresponding to one of the four classes used: class 0 for partial discharge (PD), class 1 for no discharge (NOPD), class 2 for electric arc breaking (ARC), and class 3 for gas bubbles after arc breaking (BREAK). <xref rid="sensors-25-01277-f001" ref-type="fig">Figure 1</xref>b shows the experimental image collection device. From these images, features are extracted that reduce the number of qubits needed to perform quantum analyses.</p><p>Features are basic properties that characterize and simplify experimental images of electrical discharges. The goal is to work with as few qubits as possible. For this reason, the extraction of features from images has been reduced to a maximum of thirteen.</p><p>To process the images captured in the high-voltage laboratory and select their features, the Scikit-image environment is used. An explanation of the entire Scikit-learn environment, which includes working with images in multiple formats and provides tools for transforming, analyzing, and improving images, is provided in ref. [<xref rid="B27-sensors-25-01277" ref-type="bibr">27</xref>]. This includes filtering functions, geometric transformations, edge detection, segmentation, and color manipulation, among others.</p><p>To analyze the characteristic features of electrical discharges in images captured with a high-quality camera, a region of interest (ROI) selection and analysis process was first performed. Thus, the ROI was defined as a square centered on the image with a side of 100 pixels. To do this, the coordinates of the center of the image were calculated, and the vertices of the square were located (<xref rid="sensors-25-01277-f002" ref-type="fig">Figure 2</xref>a). The ROI within this square was converted to greyscale to facilitate the analysis. The ROI is shown in a red frame.</p><p>Then, the mean and standard deviation of the pixel intensities within the ROI were calculated. Using these values, a threshold was set as the mean plus two times the standard deviation. Pixels whose intensity exceeded this threshold were identified and their coordinates determined. The mean of these coordinates was then calculated to obtain the centroid of the high-intensity region.</p><p>To highlight pixels exceeding the threshold, the original image was modified by highlighting these pixels in red. In addition, the area of the highlighted region was calculated in terms of the number of pixels, and the centroid of this region was determined. Finally, the coordinates of the centroid were adjusted with respect to the originally selected ROI (see <xref rid="sensors-25-01277-f002" ref-type="fig">Figure 2</xref>a).</p><p>Key features obtained in this image analysis include the area in pixels of the highlighted region, the centroid coordinates in both the ROI and the original image, and the intensity statistics of the ROI. All these features are normalized to the interval [0, 2<italic toggle="yes">&#x003c0;</italic>].</p><p>The thirteen features of the images and the class to which they belong are as follows: the area in pixels, the centroid coordinates (centroid_x, centroid_y), the adjusted centroid coordinates in the ROI (centroid_x_roi, centroid_y_roi), the means of the coordinates (mean_coords_x, mean_coords_y), the size of the side of the square (side_px), the dimensions of the image (image_width, image_height), the mean intensity (mean_intensity), the standard deviation of the intensity (std_intensity), the threshold (threshold), and finally the class to which it belongs.</p><p><xref rid="sensors-25-01277-f002" ref-type="fig">Figure 2</xref>b and <xref rid="sensors-25-01277-f003" ref-type="fig">Figure 3</xref>b show the preprocessing results with the acquisition of the features for the PD and BREAK classes, respectively.</p><p>From the images of each binary combination between classes, a graphic study of the relationship between the possible pairs of features of the images, which turn out to be 13 &#x000d7; 13 graphs, was performed. This allows a preliminary study of the relationship between the different features of each class. This visualization allows for a first analysis, and to identify patterns and differences between the binary classes of images corresponding to each combination of classes.</p><p><xref rid="sensors-25-01277-f004" ref-type="fig">Figure 4</xref> presents a pairwise plot illustrating the relationships between five of the thirteen normalized image features, highlighting the two classes using colors for the PD_BREAK combination shown in <xref rid="sensors-25-01277-f001" ref-type="fig">Figure 1</xref>a.</p><p>Likewise, three other binary combinations were analyzed, PD_NOPD, PD_ARC, and BREAK_NOPD. Of all the possible binary combinations, these three are analyzed in this article because they are the most significant in the study of partial discharges.</p><p>Two machine learning methods were used, QVM and QKM. The first is considered in <xref rid="sec3-sensors-25-01277" ref-type="sec">Section 3</xref> and uses a trained variational quantum circuit to distinguish each class for each of these binary combinations. The second is considered in <xref rid="sec5-sensors-25-01277" ref-type="sec">Section 5</xref> and uses SVM by estimating the quantum kernel corresponding to each of these binary combinations.</p></sec><sec id="sec3-sensors-25-01277"><title>3. Quantum Machine Learning with Variational Circuits (Quantum Variational Model&#x02014;QVM)</title><sec id="sec3dot1-sensors-25-01277"><title>3.1. Introduction</title><p>The first model used to classify PDs is known as a variational quantum circuit (see the red block in <xref rid="sensors-25-01277-f005" ref-type="fig">Figure 5</xref>). This red block has two clearly differentiated parts.</p><p>The first part corresponds to the encoding of the chosen features of the images within the quantum circuit. The features are represented by the variable <italic toggle="yes">x</italic>[<italic toggle="yes">i</italic>], where <italic toggle="yes">i</italic> is the number of chosen features that are normalized real numbers in the interval [0, 2<italic toggle="yes">&#x003c0;</italic>]. They are introduced into the circuit through the logic gate <italic toggle="yes">U</italic> that performs a rotation around the z axis.</p><p>The second part within this red block is a series of quantum parameters <italic toggle="yes">theta</italic>[<italic toggle="yes">j</italic>] = <italic toggle="yes">&#x003b8;</italic>[<italic toggle="yes">j</italic>], where <italic toggle="yes">j</italic> depends on the complexity of the circuit, its number of qubits, and its depth. In simulations and executions in real quantum circuits, we used circuits with 10 and 11 quantum parameters.</p><p>These parameters, just like in neural networks, are fitted in the training phase of the network according to a cost function <inline-formula><mml:math id="mm8" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>C</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></inline-formula> that is attempted to be minimized at each step <italic toggle="yes">p</italic> by means of an optimization algorithm (see blue block in <xref rid="sensors-25-01277-f005" ref-type="fig">Figure 5</xref>). This algorithm updates the parameters <inline-formula><mml:math id="mm9" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>C</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></inline-formula> at the next step <italic toggle="yes">p</italic> + 1 in the quantum circuit. The cost function is built by comparing the measurement phase in the quantum circuit inside the red block with the expected value known in the supervised training.</p><p>To solve the optimization problem, the SciPy package [<xref rid="B32-sensors-25-01277" ref-type="bibr">32</xref>] was used, which is a library of numerical routines for the Python programming language. Two optimization algorithms were employed: the simultaneous perturbation stochastic approximation (SPSA) algorithm, which uses a stochastic approximation to estimate the gradients through simultaneous perturbations in all dimensions of the parameter space, which reduces the number of necessary evaluations [<xref rid="B33-sensors-25-01277" ref-type="bibr">33</xref>], and the constrained optimization by linear approximations (COBYLA) algorithm [<xref rid="B32-sensors-25-01277" ref-type="bibr">32</xref>,<xref rid="B34-sensors-25-01277" ref-type="bibr">34</xref>], which does not require derivatives of the objective function or the constraints.</p><p>The number of iterations in both methods is between 50 and 100. The main challenge when using this method is to find the structure of the quantum circuit called ansatz. For this task, we used the Qiskit library [<xref rid="B35-sensors-25-01277" ref-type="bibr">35</xref>], an open-source Python library for developing quantum computing programs that provides tools for building, simulating, and running quantum circuits on IBM quantum computers. This library allows users to work with quantum algorithms and optimize solutions for complex problems which greatly helps in finding the optimal parameters.</p><p>Another important challenge encountered is sterile plateaus. These are regions of the parameter space where the gradient is almost zero, making optimization very slow and difficult.</p></sec><sec id="sec3dot2-sensors-25-01277"><title>3.2. Cost Function</title><p>To obtain the cost function represented in the blue block shown in <xref rid="sensors-25-01277-f005" ref-type="fig">Figure 5</xref>, the concept of cross-entropy loss is followed [<xref rid="B36-sensors-25-01277" ref-type="bibr">36</xref>]. In binary classification problems, where the output can be 0 or 1, the cross-entropy loss function is used to measure the difference between the true label and the probability predicted by the model. Its formulation is<disp-formula id="FD3-sensors-25-01277"><label>(3)</label><mml:math id="mm10" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>L</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>y</mml:mi><mml:mo>,</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mfenced open="[" close="]" separators="|"><mml:mrow><mml:mi>y</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>&#x02061;</mml:mo><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow></mml:mfenced></mml:mrow></mml:mrow><mml:mo>+</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>&#x02212;</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:mfenced><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>&#x02061;</mml:mo><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>&#x02212;</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></disp-formula>
where <italic toggle="yes">y</italic> is the true label (0 or 1), and <inline-formula><mml:math id="mm11" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:math></inline-formula> is the predicted probability for label 1.</p><p>This equation penalizes incorrect predictions for both label 0 and label 1. If the true label is <italic toggle="yes">y</italic> = 1, the term <inline-formula><mml:math id="mm12" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>&#x02061;</mml:mo><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> dominates and penalizes the model if it predicts a low probability for label 1. On the other hand, if <italic toggle="yes">y</italic> = 0, the term <inline-formula><mml:math id="mm13" overflow="scroll"><mml:mrow><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>&#x02212;</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:mfenced><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>&#x02061;</mml:mo><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> dominates and penalizes the model if it predicts a high probability for label 1 when the true label is 0.</p><p>In this work, to simplify the implementation in programming, the cost function focuses only on the probability assigned to the correct class. This can be represented as follows:<disp-formula id="FD4-sensors-25-01277"><label>(4)</label><mml:math id="mm14" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>L</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>&#x02061;</mml:mo><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>&#x02061;</mml:mo><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>P</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>&#x003b8;</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mo>&#x02208;</mml:mo></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>
where <italic toggle="yes">y<sub>i</sub></italic> is the correct label, <inline-formula><mml:math id="mm15" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> is the probability predicted by the quantum circuit designed for that label, and &#x003f5; is a small nonzero value added to avoid logarithms of zero. <inline-formula><mml:math id="mm16" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>P</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>&#x003b8;</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></inline-formula> represents the probability that the quantum circuit assigns a label <italic toggle="yes">y<sub>i</sub></italic>, which can be 0 or 1, to a data <italic toggle="yes">x<sub>i</sub></italic>, where <italic toggle="yes">&#x003b8;</italic> represents the variational parameters that control the quantum circuit.<disp-formula id="FD5-sensors-25-01277"><label>(5)</label><mml:math id="mm17" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>P</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>&#x003b8;</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mrow><mml:msub><mml:mo stretchy="false">&#x02211;</mml:mo><mml:mrow><mml:mi mathvariant="normal">b</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">s</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">g</mml:mi><mml:mo>,</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mi mathvariant="normal">p</mml:mi><mml:mi mathvariant="normal">a</mml:mi><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">y</mml:mi><mml:mo>(</mml:mo><mml:mi mathvariant="normal">b</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">s</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">g</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="normal">y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:mi mathvariant="normal">c</mml:mi><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">u</mml:mi><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">s</mml:mi><mml:mo>(</mml:mo><mml:mi mathvariant="normal">b</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">s</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">r</mml:mi><mml:mi mathvariant="normal">i</mml:mi><mml:mi mathvariant="normal">n</mml:mi><mml:mi mathvariant="normal">g</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">a</mml:mi><mml:mi mathvariant="normal">l</mml:mi><mml:mo>&#x000a0;</mml:mo><mml:mi mathvariant="normal">s</mml:mi><mml:mi mathvariant="normal">h</mml:mi><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">t</mml:mi><mml:mi mathvariant="normal">s</mml:mi></mml:mrow></mml:mfrac></mml:mstyle></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>For example, for a two-qubit bitstring, a particular bitstring belongs to the set of possible outcomes {00, 01, 10, 11}; the parity is given as parity(00) = 0, parity(01) = 1, parity(10) = 1 and parity(11) = 0. If the particular measurement results of the quantum computer were, for example, <inline-formula><mml:math id="mm18" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>results</mml:mi><mml:mo>=</mml:mo><mml:mfenced open="{" close="}" separators="|"><mml:mrow><mml:mi mathvariant="normal">&#x02018;</mml:mi><mml:mn>00</mml:mn><mml:mi mathvariant="normal">&#x02019;</mml:mi><mml:mo>:</mml:mo><mml:mn>2000</mml:mn><mml:mo>,</mml:mo><mml:mi mathvariant="normal">&#x02018;</mml:mi><mml:mn>01</mml:mn><mml:mi mathvariant="normal">&#x02019;</mml:mi><mml:mo>:</mml:mo><mml:mn>250</mml:mn><mml:mo>,</mml:mo><mml:mi mathvariant="normal">&#x02018;</mml:mi><mml:mn>10</mml:mn><mml:mi mathvariant="normal">&#x02019;</mml:mi><mml:mo>:</mml:mo><mml:mn>250</mml:mn><mml:mo>,</mml:mo><mml:mi mathvariant="normal">&#x02018;</mml:mi><mml:mn>11</mml:mn><mml:mi mathvariant="normal">&#x02019;</mml:mi><mml:mo>:</mml:mo><mml:mn>1500</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></inline-formula>, then <inline-formula><mml:math id="mm19" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>total</mml:mi><mml:mo>&#x000a0;</mml:mo><mml:mi>shots</mml:mi><mml:mo>=</mml:mo><mml:mn>2000</mml:mn><mml:mo>+</mml:mo><mml:mn>250</mml:mn><mml:mo>+</mml:mo><mml:mn>250</mml:mn><mml:mo>+</mml:mo><mml:mn>1500</mml:mn><mml:mo>=</mml:mo><mml:mn>4000</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula>, so the probability of obtaining parity 0 is <italic toggle="yes">P</italic>(0) = (2000 + 1500)/4000 = 0.87, and the probability of obtaining parity 1 is <italic toggle="yes">P</italic>(1) = (250 + 250)/400 = 0.13.</p><p>Finally, the cost function <inline-formula><mml:math id="mm20" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>C</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></inline-formula>, which averages the cross-entropy loss for all data samples, <italic toggle="yes">x<sub>i</sub></italic>, is expressed as<disp-formula id="FD6-sensors-25-01277"><label>(6)</label><mml:math id="mm21" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>C</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:mfrac></mml:mstyle><mml:mrow><mml:munderover><mml:mo stretchy="false">&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mi>L</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>y</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:mfrac></mml:mstyle><mml:mrow><mml:munderover><mml:mo stretchy="false">&#x02211;</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="normal">log</mml:mi></mml:mrow><mml:mo>&#x02061;</mml:mo><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>P</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>&#x003b8;</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mo>&#x02208;</mml:mo></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>
where <italic toggle="yes">N</italic> is the number of data points in the training set.</p></sec><sec id="sec3dot3-sensors-25-01277"><title>3.3. Structures of the Circuits and Quantum Gates Used</title><p>The four stages of how the supervised machine learning problem was approached, its adaptation, transformation, and resolution, using quantum computing, are summarized below. The quantum gates used are also detailed, both in the simulations carried out on the classical computer and on the quantum computer.</p><p>The first stage involves mapping the classical problem to its quantum computer formulation. In this stage, the problem is translated into a format that can be processed by a quantum computer. To do this, quantum circuits are created that represent the problem to be solved. This process can be complex and often requires specialized tools. In this work, Qiskit version 1.0 [<xref rid="B37-sensors-25-01277" ref-type="bibr">37</xref>] was used, an IBM framework for quantum computing that offers application programming interfaces (APIs) that facilitate the creation of these circuits (<xref rid="sensors-25-01277-f006" ref-type="fig">Figure 6</xref> and <xref rid="sensors-25-01277-f007" ref-type="fig">Figure 7</xref>).</p><p>The second stage is known as circuit transpilation. Once the quantum circuit has been created, it needs to be adapted to be executable on specific quantum hardware. This stage involves rewriting or transforming the original circuit into a version that is compatible and optimized for the available hardware, using gates specific to that hardware (see <xref rid="sensors-25-01277-f008" ref-type="fig">Figure 8</xref>, which corresponds to the transpilation of the circuit in <xref rid="sensors-25-01277-f007" ref-type="fig">Figure 7</xref>). Transpilation transforms it so that only the instructions are available on a chosen backend. They are used and optimized to minimize the effects of noise [<xref rid="B38-sensors-25-01277" ref-type="bibr">38</xref>].</p><p>The third stage concerns the execution and evaluation of the quantum circuits. In this stage, the transpiled quantum circuit was executed in a quantum simulator, using the Qiskit environment in Python, and additionally on three real physical quantum computers (IBM Osaka, IBM Brisbane, and IBM Kyoto). During this phase, the final measurements leading to the necessary quantum calculations were carried out.</p><p>The fourth and final stage involves the post-processing of results. The results obtained from the execution of the quantum circuit are processed and analyzed to find a solution to the original problem posed. This allows the interpretation of the quantum results and the conversion to a format compatible with the classical problem.</p><p>The relationships between the quantum gates used in the circuits are shown in <xref rid="sensors-25-01277-f006" ref-type="fig">Figure 6</xref>, <xref rid="sensors-25-01277-f007" ref-type="fig">Figure 7</xref> and <xref rid="sensors-25-01277-f008" ref-type="fig">Figure 8</xref>. Their matrix expressions are presented in Equations (7)&#x02013;(10).</p><p>The Hadamard gate <italic toggle="yes">U<sub>2</sub></italic> and <italic toggle="yes">H</italic> gate are represented by Equation (7), the generic rotation gate <italic toggle="yes">U</italic> is defined in Equation (8), and the <italic toggle="yes">z</italic>-axis rotation gate, <italic toggle="yes">P = R<sub>Z</sub></italic>, is described by Equation (9). The control gate <italic toggle="yes">CX</italic> between two qubits is specified in Equation (10).<disp-formula id="FD7-sensors-25-01277"><label>(7)</label><mml:math id="mm22" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mo>&#x02205;</mml:mo><mml:mo>,</mml:mo><mml:mi>&#x003bb;</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt></mml:mrow></mml:mfrac></mml:mstyle><mml:mfenced separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mo>&#x02212;</mml:mo><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>&#x003bb;</mml:mi></mml:mrow></mml:msup></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>&#x003d5;</mml:mi></mml:mrow></mml:msup></mml:mtd><mml:mtd><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>&#x003d5;</mml:mi><mml:mo>+</mml:mo><mml:mi>&#x003bb;</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:msub><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>&#x003c0;</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt></mml:mrow></mml:mfrac></mml:mstyle><mml:mfenced separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>H</mml:mi></mml:mrow></mml:mrow></mml:math></disp-formula><disp-formula id="FD8-sensors-25-01277"><label>(8)</label><mml:math id="mm23" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>U</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>&#x003b8;</mml:mi><mml:mo>,</mml:mo><mml:mo>&#x02205;</mml:mo><mml:mo>,</mml:mo><mml:mi>&#x003bb;</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mstyle></mml:mrow></mml:mfenced></mml:mtd><mml:mtd><mml:mo>&#x02212;</mml:mo><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>&#x003bb;</mml:mi></mml:mrow></mml:msup><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mstyle></mml:mrow></mml:mfenced></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>&#x003d5;</mml:mi></mml:mrow></mml:msup><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mstyle></mml:mrow></mml:mfenced></mml:mtd><mml:mtd><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>&#x003d5;</mml:mi><mml:mo>+</mml:mo><mml:mi>&#x003bb;</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mstyle></mml:mrow></mml:mfenced></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></disp-formula><disp-formula id="FD9-sensors-25-01277"><label>(9)</label><mml:math id="mm24" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>U</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mn>0,0</mml:mn><mml:mo>,</mml:mo><mml:mi>&#x003bb;</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mo>&#x02212;</mml:mo><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>&#x003bb;</mml:mi></mml:mrow></mml:msup><mml:mo>&#x000b7;</mml:mo><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>1</mml:mn><mml:mo>&#x000b7;</mml:mo><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>&#x003bb;</mml:mi></mml:mrow></mml:msup><mml:mo>&#x000b7;</mml:mo><mml:mn>1</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:msup><mml:mrow><mml:mi>e</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mi>&#x003bb;</mml:mi></mml:mrow></mml:msup></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi mathvariant="normal">P</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>&#x003bb;</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>R</mml:mi></mml:mrow><mml:mrow><mml:mi>Z</mml:mi></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mi>&#x003bb;</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></disp-formula><disp-formula id="FD10-sensors-25-01277"><label>(10)</label><mml:math id="mm25" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>C</mml:mi><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>The ECR gate is a two-qubit gate that performs a controlled operation in the context of cross-resonance. It is one of the native gates in IBM quantum computers and is usually defined in terms of more basic operations, taking into account the interaction between two qubits ([<xref rid="B38-sensors-25-01277" ref-type="bibr">38</xref>,<xref rid="B39-sensors-25-01277" ref-type="bibr">39</xref>]). Its matrix expression is given in Equation (11). Furthermore, the SX (square root of <italic toggle="yes">X</italic>) gate, whose expression is given in Equation (12), when applied twice, is equivalent to the Pauli <italic toggle="yes">X</italic> gate, as shown in Equation (13).<disp-formula id="FD11-sensors-25-01277"><label>(11)</label><mml:math id="mm26" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>E</mml:mi><mml:mi>C</mml:mi><mml:mi>R</mml:mi><mml:mo>=</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt></mml:mrow></mml:mfrac></mml:mstyle></mml:mtd><mml:mtd><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt></mml:mrow></mml:mfrac></mml:mstyle></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt></mml:mrow></mml:mfrac></mml:mstyle></mml:mtd><mml:mtd><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt></mml:mrow></mml:mfrac></mml:mstyle></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt></mml:mrow></mml:mfrac></mml:mstyle></mml:mtd><mml:mtd><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt></mml:mrow></mml:mfrac></mml:mstyle></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt></mml:mrow></mml:mfrac></mml:mstyle></mml:mtd><mml:mtd><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt></mml:mrow></mml:mfrac></mml:mstyle></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></disp-formula><disp-formula id="FD12-sensors-25-01277"><label>(12)</label><mml:math id="mm27" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>S</mml:mi><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mstyle><mml:mfenced separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>i</mml:mi></mml:mtd><mml:mtd><mml:mn>1</mml:mn><mml:mo>&#x02212;</mml:mo><mml:mi>i</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>1</mml:mn><mml:mo>&#x02212;</mml:mo><mml:mi>i</mml:mi></mml:mtd><mml:mtd><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mi>i</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></disp-formula><disp-formula id="FD13-sensors-25-01277"><label>(13)</label><mml:math id="mm28" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></disp-formula></p></sec><sec id="sec3dot4-sensors-25-01277"><title>3.4. Quantum Variational Model (QVM) Optimization</title><p>This section details the training process of the two types of quantum circuits used. The first type of circuit, which uses 10 parameters (see <xref rid="sensors-25-01277-f006" ref-type="fig">Figure 6</xref>), was used to perform the binary classification between the combined classes (PD and NOPD). The second type of circuit, with 11 parameters (see <xref rid="sensors-25-01277-f007" ref-type="fig">Figure 7</xref>), was used for the binary classification in the following three combined classes (PD and BREAK), (PD and ARC), and (BREAK and NOPD).</p><p>The final optimal parameters for each of these binary combinations, after the optimization process, are presented in <xref rid="sensors-25-01277-t001" ref-type="table">Table 1</xref>, corresponding to the combinations PD_NOPD, PD_BREAK, PD_ARC, and BREAK_NOPD, respectively.</p><p>Since the execution time on the quantum computer is currently limited on the available IBM, it was decided to perform this optimization step to determine the parameters in a simulation using a classical computer, solving the corresponding quantum circuits. The optimal accuracy values for both the training and test sets are shown in the last row of <xref rid="sensors-25-01277-t001" ref-type="table">Table 1</xref>. The maximum accuracy values on the test set were 95% for PD_BREAK combination, 93% for PD_NOPD combination, and higher than 82% for PD_ARC and BREAK_NOPD combination.</p><p>As previously described, <xref rid="sensors-25-01277-f005" ref-type="fig">Figure 5</xref> shows the blue block where the cost function is calculated at each iteration. The evaluation of the cost function <inline-formula><mml:math id="mm29" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>C</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>&#x003b8;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></inline-formula> is performed by passing all the images, together with their labels (+1, &#x02212;1), through the variational quantum circuit. The classification criterion is based on the parity of the qubits read after the execution of the circuit. If most of the qubits read have an even value, the image is classified as belonging to label 1. If the majority of the qubits have an odd value, the image is classified as belonging to label &#x02212;1.</p><p>The evolution of the cost function during the optimization process with the COBYLA algorithm for 50 iterations in the PD_ARC combination is shown in <xref rid="sensors-25-01277-f009" ref-type="fig">Figure 9</xref>a. Similarly, the evolution of the cost function for the PD_NOPD combination, for 100 iterations, is presented in <xref rid="sensors-25-01277-f009" ref-type="fig">Figure 9</xref>b. It should be noted that, from iteration 50 onwards, no significant improvement in the cost function is observed. In this last combination, an accuracy of 93% can be considered acceptable.</p></sec><sec id="sec3dot5-sensors-25-01277"><title>3.5. Verification of Results</title><p>All experiments performed with quantum computers were performed with the following: IBM Brisbane equipped with the Eagle r3 processor (version 1.1.33), IBM Kyoto, based on the Eagle r3 processor (version 1.2.38), and the IBM Osaka with the Eagle r3 processor (version 1.1.8).</p><p>All these systems are based on 127 superconducting qubits [<xref rid="B24-sensors-25-01277" ref-type="bibr">24</xref>,<xref rid="B28-sensors-25-01277" ref-type="bibr">28</xref>] and use a set of basic logic gates including ECR, ID, RZ, SX, and X (see <xref rid="sec3dot3-sensors-25-01277" ref-type="sec">Section 3.3</xref>), with a processing capacity of 5000 CLOPS. The mean errors of the SX and ECR gates, the mean readout error, the average error per logic gate (EPLG), and the system coherence times T1 and T2 for the three computers used are summarized in <xref rid="sensors-25-01277-t002" ref-type="table">Table 2</xref>.</p><p>The first checkpoint is related to the final measurement stage for the selection between one class or another based on the measured parity. <xref rid="sensors-25-01277-f010" ref-type="fig">Figure 10</xref>a presents the measurements obtained for two random images of the PD class, assigned to odd parity. Also shown are the measured results for all combinations, both in the simulation on a classical computer and the results obtained experimentally on the real IBM Osaka quantum computer. Similarly, the measurements obtained for two random images belonging to the NOPD class, with even parity assignment, are presented in <xref rid="sensors-25-01277-f010" ref-type="fig">Figure 10</xref>b. The execution time of the job with 4000 shots on the IBM Osaka computer in both cases is approximately 4 s.</p><p>The second verification point consists in obtaining the average accuracy for 136 random images from the test set. The tests are performed for the combinations PD_NOPD, PD_BREAK, PD_ARC, and BREAK_NOPD with the quantum circuits optimized in <xref rid="sec3dot4-sensors-25-01277" ref-type="sec">Section 3.4</xref> by running these circuits on the IBM quantum computers, Kyoto, Brisbane, and Osaka.</p><p>The results of all runs are summarized in <xref rid="sensors-25-01277-t003" ref-type="table">Table 3</xref>. The first four rows represent the average accuracy for the training and test image sets for the simulation and the IBM Kyoto, Brisbane, and Osaka computers. The number of shots is equal to 4096 for each of the quantum circuits. The average execution time for these 136 quantum circuits is 150 s.</p><p>In <xref rid="sensors-25-01277-t003" ref-type="table">Table 3</xref>, it can be observed that the accuracy of the test set of 136 random images for the combination PD_NOPD is 92% on the three quantum computers used, and the error compared to the simulation is 1%. For the rest of the combinations, PD_BREAK, PD_ARC, and BREAK_NOPD, the accuracy for the test set is around 88%.</p></sec></sec><sec id="sec4-sensors-25-01277"><title>4. Support Vector Machine, SVM</title><p>This section describes the basic principles of the second method developed to identify discharges in mineral oils. This method is based on SVM, which has been classically applied to numerous binary classification problems and is the basis of the QKM used in this paper. <xref rid="sec4dot1-sensors-25-01277" ref-type="sec">Section 4.1</xref> describes the SVM primal problem, <xref rid="sec4dot2-sensors-25-01277" ref-type="sec">Section 4.2</xref> explains the advantages of formulating the linear dual problem of SVM, and <xref rid="sec4dot3-sensors-25-01277" ref-type="sec">Section 4.3</xref> generalizes it to a nonlinear SVM problem.</p><sec id="sec4dot1-sensors-25-01277"><title>4.1. SVM Primal Problem</title><p>The primal problem of the SVM is that its dimensionality depends on the number of features <italic toggle="yes">n</italic> in the data. It can be stated as follows [<xref rid="B10-sensors-25-01277" ref-type="bibr">10</xref>]: given a training data set {(<italic toggle="yes">x<sub>i</sub></italic>,<italic toggle="yes">y<sub>i</sub></italic>)} with features <italic toggle="yes">x<sub>i</sub></italic> &#x02208; <italic toggle="yes">&#x0211d;n</italic> and labels of a binary classification <italic toggle="yes">y<sub>i</sub></italic> &#x02208; {&#x02212;1,1}, the objective is to find a hyperplane that maximizes the margin between the two classes while allowing certain classification errors.</p><p>The primal problem can be formulated as follows:<disp-formula id="FD14-sensors-25-01277"><label>(14)</label><mml:math id="mm30" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:munder><mml:mrow><mml:mi mathvariant="normal">min</mml:mi></mml:mrow><mml:mrow><mml:mi>w</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>&#x003be;</mml:mi></mml:mrow></mml:munder></mml:mrow><mml:mo>&#x02061;</mml:mo><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mstyle><mml:msup><mml:mrow><mml:mfenced open="&#x02016;" close="&#x02016;" separators="|"><mml:mrow><mml:mi>w</mml:mi></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mrow><mml:munderover><mml:mo stretchy="false">&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msubsup><mml:mrow><mml:mi>&#x003be;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>
subjected to the following restrictions:<disp-formula id="FD15-sensors-25-01277"><label>(15)</label><mml:math id="mm31" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mi>w</mml:mi><mml:mo>&#x000b7;</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:mfenced><mml:mo>&#x02265;</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003be;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003be;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>&#x02265;</mml:mo><mml:mn>0</mml:mn><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mi>p</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mo>&#x000a0;</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>&#x022ef;</mml:mo><mml:mo>,</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:mrow></mml:math></disp-formula>
where <italic toggle="yes">m</italic> is the number of available samples. For any <italic toggle="yes">p</italic> &#x0003e; 0, it is a convex problem and therefore has a unique solution [<xref rid="B8-sensors-25-01277" ref-type="bibr">8</xref>].</p><p>In this work, we chose <italic toggle="yes">p</italic> = 2, called the L2 soft margin, which is a common practice, <italic toggle="yes">w</italic> is the weight vector, b is the bias, <italic toggle="yes">&#x003be;<sub>i</sub></italic> are the slack variables that allow misclassifications, and <italic toggle="yes">C</italic><sub>1</sub> is a parameter that controls the trade-off between margin and classification error. A large <italic toggle="yes">C</italic><sub>1</sub> results in a smaller margin but fewer misclassifications, while a small <italic toggle="yes">C</italic><sub>1</sub> results in a larger margin but more allowed errors.</p></sec><sec id="sec4dot2-sensors-25-01277"><title>4.2. SVM Linear Dual Problem</title><p>The dual formulation is based on the inner products between pairs of data samples, <inline-formula><mml:math id="mm32" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. These products define the linear kernel <italic toggle="yes">K(x<sub>j</sub>,x<sub>i</sub>)</italic>. The kernel allows these inner products to be computed in the upper feature space efficiently, even when this space is very high-dimensional or infinite.</p><p>The dual formulation of the SVM problem [<xref rid="B10-sensors-25-01277" ref-type="bibr">10</xref>] with a soft L2 margin is expressed in the following equation:<disp-formula id="FD16-sensors-25-01277"><label>(16)</label><mml:math id="mm33" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:munder><mml:mrow><mml:mi mathvariant="normal">max</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:mrow></mml:munder></mml:mrow><mml:mo>&#x02061;</mml:mo><mml:mrow><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mrow><mml:munderover><mml:mo stretchy="false">&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mstyle><mml:mrow><mml:munderover><mml:mo stretchy="false">&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mrow><mml:munderover><mml:mo stretchy="false">&#x02211;</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msubsup><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>&#x02212;</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>4</mml:mn><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mstyle><mml:mrow><mml:munderover><mml:mo stretchy="false">&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msubsup><mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>
and is subject to the following restrictions:<disp-formula id="FD17-sensors-25-01277"><label>(17)</label><mml:math id="mm34" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mrow><mml:munderover><mml:mo stretchy="false">&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mn>0</mml:mn><mml:mo>&#x02264;</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>&#x02264;</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>&#x022ef;</mml:mo><mml:mo>,</mml:mo><mml:mi>m</mml:mi></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>The solution to Equation (16) subjected to the constraints of the dual problem shown in Equation (17) produces the optimal values of <italic toggle="yes">&#x003b1;<sub>i</sub></italic>. Once we have solved the dual problem and found the <italic toggle="yes">&#x003b1;<sub>i</sub></italic>, the weight vector <italic toggle="yes">w</italic> can be calculated with the following equation:<disp-formula id="FD18-sensors-25-01277"><label>(18)</label><mml:math id="mm35" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>w</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:munderover><mml:mo stretchy="false">&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>The bias <italic toggle="yes">b</italic> can be calculated using any of the support vectors <italic toggle="yes">x<sub>k</sub></italic> which are the points for which <italic toggle="yes">&#x003b1;<sub>i</sub></italic> &#x0003e; 0, as expressed in the following equation:<disp-formula id="FD19-sensors-25-01277"><label>(19)</label><mml:math id="mm36" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msup><mml:mrow><mml:mi>w</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>Working with the dual problem of an L2 soft margin SVM offers several key advantages.</p><p>In the dual problem, the optimization is performed based on the Lagrange multipliers <italic toggle="yes">&#x003b1;<sub>i</sub></italic>, which are associated with each data sample. This allows the optimization problem to be changed from the feature space, which has a dimension <italic toggle="yes">n</italic>, to the sample space, with a dimension <italic toggle="yes">m</italic>, facilitating data handling.</p><p>In the solution of the dual problem, many of the Lagrange multipliers <italic toggle="yes">&#x003b1;<sub>i</sub></italic> are zero. Only the samples located on the margin, known as support vectors, have <italic toggle="yes">&#x003b1;<sub>i</sub></italic> &#x0003e; 0. This reduces both the computational cost and the complexity of the model.</p><p>Quadratic optimization methods used to solve the dual problem are well developed and especially efficient with high-dimensional problems in the sample space. Specific algorithms, such as the sequential minimal optimization (SMO) method [<xref rid="B40-sensors-25-01277" ref-type="bibr">40</xref>], are designed to efficiently solve the SVM dual problem by taking advantage of the sparsity in the Lagrange multipliers.</p></sec><sec id="sec4dot3-sensors-25-01277"><title>4.3. SVM Dual Nonlinear Problem</title><p>If the problem is nonlinear [<xref rid="B8-sensors-25-01277" ref-type="bibr">8</xref>], the solution is stated as follows according to Equation (20) subject to the restrictions of Equation (21):<disp-formula id="FD20-sensors-25-01277"><label>(20)</label><mml:math id="mm37" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mrow><mml:mrow><mml:munder><mml:mrow><mml:mi mathvariant="normal">max</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:mrow></mml:munder></mml:mrow><mml:mo>&#x02061;</mml:mo><mml:mrow><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mrow><mml:munderover><mml:mo stretchy="false">&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mstyle><mml:mrow><mml:munderover><mml:mo stretchy="false">&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mrow><mml:munderover><mml:mo stretchy="false">&#x02211;</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mi>K</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>&#x02212;</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>4</mml:mn><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mstyle><mml:mrow><mml:munderover><mml:mo stretchy="false">&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msubsup><mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula><disp-formula id="FD21-sensors-25-01277"><label>(21)</label><mml:math id="mm38" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>&#x000a0;</mml:mo><mml:mn>0</mml:mn><mml:mo>&#x02264;</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>&#x02264;</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mrow><mml:munderover><mml:mo stretchy="false">&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>&#x000a0;</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>The bias value <italic toggle="yes">b</italic> is calculated using the support vectors <italic toggle="yes">x<sub>i</sub></italic>, for which the decision function is equal to the label <italic toggle="yes">y<sub>i</sub></italic> of the following equation:<disp-formula id="FD22-sensors-25-01277"><label>(22)</label><mml:math id="mm39" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:munderover><mml:mo stretchy="false">&#x02211;</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mi>K</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>To calculate <italic toggle="yes">b</italic>, Equation (18) is rearranged, as indicated below:<disp-formula id="FD23-sensors-25-01277"><label>(23)</label><mml:math id="mm40" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>&#x02212;</mml:mo><mml:mrow><mml:munderover><mml:mo stretchy="false">&#x02211;</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mi>K</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></disp-formula>
or an average is taken to obtain a more robust estimate of the bias <italic toggle="yes">b</italic>, which is calculated using the following equation:<disp-formula id="FD24-sensors-25-01277"><label>(24)</label><mml:math id="mm41" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mfenced open="|" close="|" separators="|"><mml:mrow><mml:mi>S</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfrac></mml:mstyle><mml:mrow><mml:munder><mml:mo stretchy="false">&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mi>&#x003f5;</mml:mi><mml:mi>S</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>&#x02212;</mml:mo><mml:mrow><mml:munderover><mml:mo stretchy="false">&#x02211;</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mi>K</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>
where <italic toggle="yes">S</italic> is the set of support vectors.</p><p>Once the value of <italic toggle="yes">b</italic> is determined, the prediction of a new element value <italic toggle="yes">x</italic> is made according to Equation (25):<disp-formula id="FD25-sensors-25-01277"><label>(25)</label><mml:math id="mm42" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mo>=</mml:mo><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>g</mml:mi><mml:mi>n</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mrow><mml:munderover><mml:mo stretchy="false">&#x02211;</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mi>K</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>That is, we identify the class <italic toggle="yes">y<sub>i</sub></italic> &#x02208; {&#x02212;1,1} to which a new element <italic toggle="yes">x</italic> belongs.</p></sec></sec><sec id="sec5-sensors-25-01277"><title>5. Quantum Kernel Estimate (Quantum Kernel Model, QKM)</title><p>In this section, a quantum kernel estimate is made for two, three, and eight features using a quantum computer with two, three, and eight qubits, respectively. Once the kernel has been estimated, Equations (20)&#x02013;(25) are used on a classical computer to make the corresponding membership estimate of a new element <italic toggle="yes">x</italic>.</p><p>The quantum kernel estimation algorithm consists of mapping classical data vectors into quantum states [<xref rid="B11-sensors-25-01277" ref-type="bibr">11</xref>]. This is achieved by a mapping that transforms a classical feature vector x into a quantum state |<italic toggle="yes">&#x003d5;</italic>(<italic toggle="yes">x</italic>)&#x027e9;. This process is performed by parameterizing a quantum circuit with the feature x, transforming a unitary matrix over <italic toggle="yes">n</italic> qubits into the ground state |0<italic toggle="yes"><sup>n</sup></italic>&#x027e9;, i.e., <italic toggle="yes">U</italic>(<italic toggle="yes">x</italic>)|0<italic toggle="yes"><sup>n</sup></italic>&#x027e9;.</p><p>A quantum kernel is based on using quantum states to represent data and calculate the similarity between them in a quantum feature space. This is done using quantum circuits that encode the data into quantum states. The similarity between two feature vectors <italic toggle="yes">x</italic> and <italic toggle="yes">y</italic> is calculated by the Hilbert&#x02013;Schmidt inner product between density matrices [<xref rid="B8-sensors-25-01277" ref-type="bibr">8</xref>]. The similarity between two feature vectors <italic toggle="yes">x</italic> and <italic toggle="yes">y</italic> is calculated as the value of the quantum kernel <italic toggle="yes">k</italic>(<italic toggle="yes">x</italic>,<italic toggle="yes">y</italic>) given in Equation (26):<disp-formula id="FD26-sensors-25-01277"><label>(26)</label><mml:math id="mm43" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mfenced open="|" close="|" separators="|"><mml:mrow><mml:mfenced open="&#x027e8;" close="&#x027e9;" separators="|"><mml:mrow><mml:mi>&#x003d5;</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi>&#x003d5;</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mfenced open="|" close="|" separators="|"><mml:mrow><mml:mfenced open="&#x027e8;" close="&#x027e9;" separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mo>&#x02020;</mml:mo></mml:mrow></mml:msup><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi></mml:mrow></mml:mfenced><mml:mi>U</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>The way to evaluate each point in the matrix <italic toggle="yes">k</italic>(<italic toggle="yes">x</italic>,<italic toggle="yes">y</italic>) is to run a quantum circuit <italic toggle="yes">U</italic><sup>&#x02020;</sup>(<italic toggle="yes">x</italic>)<italic toggle="yes">U</italic>(<italic toggle="yes">y</italic>) on the input <inline-formula><mml:math id="mm44" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mfenced open="" close="&#x027e9;" separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></inline-formula> and find the probability of obtaining the state <inline-formula><mml:math id="mm45" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>|</mml:mo><mml:mfenced open="" close="&#x027e9;" separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></inline-formula>. <xref rid="sensors-25-01277-f011" ref-type="fig">Figure 11</xref> shows the generic structure of the quantum circuit used to estimate the particularized kernel for three features. For this purpose, the ZZFeatureMap function obtained from the Qiskit library [<xref rid="B28-sensors-25-01277" ref-type="bibr">28</xref>] was used. This is a parameterized quantum circuit used to map classical data to a quantum feature space. This mapping is performed by applying quantum rotation gates on the qubits, followed by CX-type interactions between pairs of qubits, which allows the capture of nonlinear relationships in the data.</p><p>Next, in <xref rid="sec5dot1-sensors-25-01277" ref-type="sec">Section 5.1</xref>, the results obtained with the QKM method for the binary combinations PD_NODP, PD_BREAK, PD_ARC, and BREAK_NOPD, with two features, are explained in order to make a comparison with the results obtained with the QVM method. Then, in <xref rid="sec5dot2-sensors-25-01277" ref-type="sec">Section 5.2</xref>, the results with the QKM method for three and eight features are analyzed, and the improvement in accuracy is analyzed.</p><sec id="sec5dot1-sensors-25-01277"><title>5.1. Two-Feature Kernel Estimation</title><p>All simulations performed on classical computers and experiments performed on quantum computers were run following the basic ZZFeatureMap circuit structure, shown in <xref rid="sensors-25-01277-f011" ref-type="fig">Figure 11</xref> and defined in [<xref rid="B35-sensors-25-01277" ref-type="bibr">35</xref>]. In this section, the kernel is estimated for two features, [&#x02018;area-pixels&#x02019;, &#x02018;mean-coords-x&#x02019;], described in <xref rid="sec2-sensors-25-01277" ref-type="sec">Section 2</xref> and for the four class combinations PD_NODP, PD_BREAK, PD_ARC, and BREAK_NOPD.</p><p>The exact kernel results for the PD_BREAK class combination are depicted in <xref rid="sensors-25-01277-f012" ref-type="fig">Figure 12</xref>a. Only the upper diagonal needs to be computed, since the matrix is symmetric. The element kernel matrix obtained is 580 &#x000d7; 580, as can be seen in the Data Index (X1) and (X2). The number of computations, which corresponds to the quantum circuit in <xref rid="sensors-25-01277-f011" ref-type="fig">Figure 11</xref>, is determined by Equation (26). This circuit was used to estimate the kernel on a quantum computer, performing 168,200 evaluations. For each evaluation, the kernel matrix value is normalized between 0 and 1.</p><p><xref rid="sensors-25-01277-f012" ref-type="fig">Figure 12</xref>b shows a comparative study between the exact kernel value and the value obtained with the IBM Kyoto computer for row 40 and columns 0 to 24 (Pub 0 to Pub 24) of the matrix shown in <xref rid="sensors-25-01277-f012" ref-type="fig">Figure 12</xref>a. The matrix was generated using the library Qiskit [<xref rid="B28-sensors-25-01277" ref-type="bibr">28</xref>], with the Jupyter Notebook QKM_verification_two_qubits.ipynb allocated in the repository [<xref rid="B29-sensors-25-01277" ref-type="bibr">29</xref>].</p><p>Due to time constraints on available quantum computers, 140 values were randomly selected from the top of the matrix to estimate the kernel and compared with those obtained in simulations on a classical computer. These values are shown in <xref rid="sensors-25-01277-f013" ref-type="fig">Figure 13</xref>a, with the execution time on the quantum computer being 2 m 34 s. The results of the simulation and the execution on the IBM Kyoto computer are presented in <xref rid="sensors-25-01277-f013" ref-type="fig">Figure 13</xref>b, with a mean absolute percentage error (MAPE) of 7.6% according to Equation (27). <xref rid="sensors-25-01277-f012" ref-type="fig">Figure 12</xref>b details the comparison between the exact value and the results of 25 consecutive values from row 40 of the kernel matrix, obtained on the same quantum computer.<disp-formula id="FD27-sensors-25-01277"><label>(27)</label><mml:math id="mm46" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">P</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mo>=</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>100</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfrac></mml:mstyle><mml:mrow><mml:munderover><mml:mo stretchy="false">&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:munderover><mml:mrow><mml:mfenced open="|" close="|" separators="|"><mml:mrow><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>A</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mstyle></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>
where <italic toggle="yes">k</italic> = 140 is the total number of elements, <italic toggle="yes">A<sub>i</sub></italic> is the actual observed value, and <italic toggle="yes">F<sub>i</sub></italic> is the value predicted by the simulation.</p><p><xref rid="sensors-25-01277-f014" ref-type="fig">Figure 14</xref>a shows another 140 random evaluations, different from the previous ones, see, performed on another quantum computer, IBM Osaka, for PD_BREAK class combination, in order to verify the results in another physical environment. <xref rid="sensors-25-01277-f014" ref-type="fig">Figure 14</xref>b shows the comparison between the results obtained on the real IBM Osaka quantum computer and the simulation, with a runtime of 2 m 34 s on the IBM computer.</p><p>The results obtained in the three quantum computers were verified in the other three class combinations PD_NOPD, BREAK_NOPD, and PD_ARC, and are represented in <xref rid="sensors-25-01277-f015" ref-type="fig">Figure 15</xref>, <xref rid="sensors-25-01277-f016" ref-type="fig">Figure 16</xref>, and <xref rid="sensors-25-01277-f017" ref-type="fig">Figure 17</xref>, respectively, along with the simulations of the kernel obtained with a classical computer.</p><p>The exact kernel results for the PD_NOPD, BREAK_NOPD, and PD_ARC class combinations are depicted in <xref rid="sensors-25-01277-f015" ref-type="fig">Figure 15</xref>a, <xref rid="sensors-25-01277-f016" ref-type="fig">Figure 16</xref>a, and <xref rid="sensors-25-01277-f017" ref-type="fig">Figure 17</xref>a, respectively. Only the upper diagonal needs to be computed, since the matrix is symmetric. The element kernel matrix obtained is 580 &#x000d7; 580, as can be seen in the Data Index (X1) and (X2). The number of computations, which corresponds to the quantum circuit in <xref rid="sensors-25-01277-f011" ref-type="fig">Figure 11</xref>, is determined by Equation (26). This circuit was used to estimate the kernel on a quantum computer, performing 168,200 evaluations. For each evaluation, the kernel matrix value is normalized between 0 and 1.</p><p><xref rid="sensors-25-01277-f015" ref-type="fig">Figure 15</xref>b, <xref rid="sensors-25-01277-f016" ref-type="fig">Figure 16</xref>b, and <xref rid="sensors-25-01277-f017" ref-type="fig">Figure 17</xref>b show a comparative study between the exact kernel value and the value obtained with IBM Osaka, Brisbane, and IBM Kyoto computers, respectively, for row 40 and columns 0 to 24 (Pub 0 to Pub 24) of the matrix shown in <xref rid="sensors-25-01277-f015" ref-type="fig">Figure 15</xref>a, <xref rid="sensors-25-01277-f016" ref-type="fig">Figure 16</xref>a, and <xref rid="sensors-25-01277-f017" ref-type="fig">Figure 17</xref>a, respectively. These matrices were generated using the library Qiskit [<xref rid="B28-sensors-25-01277" ref-type="bibr">28</xref>], with the Jupyter Notebook QKM_verification_two_qubits.ipynb allocated in the repository [<xref rid="B29-sensors-25-01277" ref-type="bibr">29</xref>].</p><p>As a final summary of the results obtained for two features, <xref rid="sensors-25-01277-t004" ref-type="table">Table 4</xref> presents the accuracy of all the binary combinations using quantum kernel estimation on the different two-qubit features x = [&#x02018;area-pixels&#x02019;, &#x02018;mean-coords-x&#x02019;], using a test image ratio of 20%. The accuracy values are 83% and 97% for the PD_ARC and PD_NOPD combinations, respectively. The execution times for the kernel calculation on the test items vary between 2587 s and 2639 s for these models.</p><p>Results for the QVM are presented in <xref rid="sensors-25-01277-t003" ref-type="table">Table 3</xref> (see <xref rid="sec3-sensors-25-01277" ref-type="sec">Section 3</xref>). In the first QVM, an accuracy of 92% was observed on the test set for 136 random images under the first PD_NOPD binary combination, obtained consistently on the three types of quantum computers used, with a 1% error margin compared to the simulation. For the other three binary combinations, the test set accuracy was around 88%.</p><p>However, for QKM, using SVM, the test set accuracy for the PD_NOPD combination reached 97%, while for the other combinations, the average accuracy was 89% (<xref rid="sensors-25-01277-t004" ref-type="table">Table 4</xref>).</p></sec><sec id="sec5dot2-sensors-25-01277"><title>5.2. Kernel Estimation with Three and Eight Features</title><p>In this section, the improvement in accuracy when increasing the number of features is analyzed.</p><p>The features used for three qubits are represented in Equation (28). The test or validation set represents 80% of the data.<disp-formula id="FD28-sensors-25-01277"><label>(28)</label><mml:math id="mm47" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:mfenced open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>a</mml:mi><mml:mo>_</mml:mo><mml:mi>p</mml:mi><mml:mi>i</mml:mi><mml:mi>x</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mi>s</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>m</mml:mi><mml:mi>e</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mo>_</mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>s</mml:mi><mml:mo>_</mml:mo><mml:mi>x</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>m</mml:mi><mml:mi>e</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mo>_</mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>s</mml:mi><mml:mo>_</mml:mo><mml:mi>y</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></disp-formula></p><p><xref rid="sensors-25-01277-t005" ref-type="table">Table 5</xref> shows the results of four binary combinations, using an SVM with a kernel to train and evaluate models with these three features, parameter <italic toggle="yes">C</italic><sub>1</sub> = 1 in Equation (20). The results indicate that the accuracies on the test set for the binary combinations PD_NODP, PD_BREAK, PD_ARC, and BREAK_NOPD are 99%, 85%, 84%, and 92%, respectively. The kernel matrix computation times for the training data vary between 157 s and 307 s, corresponding to a range of 129 to 173 evaluations. For the validation set, the times range between 1290 and 3509 s, due to a higher number of evaluations.</p><p>The features used for eight qubits are expressed in Equation (29). The test or validation set represents 80% of the data.<disp-formula id="FD29-sensors-25-01277"><label>(29)</label><mml:math id="mm48" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>X</mml:mi><mml:mo>=</mml:mo><mml:mfenced open="[" close="]" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>a</mml:mi><mml:mo>_</mml:mo><mml:mi>p</mml:mi><mml:mi>i</mml:mi><mml:mi>x</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mi>s</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>m</mml:mi><mml:mi>e</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mo>_</mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>s</mml:mi><mml:mo>_</mml:mo><mml:mi>x</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>m</mml:mi><mml:mi>e</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mo>_</mml:mo><mml:mi>c</mml:mi><mml:mi>o</mml:mi><mml:mi>o</mml:mi><mml:mi>r</mml:mi><mml:mi>d</mml:mi><mml:mi>s</mml:mi><mml:mo>_</mml:mo><mml:mi>y</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>c</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>t</mml:mi><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:mi>i</mml:mi><mml:mi>d</mml:mi><mml:mo>_</mml:mo><mml:mi>x</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>c</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>t</mml:mi><mml:mi>r</mml:mi><mml:mi>o</mml:mi><mml:mi>i</mml:mi><mml:mi>d</mml:mi><mml:mo>_</mml:mo><mml:mi>y</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>m</mml:mi><mml:mi>e</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>y</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>s</mml:mi><mml:mi>t</mml:mi><mml:mi>d</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>y</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>t</mml:mi><mml:mi>h</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mi>h</mml:mi><mml:mi>o</mml:mi><mml:mi>l</mml:mi><mml:mi>d</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></disp-formula></p><p><xref rid="sensors-25-01277-t006" ref-type="table">Table 6</xref> shows the results of four binary combinations, using an SVM with a kernel to train and evaluate models with these eight features. The results indicate that the accuracy on the test set for all the binary classes PD_NODP, PD_BREAK, PD_ARC, and BREAK_NOPD is 99%, 94%, 99%, and 98%, respectively. The kernel matrix computation times for the training data vary between 294 and 531 s, corresponding to a range of 129 to 173 evaluations. For the validation set, the times range between 2352 s and 4229 s, due to a higher number of evaluations.</p><p>A comparison of <xref rid="sensors-25-01277-t005" ref-type="table">Table 5</xref> and <xref rid="sensors-25-01277-t006" ref-type="table">Table 6</xref> shows how increasing the number of features affects both the accuracy and the execution time of the SVM models with the kernel. When using more features (eight instead of three), an improvement in accuracy is observed, especially on the test set, suggesting that the model generalizes better with new data. However, this improvement leads to an increase in execution times as more features are added.</p></sec></sec><sec id="sec6-sensors-25-01277"><title>6. Overall Flowchart</title><p>In this section, an overall flowchart, see <xref rid="sensors-25-01277-f018" ref-type="fig">Figure 18</xref>, that explains the main steps followed in the article to obtain the different results shown in <xref rid="sec2-sensors-25-01277" ref-type="sec">Section 2</xref>, <xref rid="sec3-sensors-25-01277" ref-type="sec">Section 3</xref>, <xref rid="sec4-sensors-25-01277" ref-type="sec">Section 4</xref> and <xref rid="sec5-sensors-25-01277" ref-type="sec">Section 5</xref> has been added. We believe this will make the procedure easier to understand.</p><p>A detailed description of each step of the process is included in the README of the Zenodo repository [<xref rid="B29-sensors-25-01277" ref-type="bibr">29</xref>], along with links to the corresponding Jupyter Notebooks. To make it easier to understand the overall workflow, we have included a summary description of the flowchart in four steps. This flowchart is described below.</p><p>Flowchart Description:</p><p>The flowchart is generated running the Binary_features_generation.ipynb file and can be viewed directly in the repository. It graphically represents the four main steps of this experimental process.</p><p>Step A: Feature Generation</p><p>The name of the Jupyter Notebook is Binary_features_generation.ipynb.</p><p>It presents the following subsections: image visualization, feature extraction, and binary concatenation of files in csv format. Folders /IMAGES/ and /FEATURE_RESULTS/ are referenced, and the feature_*.csv files are introduced.</p><p>Step B: Optimization of QVM Parameters</p><p>The name of the Jupyter Notebook is FIT_DP_NODP_CIRCUIT.ipynb.</p><p>It presents the following subsections: library import, function definition, data loading, normalization, quantum circuit definition, cost function, COBYLA optimization, and model evaluation. Reference is made to <xref rid="sensors-25-01277-t001" ref-type="table">Table 1</xref> and to the optimal parameters stored in the variable named opt_var.</p><p>Step C: Verification on Quantum Hardware/Simulation</p><p>The name of the Jupyter Notebook is QVM_verification_two_qubits.ipynb.</p><p>It presents the following subsections: environment setup, backend selection, data and parameter loading, circuit definition, transpilation, circuit execution, and results analysis. Reference is made to <xref rid="sensors-25-01277-t003" ref-type="table">Table 3</xref> and the results comparison graphs.</p><p>Step D: Execution of QKM Model</p><p>The name of the Jupyter Notebook is QKM_verification_two_qubits.ipynb.</p><p>It presents the following subsections: execution of the QKM model on real quantum computers, real quantum computer execution, quantum kernel estimation algorithm, and SVM with QKM for two, three, and eight qubits.</p></sec><sec sec-type="conclusions" id="sec7-sensors-25-01277"><title>7. Conclusions</title><p>In this paper, electrical discharge images are classified using AI with quantum machine learning techniques. The results show that quantum machine learning is effective in classifying electrical discharge images in dielectric mineral oils that were detected by a high-resolution optical sensor. Both the variational quantum model QVM and the support vector machine SVM with quantum kernel model estimation QKM achieved significant accuracies of 92% and 97%, respectively, in the first discharge combination, PD_NOPD, realized with two qubits. This demonstrates the potential of quantum algorithms in classification applications in highly complex scenarios.</p><p>The two developed quantum models showed remarkable consistency when running on three different physical quantum computers, IBM Osaka, IBM Brisbane, and IBM Kyoto. The results obtained a 1% error margin compared to simulations performed on classical computers, indicating the robustness of the models against variability in quantum hardware. Increasing the number of qubits from two to eight in the QKM resulted in a significant improvement in model accuracy, reaching an average of 97% in test set accuracy for the four binary combinations PD_NOPD, PD_BREAK, PD_ARC, and BREAK_NOPD. This increase shows that models with more qubits have a higher generalization capacity, improving the classification of previously unseen data.</p><p>The comparison between the two models indicates that although both quantum approaches proved to be effective, the SVM-QKM slightly outperformed the QVM in terms of overall accuracy. This result suggests that, in this specific context, combining quantum techniques with classical methods such as SVM can offer an advantage in classifying complex patterns.</p><p>The findings show that implementing quantum machine learning techniques in detection and diagnostic systems offers significant advantages in terms of accuracy and generalization capacity, especially when more qubits are employed in the models. This opens the door to future research and practical applications in the field of detection and analysis of electrical discharges in dielectric systems.</p></sec></body><back><ack><title>Acknowledgments</title><p>We acknowledge the use of IBM Quantum services for this work. The views expressed are those of the authors, and do not reflect the official policy or position of IBM or the IBM Quantum team. We also wish to acknowledge the Institute for Applied Microelectronics, the Electrical Engineering Department, and the Department of Electronic Engineering and Automatics at the University of Las Palmas de Gran Canaria.</p></ack><fn-group><fn><p><bold>Disclaimer/Publisher&#x02019;s Note:</bold> The statements, opinions and data contained in all publications are solely those of the individual author(s) and contributor(s) and not of MDPI and/or the editor(s). MDPI and/or the editor(s) disclaim responsibility for any injury to people or property resulting from any ideas, methods, instructions or products referred to in the content.</p></fn></fn-group><notes><title>Author Contributions</title><p>J.M.M.-V. supported the theory background, collected and processed the images, developed the experiments, analyzed the data, and wrote the paper. S.G.-A. and F.J.S.-M. supported the theory background, analyzed the data, and wrote the paper. All authors have read and agreed to the published version of the manuscript.</p></notes><notes><title>Institutional Review Board Statement</title><p>Not applicable.</p></notes><notes><title>Informed Consent Statement</title><p>This research article does not include any human studies.</p></notes><notes notes-type="data-availability"><title>Data Availability Statement</title><p>Data are contained within the article.</p></notes><notes notes-type="COI-statement"><title>Conflicts of Interest</title><p>The authors declare no conflicts of interest.</p></notes><ref-list><title>References</title><ref id="B1-sensors-25-01277"><label>1.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Thobejane</surname><given-names>L.T.</given-names></name>
<name><surname>Thango</surname><given-names>B.A.</given-names></name>
</person-group><article-title>Partial Discharge Source Classification in Power Transformers: A Systematic Literature Review</article-title><source>Appl. Sci.</source><year>2024</year><volume>14</volume><elocation-id>6097</elocation-id><pub-id pub-id-type="doi">10.3390/app14146097</pub-id></element-citation></ref><ref id="B2-sensors-25-01277"><label>2.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Govindarajan</surname><given-names>S.</given-names></name>
<name><surname>Morales Rivera</surname><given-names>A.</given-names></name>
<name><surname>Ardila-Rey</surname><given-names>J.</given-names></name>
<name><surname>Purushothaman</surname><given-names>N.</given-names></name>
</person-group><article-title>A review on partial discharge diagnosis in cables: Theory, techniques, and trends</article-title><source>Measurement</source><year>2023</year><volume>216</volume><fpage>112882</fpage><pub-id pub-id-type="doi">10.1016/j.measurement.2023.112882</pub-id></element-citation></ref><ref id="B3-sensors-25-01277"><label>3.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Sekatane</surname><given-names>P.M.</given-names></name>
<name><surname>Bokoro</surname><given-names>P.</given-names></name>
</person-group><article-title>Partial Discharge Localization through k-NN and SVM</article-title><source>Energies</source><year>2023</year><volume>16</volume><elocation-id>7430</elocation-id><pub-id pub-id-type="doi">10.3390/en16217430</pub-id></element-citation></ref><ref id="B4-sensors-25-01277"><label>4.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Adam</surname><given-names>B.</given-names></name>
<name><surname>Tenbohlen</surname><given-names>S.</given-names></name>
</person-group><article-title>Classification of Superimposed Partial Discharge Patterns</article-title><source>Energies</source><year>2021</year><volume>14</volume><elocation-id>2144</elocation-id><pub-id pub-id-type="doi">10.3390/en14082144</pub-id></element-citation></ref><ref id="B5-sensors-25-01277"><label>5.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Yan</surname><given-names>X.</given-names></name>
<name><surname>Bai</surname><given-names>Y.</given-names></name>
<name><surname>Zhang</surname><given-names>W.</given-names></name>
<name><surname>Cheng</surname><given-names>C.</given-names></name>
<name><surname>Liu</surname><given-names>J.</given-names></name>
</person-group><article-title>Partial discharge pattern-recognition method based on embedded artificial intelligence</article-title><source>Appl. Sci.</source><year>2023</year><volume>13</volume><fpage>10370</fpage><lpage>10387</lpage><pub-id pub-id-type="doi">10.3390/app131810370</pub-id></element-citation></ref><ref id="B6-sensors-25-01277"><label>6.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Schuld</surname><given-names>M.</given-names></name>
<name><surname>Nathan</surname><given-names>K.</given-names></name>
</person-group><article-title>Is Quantum Advantage the Right Goal for Quantum Machine Learning?</article-title><source>PRX Quantum</source><year>2022</year><volume>3</volume><fpage>030101</fpage><pub-id pub-id-type="doi">10.1103/PRXQuantum.3.030101</pub-id></element-citation></ref><ref id="B7-sensors-25-01277"><label>7.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Havl&#x000ed;&#x0010d;ek</surname><given-names>V.</given-names></name>
<name><surname>C&#x000f3;rcoles</surname><given-names>A.D.</given-names></name>
<name><surname>Temme</surname><given-names>K.</given-names></name>
<name><surname>Harrow</surname><given-names>A.W.</given-names></name>
<name><surname>Kandala</surname><given-names>A.</given-names></name>
<name><surname>Chow</surname><given-names>J.M.</given-names></name>
<name><surname>Gambetta</surname><given-names>J.M.</given-names></name>
</person-group><article-title>Supervised learning with quantum-enhanced feature spaces</article-title><source>Nature</source><year>2019</year><volume>567</volume><fpage>209</fpage><lpage>212</lpage><pub-id pub-id-type="doi">10.1038/s41586-019-0980-2</pub-id><pub-id pub-id-type="pmid">30867609</pub-id>
</element-citation></ref><ref id="B8-sensors-25-01277"><label>8.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Yunchao</surname><given-names>L.</given-names></name>
<name><surname>Srinivasan</surname><given-names>A.</given-names></name>
<name><surname>Kristan</surname><given-names>T.</given-names></name>
</person-group><article-title>A rigorous and robust quantum speed-up in supervised machine learning</article-title><source>Nat. Phys.</source><year>2021</year><volume>17</volume><fpage>1013</fpage><lpage>1017</lpage><pub-id pub-id-type="doi">10.1038/s41567-021-01287-z</pub-id></element-citation></ref><ref id="B9-sensors-25-01277"><label>9.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Supanut</surname><given-names>T.</given-names></name>
<name><surname>Samson</surname><given-names>W.</given-names></name>
<name><surname>Cerezo</surname><given-names>M.</given-names></name>
<name><surname>Zo&#x000eb;</surname><given-names>H.</given-names></name>
</person-group><article-title>Exponential concentration in quantum kernel methods</article-title><source>Nat. Commun.</source><year>2024</year><volume>15</volume><fpage>5200</fpage><pub-id pub-id-type="doi">10.1038/s41467-024-49287-w</pub-id><pub-id pub-id-type="pmid">38890282</pub-id>
</element-citation></ref><ref id="B10-sensors-25-01277"><label>10.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Gian</surname><given-names>G.</given-names></name>
<name><surname>Arne</surname><given-names>T.</given-names></name>
<name><surname>David</surname><given-names>S.</given-names></name>
<name><surname>Stefan</surname><given-names>W.</given-names></name>
</person-group><article-title>The complexity of quantum support vector machines</article-title><source>Quantum</source><year>2024</year><volume>8</volume><fpage>1225</fpage><pub-id pub-id-type="doi">10.22331/q-2024-01-11-1225</pub-id></element-citation></ref><ref id="B11-sensors-25-01277"><label>11.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Schuld</surname><given-names>M.</given-names></name>
</person-group><article-title>Supervised quantum machine learning models are kernel methods</article-title><source>arXiv</source><year>2021</year><pub-id pub-id-type="doi">10.48550/arXiv.2101.11020</pub-id><pub-id pub-id-type="arxiv">2101.11020v2</pub-id></element-citation></ref><ref id="B12-sensors-25-01277"><label>12.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Jacob</surname><given-names>B.</given-names></name>
<name><surname>Peter</surname><given-names>W.</given-names></name>
<name><surname>Nicola</surname><given-names>P.</given-names></name>
<name><surname>Patrick</surname><given-names>R.</given-names></name>
<name><surname>Nathan</surname><given-names>W.</given-names></name>
<name><surname>Seth</surname><given-names>L.</given-names></name>
</person-group><article-title>Quantum machine learning</article-title><source>Nature</source><year>2017</year><volume>549</volume><fpage>195</fpage><lpage>202</lpage><pub-id pub-id-type="doi">10.1038/nature23474</pub-id><pub-id pub-id-type="pmid">28905917</pub-id>
</element-citation></ref><ref id="B13-sensors-25-01277"><label>13.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Schuld</surname><given-names>M.</given-names></name>
<name><surname>Sinayskiy</surname><given-names>I.</given-names></name>
<name><surname>Petruccione</surname><given-names>F.</given-names></name>
</person-group><article-title>Simulating a perceptron on a quantum computer</article-title><source>Phys. Lett. A</source><year>2015</year><volume>379</volume><fpage>660</fpage><lpage>663</lpage><pub-id pub-id-type="doi">10.1016/j.physleta.2014.11.061</pub-id></element-citation></ref><ref id="B14-sensors-25-01277"><label>14.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Farhi</surname><given-names>E.</given-names></name>
<name><surname>Neven</surname><given-names>H.</given-names></name>
</person-group><article-title>Classification with Quantum Neural Networks on Near Term Processors</article-title><source>arXiv</source><year>2018</year><pub-id pub-id-type="doi">10.48550/arXiv.1802.06002</pub-id><pub-id pub-id-type="arxiv">1802.06002</pub-id></element-citation></ref><ref id="B15-sensors-25-01277"><label>15.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Lloyd</surname><given-names>S.</given-names></name>
<name><surname>Mohseni</surname><given-names>M.</given-names></name>
<name><surname>Rebentrost</surname><given-names>R.</given-names></name>
</person-group><article-title>Quantum principal component analysis</article-title><source>Nat. Phys.</source><year>2014</year><volume>10</volume><fpage>631</fpage><lpage>633</lpage><comment>Available online: <ext-link xlink:href="https://www.nature.com/articles/nphys3029" ext-link-type="uri">https://www.nature.com/articles/nphys3029</ext-link></comment><date-in-citation content-type="access-date" iso-8601-date="2024-10-10">(accessed on 10 October 2024)</date-in-citation><pub-id pub-id-type="doi">10.1038/nphys3029</pub-id></element-citation></ref><ref id="B16-sensors-25-01277"><label>16.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Mart&#x000ed;n-L&#x000f3;pez</surname><given-names>E.</given-names></name>
<name><surname>Laing</surname><given-names>A.</given-names></name>
<name><surname>Lawson</surname><given-names>T.</given-names></name>
<name><surname>Alvarez</surname><given-names>R.</given-names></name>
<name><surname>Zhou</surname><given-names>X.Q.</given-names></name>
<name><surname>O&#x02019;brien</surname><given-names>J.L.</given-names></name>
</person-group><article-title>Experimental realization of Shor&#x02019;s quantum factoring algorithm using qubit recycling</article-title><source>Nat. Photon</source><year>2012</year><volume>6</volume><fpage>773</fpage><lpage>776</lpage><pub-id pub-id-type="doi">10.1038/nphoton.2012.259</pub-id></element-citation></ref><ref id="B17-sensors-25-01277"><label>17.</label><element-citation publication-type="book"><person-group person-group-type="author">
<name><surname>Lenstra</surname><given-names>A.K.</given-names></name>
<name><surname>Lenstra</surname><given-names>H.W.</given-names></name>
<name><surname>Manasse</surname><given-names>M.S.</given-names></name>
<name><surname>Pollard</surname><given-names>J.M.</given-names></name>
</person-group><article-title>The number field sieve</article-title><source>The Development of the Number Field Sieve</source><person-group person-group-type="editor">
<name><surname>Lenstra</surname><given-names>A.K.</given-names></name>
<name><surname>Lenstra</surname><given-names>H.W.</given-names></name>
</person-group><comment>Lecture Notes in Mathematics</comment><publisher-name>Springer</publisher-name><publisher-loc>Berlin/Heidelberg, Germany</publisher-loc><year>1993</year><volume>Volume 1554</volume><fpage>11</fpage><lpage>42</lpage><pub-id pub-id-type="doi">10.1007/BFb0091537</pub-id></element-citation></ref><ref id="B18-sensors-25-01277"><label>18.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Gilliam</surname><given-names>A.</given-names></name>
<name><surname>Stefan</surname><given-names>W.</given-names></name>
<name><surname>Gonciulea</surname><given-names>C.</given-names></name>
</person-group><article-title>Grover Adaptive Search for Constrained Polynomial Binary Optimization</article-title><source>Quantum Open Access Publizierens Quantenwissenschaften</source><year>2021</year><volume>5</volume><fpage>428</fpage><pub-id pub-id-type="doi">10.22331/q-2021-04-08-428</pub-id></element-citation></ref><ref id="B19-sensors-25-01277"><label>19.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Zhu</surname><given-names>Y.</given-names></name>
<name><surname>Wang</surname><given-names>Z.</given-names></name>
<name><surname>Yan</surname><given-names>B.</given-names></name>
<name><surname>Wei</surname><given-names>S.</given-names></name>
</person-group><article-title>Robust Quantum Search with Uncertain Number of Target States</article-title><source>Entropy</source><year>2021</year><volume>23</volume><elocation-id>1649</elocation-id><pub-id pub-id-type="doi">10.3390/e23121649</pub-id><pub-id pub-id-type="pmid">34945955</pub-id>
</element-citation></ref><ref id="B20-sensors-25-01277"><label>20.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Peters</surname><given-names>E.</given-names></name>
<name><surname>Caldeira</surname><given-names>J.</given-names></name>
<name><surname>Ho</surname><given-names>A.</given-names></name>
<name><surname>Leichenauer</surname><given-names>S.</given-names></name>
<name><surname>Mohseni</surname><given-names>M.</given-names></name>
<name><surname>Neven</surname><given-names>H.</given-names></name>
<name><surname>Spentzouris</surname><given-names>P.</given-names></name>
<name><surname>Strain</surname><given-names>D.</given-names></name>
<name><surname>Perdue</surname><given-names>G.N.</given-names></name>
</person-group><article-title>Machine learning of high dimensional data on a noisy quantum processor</article-title><source>NPJ Quantum Inf.</source><year>2021</year><volume>7</volume><fpage>161</fpage><pub-id pub-id-type="doi">10.1038/s41534-021-00498-9</pub-id></element-citation></ref><ref id="B21-sensors-25-01277"><label>21.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Preskill</surname><given-names>J.</given-names></name>
</person-group><article-title>Quantum Computing in the NISQ era and beyond</article-title><source>Quantum</source><year>2018</year><volume>2</volume><fpage>79</fpage><pub-id pub-id-type="doi">10.22331/q-2018-08-06-79</pub-id></element-citation></ref><ref id="B22-sensors-25-01277"><label>22.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Han</surname><given-names>J.</given-names></name>
<name><surname>Li</surname><given-names>Z.</given-names></name>
<name><surname>Zhang</surname><given-names>J.</given-names></name>
<name><surname>Xu</surname><given-names>H.</given-names></name>
<name><surname>Linghu</surname><given-names>K.</given-names></name>
<name><surname>Li</surname><given-names>Y.</given-names></name>
<name><surname>Li</surname><given-names>C.</given-names></name>
<name><surname>Chen</surname><given-names>M.</given-names></name>
<name><surname>Yang</surname><given-names>Z.</given-names></name>
<name><surname>Wang</surname><given-names>J.</given-names></name>
<etal/>
</person-group><article-title>Characterizing noise correlation and enhancing coherence via qubit motion</article-title><source>Fundam. Res.</source><year>2021</year><volume>1</volume><fpage>10</fpage><lpage>15</lpage><pub-id pub-id-type="doi">10.1016/j.fmre.2020.12.005</pub-id></element-citation></ref><ref id="B23-sensors-25-01277"><label>23.</label><element-citation publication-type="webpage"><article-title>The University of Tokyo Completes Installation of 127-Qubit IBM Quantum Eagle Processor</article-title><year>2023</year><comment>Available online: <ext-link xlink:href="https://newsroom.ibm.com/2023-11-27-The-University-of-Tokyo-Completes-Installation-of-127-Qubit-IBM-Quantum-Eagle-Processor" ext-link-type="uri">https://newsroom.ibm.com/2023-11-27-The-University-of-Tokyo-Completes-Installation-of-127-Qubit-IBM-Quantum-Eagle-Processor</ext-link></comment><date-in-citation content-type="access-date" iso-8601-date="2024-10-10">(accessed on 10 October 2024)</date-in-citation></element-citation></ref><ref id="B24-sensors-25-01277"><label>24.</label><element-citation publication-type="webpage"><article-title>IBM Quantum</article-title><comment>Available online: <ext-link xlink:href="https://quantum.ibm.com" ext-link-type="uri">https://quantum.ibm.com</ext-link></comment><date-in-citation content-type="access-date" iso-8601-date="2024-10-10">(accessed on 10 October 2024)</date-in-citation></element-citation></ref><ref id="B25-sensors-25-01277"><label>25.</label><element-citation publication-type="webpage"><article-title>Quantum Processing Units</article-title><comment>Available online: <ext-link xlink:href="https://quantum.ibm.com/services/resources?system=ibm_brisbane" ext-link-type="uri">https://quantum.ibm.com/services/resources?system=ibm_brisbane</ext-link></comment><date-in-citation content-type="access-date" iso-8601-date="2024-10-10">(accessed on 10 October 2024)</date-in-citation></element-citation></ref><ref id="B26-sensors-25-01277"><label>26.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Arute</surname><given-names>F.</given-names></name>
<name><surname>Arya</surname><given-names>K.</given-names></name>
<name><surname>Babbush</surname><given-names>R.</given-names></name>
<name><surname>Bacon</surname><given-names>D.</given-names></name>
<name><surname>Bardin</surname><given-names>J.C.</given-names></name>
<name><surname>Barends</surname><given-names>R.</given-names></name>
<name><surname>Biswas</surname><given-names>R.</given-names></name>
<name><surname>Boixo</surname><given-names>S.</given-names></name>
<name><surname>Brandao</surname><given-names>F.G.</given-names></name>
<name><surname>Buell</surname><given-names>D.A.</given-names></name>
<etal/>
</person-group><article-title>Quantum supremacy using a programmable superconducting processor</article-title><source>Nature</source><year>2019</year><volume>574</volume><fpage>505</fpage><lpage>510</lpage><pub-id pub-id-type="doi">10.1038/s41586-019-1666-5</pub-id><pub-id pub-id-type="pmid">31645734</pub-id>
</element-citation></ref><ref id="B27-sensors-25-01277"><label>27.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Van der Walt</surname><given-names>S.</given-names></name>
<name><surname>Sch&#x000f6;nberger</surname><given-names>J.L.</given-names></name>
<name><surname>Nunez-Iglesias</surname><given-names>J.</given-names></name>
<name><surname>Boulogne</surname><given-names>F.</given-names></name>
<name><surname>Warner</surname><given-names>J.D.</given-names></name>
<name><surname>Yager</surname><given-names>N.</given-names></name>
<name><surname>Gouillart</surname><given-names>E.</given-names></name>
<name><surname>Yu</surname><given-names>T.</given-names></name>
</person-group><article-title>Scikit-image: Image processing in Python</article-title><source>PeerJ</source><year>2014</year><volume>2</volume><fpage>e453</fpage><pub-id pub-id-type="doi">10.7717/peerj.453</pub-id><pub-id pub-id-type="pmid">25024921</pub-id>
</element-citation></ref><ref id="B28-sensors-25-01277"><label>28.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Mainak</surname><given-names>R.</given-names></name>
<name><surname>Jessica</surname><given-names>J.B.</given-names></name>
<name><surname>Ryan</surname><given-names>H.</given-names></name>
<name><surname>Victor</surname><given-names>O.</given-names></name>
</person-group><article-title>Simulating open quantum systems using noise models and NISQ devices with error mitigation</article-title><source>arXiv</source><year>2024</year><pub-id pub-id-type="arxiv">2401.06535v1</pub-id></element-citation></ref><ref id="B29-sensors-25-01277"><label>29.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Monz&#x000f3;n-Verona</surname><given-names>J.M.</given-names></name>
<name><surname>Garc&#x000ed;a-Alonso</surname><given-names>S.</given-names></name>
<name><surname>Santana-Mart&#x000ed;n</surname><given-names>F.J.</given-names></name>
</person-group><article-title>Software and dataset of Quantum Variational vs. Quantum Kernel Machine Learning Models for Partial Discharge Classification in Dielectric Oils</article-title><source>Zenodo</source><year>2024</year><pub-id pub-id-type="doi">10.5281/zenodo.14589724</pub-id></element-citation></ref><ref id="B30-sensors-25-01277"><label>30.</label><element-citation publication-type="book"><std>IS IEC 60270:2000AMD1:2015 CSV</std><source>High-Voltage Test Techniques&#x02014;Partial Discharge Measurements</source><comment>Edition 3.1, 2015&#x02013;11; Consolidated Version</comment><publisher-name>International Electrotechnical Commission</publisher-name><publisher-loc>Geneva, Switzerland</publisher-loc><year>2015</year></element-citation></ref><ref id="B31-sensors-25-01277"><label>31.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Monz&#x000f3;n-Verona</surname><given-names>J.M.</given-names></name>
<name><surname>Gonz&#x000e1;lez-Dom&#x000ed;nguez</surname><given-names>P.</given-names></name>
<name><surname>Garc&#x000ed;a-Alonso</surname><given-names>S.</given-names></name>
</person-group><article-title>Characterization of Partial Discharges in Dielectric Oils Using High-Resolution CMOS Image Sensor and Convolutional Neural Networks</article-title><source>Sensors</source><year>2024</year><volume>24</volume><elocation-id>1317</elocation-id><pub-id pub-id-type="doi">10.3390/s24041317</pub-id><pub-id pub-id-type="pmid">38400475</pub-id>
</element-citation></ref><ref id="B32-sensors-25-01277"><label>32.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Virtanen</surname><given-names>P.</given-names></name>
<name><surname>Gommers</surname><given-names>R.</given-names></name>
<name><surname>Oliphant</surname><given-names>T.E.</given-names></name>
<name><surname>Haberland</surname><given-names>M.</given-names></name>
<name><surname>Reddy</surname><given-names>T.</given-names></name>
<name><surname>Cournapeau</surname><given-names>D.</given-names></name>
<name><surname>Burovski</surname><given-names>E.</given-names></name>
<name><surname>Peterson</surname><given-names>P.</given-names></name>
<name><surname>Weckesser</surname><given-names>W.</given-names></name>
<name><surname>Bright</surname><given-names>J.</given-names></name>
<etal/>
</person-group><article-title>SciPy 1.0: Fundamental algorithms for scientific computing in Python</article-title><source>Nat. Methods</source><year>2020</year><volume>17</volume><fpage>261</fpage><lpage>272</lpage><pub-id pub-id-type="doi">10.1038/s41592-019-0686-2</pub-id><pub-id pub-id-type="pmid">32015543</pub-id>
</element-citation></ref><ref id="B33-sensors-25-01277"><label>33.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Spall</surname><given-names>J.C.</given-names></name>
</person-group><article-title>Implementation of the Simultaneous Perturbation Algorithm for Stochastic Optimization</article-title><source>IEEE Trans. Aerosp. Electron. Syst.</source><year>1998</year><volume>34</volume><fpage>817</fpage><lpage>823</lpage><pub-id pub-id-type="doi">10.1109/7.705889</pub-id></element-citation></ref><ref id="B34-sensors-25-01277"><label>34.</label><element-citation publication-type="book"><person-group person-group-type="author">
<name><surname>Andrei</surname><given-names>N.</given-names></name>
</person-group><article-title>Direct Methods for Constrained Optimization</article-title><source>Modern Numerical Nonlinear Optimization</source><publisher-name>Springer International Publishing</publisher-name><publisher-loc>Berlin/Heidelberg, Germany</publisher-loc><year>2022</year><fpage>679</fpage><lpage>689</lpage><pub-id pub-id-type="doi">10.1007/978-3-031-08720-2_20</pub-id></element-citation></ref><ref id="B35-sensors-25-01277"><label>35.</label><element-citation publication-type="webpage"><person-group person-group-type="author">
<collab>IBM Quantum Documentation</collab>
</person-group><article-title>Qiskit SDK</article-title><comment>Available online: <ext-link xlink:href="https://docs.quantum.ibm.com/guides/circuit-library" ext-link-type="uri">https://docs.quantum.ibm.com/guides/circuit-library</ext-link></comment><date-in-citation content-type="access-date" iso-8601-date="2024-10-10">(accessed on 10 October 2024)</date-in-citation></element-citation></ref><ref id="B36-sensors-25-01277"><label>36.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Connor</surname><given-names>R.</given-names></name>
<name><surname>Dearle</surname><given-names>A.</given-names></name>
<name><surname>Claydon</surname><given-names>B.</given-names></name>
<name><surname>Vadicamo</surname><given-names>L.</given-names></name>
</person-group><article-title>Correlations of Cross-Entropy Loss in Machine Learning</article-title><source>Entropy</source><year>2024</year><volume>26</volume><elocation-id>491</elocation-id><pub-id pub-id-type="doi">10.3390/e26060491</pub-id><pub-id pub-id-type="pmid">38920500</pub-id>
</element-citation></ref><ref id="B37-sensors-25-01277"><label>37.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Javadi-Abhari</surname><given-names>A.</given-names></name>
<name><surname>Treinish</surname><given-names>M.</given-names></name>
<name><surname>Krsulich</surname><given-names>K.</given-names></name>
<name><surname>Wood</surname><given-names>C.J.</given-names></name>
<name><surname>Lishman</surname><given-names>J.</given-names></name>
<name><surname>Gacon</surname><given-names>J.</given-names></name>
<name><surname>Martiel</surname><given-names>S.</given-names></name>
<name><surname>Nation</surname><given-names>P.D.</given-names></name>
<name><surname>Bishop</surname><given-names>L.S.</given-names></name>
<name><surname>Cross</surname><given-names>A.W.</given-names></name>
<etal/>
</person-group><article-title>Quantum computing with Qiskit</article-title><source>arXiv</source><year>2024</year><pub-id pub-id-type="doi">10.48550/arXiv.2405.08810</pub-id><pub-id pub-id-type="arxiv">2405.08810</pub-id></element-citation></ref><ref id="B38-sensors-25-01277"><label>38.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Toshinar</surname><given-names>I.</given-names></name>
<name><surname>Moein</surname><given-names>M.</given-names></name>
<name><surname>Naoki</surname><given-names>K.</given-names></name>
<name><surname>Maika</surname><given-names>T.</given-names></name>
</person-group><article-title>Three-qubit Parity Gate via Simultaneous Cross Resonance Drives</article-title><source>arXiv</source><year>2023</year><pub-id pub-id-type="doi">10.48550/arXiv.2309.11287</pub-id><pub-id pub-id-type="arxiv">2309.11287</pub-id></element-citation></ref><ref id="B39-sensors-25-01277"><label>39.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Campbell</surname><given-names>C.</given-names></name>
<name><surname>Chong</surname><given-names>F.T.</given-names></name>
<name><surname>Dahl</surname><given-names>D.</given-names></name>
<name><surname>Frederick</surname><given-names>P.</given-names></name>
<name><surname>Goiporia</surname><given-names>P.</given-names></name>
<name><surname>Gokhale</surname><given-names>P.</given-names></name>
<name><surname>Hall</surname><given-names>B.</given-names></name>
<name><surname>Issa</surname><given-names>S.</given-names></name>
<name><surname>Jones</surname><given-names>E.</given-names></name>
<name><surname>Lee</surname><given-names>S.</given-names></name>
<etal/>
</person-group><article-title>Superstaq: Deep Optimization of Quantum Programs</article-title><source>arXiv</source><year>2023</year><pub-id pub-id-type="doi">10.48550/arXiv.2309.05157</pub-id><pub-id pub-id-type="arxiv">2309.05157</pub-id></element-citation></ref><ref id="B40-sensors-25-01277"><label>40.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Keerthi</surname><given-names>S.S.</given-names></name>
<name><surname>Shevade</surname><given-names>S.K.</given-names></name>
<name><surname>Bhattacharyya</surname><given-names>C.</given-names></name>
<name><surname>Murthy</surname><given-names>K.R.K.</given-names></name>
</person-group><article-title>Improvements to Platt&#x02019;s SMO Algorithm for SVM Classifier Design</article-title><source>Neural Comput.</source><year>2001</year><volume>13</volume><fpage>637</fpage><lpage>649</lpage><pub-id pub-id-type="doi">10.1162/089976601300014493</pub-id></element-citation></ref></ref-list></back><floats-group><fig position="float" id="sensors-25-01277-f001"><label>Figure 1</label><caption><p>(<bold>a</bold>) Reference images at the electrodes with their four possible classes associated with the discharges in mineral oil, class 0 (PD), class 1 (NOPD), class 2 (ARC) and class 3 (BREAK). (<bold>b</bold>) Experimental device made for the collection of images [<xref rid="B31-sensors-25-01277" ref-type="bibr">31</xref>].</p></caption><graphic xlink:href="sensors-25-01277-g001" position="float"/></fig><fig position="float" id="sensors-25-01277-f002"><label>Figure 2</label><caption><p>PD and its processing at 93.33 s. PD are shown in red and green color. (<bold>a</bold>) Selection and analysis of ROI, electrodes, and class 0 discharge. (<bold>b</bold>) Image obtained with the Scikit-image environment [<xref rid="B27-sensors-25-01277" ref-type="bibr">27</xref>].</p></caption><graphic xlink:href="sensors-25-01277-g002" position="float"/></fig><fig position="float" id="sensors-25-01277-f003"><label>Figure 3</label><caption><p>Features obtained from the BREAK class are shown in red and green. (<bold>a</bold>) Image of the electrodes and the red-colored area of the post-arc bubbles, obtained at time 29.52 s. (<bold>b</bold>) Image resulting after the Scikit-image program was applied.</p></caption><graphic xlink:href="sensors-25-01277-g003" position="float"/></fig><fig position="float" id="sensors-25-01277-f004"><label>Figure 4</label><caption><p>Relationships between five of the thirteen normalized features in the interval [0, 2<italic toggle="yes">&#x003c0;</italic>] corresponding to the PD-BREAK class combination.</p></caption><graphic xlink:href="sensors-25-01277-g004" position="float"/></fig><fig position="float" id="sensors-25-01277-f005"><label>Figure 5</label><caption><p>Main blocks of a QVM. The red block runs on the quantum computer, the blue one on the classical.</p></caption><graphic xlink:href="sensors-25-01277-g005" position="float"/></fig><fig position="float" id="sensors-25-01277-f006"><label>Figure 6</label><caption><p><italic toggle="yes">H</italic> is the Hadamard gate presented in Equation (7); <italic toggle="yes">P</italic> is the phase gate that performs a rotation around the z axis of the complex plane; <italic toggle="yes">Ry</italic> performs a rotation around the <italic toggle="yes">y</italic> axis. This circuit contains 10 parameters. a, b and c show the logical connection of the two levels in the diagram.</p></caption><graphic xlink:href="sensors-25-01277-g006" position="float"/></fig><fig position="float" id="sensors-25-01277-f007"><label>Figure 7</label><caption><p><italic toggle="yes">U</italic><sub>2</sub> = <italic toggle="yes">U</italic><sub>2</sub>(<italic toggle="yes">&#x003d5;</italic>,<italic toggle="yes">&#x003bb;</italic>) = <italic toggle="yes">U</italic><sub>2</sub>(0,<italic toggle="yes">&#x003c0;</italic>) = <italic toggle="yes">H</italic>, <italic toggle="yes">U</italic>(<italic toggle="yes">&#x003b8;</italic>,<italic toggle="yes">&#x003d5;</italic>,<italic toggle="yes">&#x003bb;</italic>) = <italic toggle="yes">U</italic>(0,0,<italic toggle="yes">&#x003bb;</italic>) = <italic toggle="yes">P</italic>(<italic toggle="yes">&#x003bb;</italic>); <italic toggle="yes">R</italic> = <italic toggle="yes">Ry</italic>. This circuit contains 11 parameters. a, b and c show the logical connection of the two levels in the diagram.</p></caption><graphic xlink:href="sensors-25-01277-g007" position="float"/></fig><fig position="float" id="sensors-25-01277-f008"><label>Figure 8</label><caption><p>Transpilation of the 11 parameters of the circuit shown in <xref rid="sensors-25-01277-f007" ref-type="fig">Figure 7</xref>, where a1&#x02013;a3, b1&#x02013;b3, c1&#x02013;c3 show the logical connection of the four levels in the diagram.</p></caption><graphic xlink:href="sensors-25-01277-g008" position="float"/></fig><fig position="float" id="sensors-25-01277-f009"><label>Figure 9</label><caption><p>Evolution of the cost function in the optimization process for the COBYLA algorithm corresponding to <xref rid="sensors-25-01277-t001" ref-type="table">Table 1</xref>. (<bold>a</bold>) Evolution of the cost function for the PD_ARC combination. (<bold>b</bold>) Evolution of the cost function for the PD_NOPD combination.</p></caption><graphic xlink:href="sensors-25-01277-g009" position="float"/></fig><fig position="float" id="sensors-25-01277-f010"><label>Figure 10</label><caption><p>Measurement results for the PD_NOPD model for two images with the IBM Osaka quantum computer vs. simulation. (<bold>a</bold>) Measurements obtained for two values belonging to the PD class, odd parity. (<bold>b</bold>) Measurements obtained for two values belonging to the NOPD class, even parity.</p></caption><graphic xlink:href="sensors-25-01277-g010" position="float"/></fig><fig position="float" id="sensors-25-01277-f011"><label>Figure 11</label><caption><p>Generic structure of the quantum circuit and measurement used to estimate the kernel of Equation (26). It is particularized for three features. The number 3 represents the set of the three measured features 0, 1 and 2. q0, q1 and q2 are the input qubits to the quantum circuit.</p></caption><graphic xlink:href="sensors-25-01277-g011" position="float"/></fig><fig position="float" id="sensors-25-01277-f012"><label>Figure 12</label><caption><p>(<bold>a</bold>) Exactly computed two-feature kernel matrix for the PD_BREAK combination. Simulation result of the symmetric 580 &#x000d7; 580 element kernel matrix obtained with Equation (26), for PD_BREAK. (<bold>b</bold>) Comparison of results for the IBM Kyoto computer. Verification of results for row 40 and columns 0 to 24 of the matrix shown in (<bold>a</bold>), simulation in blue. Where the orange and blue colors overlap, a magenta color is displayed.</p></caption><graphic xlink:href="sensors-25-01277-g012" position="float"/></fig><fig position="float" id="sensors-25-01277-f013"><label>Figure 13</label><caption><p>(<bold>a</bold>) One hundred forty values randomly chosen from the kernel matrix for PD_BREAK. (<bold>b</bold>) Comparison of results for the real IBM Kyoto computer with the simulation and mean absolute percentage error (MAPE) = 7.6%, on the real IBM Kyoto computer.</p></caption><graphic xlink:href="sensors-25-01277-g013" position="float"/></fig><fig position="float" id="sensors-25-01277-f014"><label>Figure 14</label><caption><p>(<bold>a</bold>) One hundred forty randomly selected values from the kernel matrix for PD_BREAK, obtained using the IBM Osaka computer. (<bold>b</bold>) Comparison of results for the real IBM Osaka computer with the simulation, for the PD_BREAK combination. Execution time 2 m 34 s.</p></caption><graphic xlink:href="sensors-25-01277-g014" position="float"/></fig><fig position="float" id="sensors-25-01277-f015"><label>Figure 15</label><caption><p>(<bold>a</bold>) Exactly computed two-feature kernel matrix for the PD_NOPD combination. The kernel matrix is symmetrical with 693 &#x000d7; 693 elements. (<bold>b</bold>) Comparison of results for the real IBM Osaka computer and verification of results for row 40 and columns 0 to 24 of the matrix shown in (<bold>a</bold>), simulation in blue. Where the orange and blue colors overlap, a magenta color is displayed.</p></caption><graphic xlink:href="sensors-25-01277-g015" position="float"/></fig><fig position="float" id="sensors-25-01277-f016"><label>Figure 16</label><caption><p>(<bold>a</bold>) Exactly computed two-feature kernel matrix for the BREAK_NOPD combination. The kernel matrix is symmetrical with 517 &#x000d7; 517 elements. (<bold>b</bold>) Comparison of results for the real IBM Brisbane computer and verification of results for row 40 and columns 0 to 24 of the matrix shown in (<bold>a</bold>), simulation in blue. Where the orange and blue colors overlap, a magenta color is displayed.</p></caption><graphic xlink:href="sensors-25-01277-g016" position="float"/></fig><fig position="float" id="sensors-25-01277-f017"><label>Figure 17</label><caption><p>(<bold>a</bold>) Exactly computed two-feature kernel matrix for the PD_ARC combination. The kernel matrix is symmetrical with 694 &#x000d7; 694 elements. (<bold>b</bold>) Comparison of results for the real IBM Kyoto computer and verification of results for row 40 and columns 0 to 24 of the matrix shown in (<bold>a</bold>), simulation in blue. Where the orange and blue colors overlap, a magenta color is displayed.</p></caption><graphic xlink:href="sensors-25-01277-g017" position="float"/></fig><fig position="float" id="sensors-25-01277-f018"><label>Figure 18</label><caption><p>Overall flowchart and Jupyter Notebooks.</p></caption><graphic xlink:href="sensors-25-01277-g018" position="float"/></fig><table-wrap position="float" id="sensors-25-01277-t001"><object-id pub-id-type="pii">sensors-25-01277-t001_Table 1</object-id><label>Table 1</label><caption><p>Optimal parameters for the QVM circuits of <xref rid="sensors-25-01277-f006" ref-type="fig">Figure 6</xref> and <xref rid="sensors-25-01277-f007" ref-type="fig">Figure 7</xref>, with 10 and 11 parameters, respectively.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Optimal Parameters</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">PD_NOPD</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">PD_BREAK</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">PD_ARC</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">BREAK_NOPD</th></tr></thead><tbody><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>&#x003b8;(0)</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;1.36</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;0.46</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;2.03</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;0.11</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>&#x003b8;(1)</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">0.73</td><td align="center" valign="middle" rowspan="1" colspan="1">3.01</td><td align="center" valign="middle" rowspan="1" colspan="1">2.49</td><td align="center" valign="middle" rowspan="1" colspan="1">5.64</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>&#x003b8;(2)</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">0.46</td><td align="center" valign="middle" rowspan="1" colspan="1">0.35</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;0.12</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;2.54</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>&#x003b8;(3)</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;0.23</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;0.43</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;0.75</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;2.71</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>&#x003b8;(4)</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">0.72</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;3.04</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;1.36</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;6.40</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>&#x003b8;(5)</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;5.04</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;5.67</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;5.43</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;1.20</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>&#x003b8;(6)</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">0.25</td><td align="center" valign="middle" rowspan="1" colspan="1">1.70</td><td align="center" valign="middle" rowspan="1" colspan="1">1.55</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;0.99</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>&#x003b8;(7)</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">3.20</td><td align="center" valign="middle" rowspan="1" colspan="1">6.01</td><td align="center" valign="middle" rowspan="1" colspan="1">5.31</td><td align="center" valign="middle" rowspan="1" colspan="1">8.97</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>&#x003b8;(8)</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">2.22</td><td align="center" valign="middle" rowspan="1" colspan="1">5.84</td><td align="center" valign="middle" rowspan="1" colspan="1">5.63</td><td align="center" valign="middle" rowspan="1" colspan="1">4.15</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>&#x003b8;(9)</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">2.8</td><td align="center" valign="middle" rowspan="1" colspan="1">2.26</td><td align="center" valign="middle" rowspan="1" colspan="1">3.50</td><td align="center" valign="middle" rowspan="1" colspan="1">8.22</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>&#x003b8;(10)</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02014;</td><td align="center" valign="middle" rowspan="1" colspan="1">1.56</td><td align="center" valign="middle" rowspan="1" colspan="1">1.18</td><td align="center" valign="middle" rowspan="1" colspan="1">1.53</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1"><bold>Accuracy</bold>&#x000a0;<sup>1</sup></td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">[0.90:0.93]</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">[0.93:0.95]</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">[0.82:0.83]</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">[0.85:0.82]</td></tr></tbody></table><table-wrap-foot><fn><p><sup>1</sup> [train:test].</p></fn></table-wrap-foot></table-wrap><table-wrap position="float" id="sensors-25-01277-t002"><object-id pub-id-type="pii">sensors-25-01277-t002_Table 2</object-id><label>Table 2</label><caption><p>Calibration data for computers used in the experiments from IBM.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Mean Property</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">IBM Osaka</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">IBM Kyoto</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">IBM Brisbane</th></tr></thead><tbody><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>T1 (&#x000b5;s)</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">287.09</td><td align="center" valign="middle" rowspan="1" colspan="1">215.43</td><td align="center" valign="middle" rowspan="1" colspan="1">228.55</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>T2 (&#x000b5;s)</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">144.57</td><td align="center" valign="middle" rowspan="1" colspan="1">109.44</td><td align="center" valign="middle" rowspan="1" colspan="1">151.41</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>SX error %</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">3.053 &#x000d7; 10<sup>&#x02212;2</sup></td><td align="center" valign="middle" rowspan="1" colspan="1">3.073 &#x000d7; 10<sup>&#x02212;2</sup></td><td align="center" valign="middle" rowspan="1" colspan="1">2.409 &#x000d7; 10<sup>&#x02212;2</sup></td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>ECR error %</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">8.032 &#x000d7; 10<sup>&#x02212;1</sup></td><td align="center" valign="middle" rowspan="1" colspan="1">9.345 &#x000d7; 10<sup>&#x02212;1</sup></td><td align="center" valign="middle" rowspan="1" colspan="1">7.820 &#x000d7; 10<sup>&#x02212;1</sup></td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>EPLG error %</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">3.3</td><td align="center" valign="middle" rowspan="1" colspan="1">3.6</td><td align="center" valign="middle" rowspan="1" colspan="1">2.0</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">
<bold>Readout error %</bold>
</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">2.210</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">1.540</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">1.350</td></tr></tbody></table></table-wrap><table-wrap position="float" id="sensors-25-01277-t003"><object-id pub-id-type="pii">sensors-25-01277-t003_Table 3</object-id><label>Table 3</label><caption><p>Accuracy, time (s), and numbers of variational quantum circuits used in the IBM computers in the experiments corresponding to <xref rid="sensors-25-01277-f006" ref-type="fig">Figure 6</xref> and <xref rid="sensors-25-01277-f007" ref-type="fig">Figure 7</xref>, with 10 and 11 parameters, respectively.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">
</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">PD_NOPD</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">PD_BREAK</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">PD_ARC</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">BREAK_NOPD</th></tr></thead><tbody><tr><td align="center" valign="middle" rowspan="1" colspan="1">Accuracy <sup>1</sup> simulation</td><td align="center" valign="middle" rowspan="1" colspan="1">[0.90:0.93]</td><td align="center" valign="middle" rowspan="1" colspan="1">[0.93:0.95]</td><td align="center" valign="middle" rowspan="1" colspan="1">[0.82:0.83]</td><td align="center" valign="middle" rowspan="1" colspan="1">[0.85:0.82]</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">Accuracy <sup>1</sup> Kyoto</td><td align="center" valign="middle" rowspan="1" colspan="1">[0.90:0.92]</td><td align="center" valign="middle" rowspan="1" colspan="1">[0.95:0.91]</td><td align="center" valign="middle" rowspan="1" colspan="1">[0.80:0.88]</td><td align="center" valign="middle" rowspan="1" colspan="1">[0.85:0.87]</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">Accuracy <sup>1</sup> Brisbane</td><td align="center" valign="middle" rowspan="1" colspan="1">[0.90:0.92]</td><td align="center" valign="middle" rowspan="1" colspan="1">[0.93:0.91]</td><td align="center" valign="middle" rowspan="1" colspan="1">[0.80:0.88]</td><td align="center" valign="middle" rowspan="1" colspan="1">[0.84:0.85]</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">Accuracy <sup>1</sup> Osaka</td><td align="center" valign="middle" rowspan="1" colspan="1">[0.92:0.92]</td><td align="center" valign="middle" rowspan="1" colspan="1">[0.95:0.91]</td><td align="center" valign="middle" rowspan="1" colspan="1">[0.80:0.80]</td><td align="center" valign="middle" rowspan="1" colspan="1">[0.85:0.88]</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">Time (s) <sup>1</sup> Kyoto</td><td align="center" valign="middle" rowspan="1" colspan="1">[150:150]</td><td align="center" valign="middle" rowspan="1" colspan="1">[150:150]</td><td align="center" valign="middle" rowspan="1" colspan="1">[150:150]</td><td align="center" valign="middle" rowspan="1" colspan="1">[149:110]</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">Time (s) <sup>1</sup> Brisbane</td><td align="center" valign="middle" rowspan="1" colspan="1">[151:150]</td><td align="center" valign="middle" rowspan="1" colspan="1">[110:149]</td><td align="center" valign="middle" rowspan="1" colspan="1">[149:150]</td><td align="center" valign="middle" rowspan="1" colspan="1">[149:110]</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">Time (s) <sup>1</sup> Osaka</td><td align="center" valign="middle" rowspan="1" colspan="1">[150:150]</td><td align="center" valign="middle" rowspan="1" colspan="1">[149:149]</td><td align="center" valign="middle" rowspan="1" colspan="1">[149:149]</td><td align="center" valign="middle" rowspan="1" colspan="1">[149:110]</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">Circuits <sup>1</sup> Kyoto</td><td align="center" valign="middle" rowspan="1" colspan="1">[136:136]</td><td align="center" valign="middle" rowspan="1" colspan="1">[136:136]</td><td align="center" valign="middle" rowspan="1" colspan="1">[136:136]</td><td align="center" valign="middle" rowspan="1" colspan="1">[136:100]</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">Circuits <sup>1</sup> Brisbane</td><td align="center" valign="middle" rowspan="1" colspan="1">[136:136]</td><td align="center" valign="middle" rowspan="1" colspan="1">[100:136]</td><td align="center" valign="middle" rowspan="1" colspan="1">[136:136]</td><td align="center" valign="middle" rowspan="1" colspan="1">[136:100]</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Circuits <sup>1</sup> Osaka</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">[136:136]</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">[136:136]</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">[136:136]</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">[136:100]</td></tr></tbody></table><table-wrap-foot><fn><p><sup>1</sup> [train:test].</p></fn></table-wrap-foot></table-wrap><table-wrap position="float" id="sensors-25-01277-t004"><object-id pub-id-type="pii">sensors-25-01277-t004_Table 4</object-id><label>Table 4</label><caption><p>Accuracy and execution times for two qubits x = [&#x02018;area-pixels&#x02019;, &#x02018;mean-coords-x&#x02019;] with test_size = 20%.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">
</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">PD_NOPD</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">PD_BREAK</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">PD_ARC</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">BREAK_NOPD</th></tr></thead><tbody><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>Accuracy [train]</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">0.95</td><td align="center" valign="middle" rowspan="1" colspan="1">0.90</td><td align="center" valign="middle" rowspan="1" colspan="1">0.84</td><td align="center" valign="middle" rowspan="1" colspan="1">0.93</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>Accuracy [test]</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">0.97</td><td align="center" valign="middle" rowspan="1" colspan="1">0.94</td><td align="center" valign="middle" rowspan="1" colspan="1">0.83</td><td align="center" valign="middle" rowspan="1" colspan="1">0.92</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>Train execution time (s)</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">5040</td><td align="center" valign="middle" rowspan="1" colspan="1">3573</td><td align="center" valign="middle" rowspan="1" colspan="1">5357</td><td align="center" valign="middle" rowspan="1" colspan="1">2911</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>Test execution time (s)</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">2587</td><td align="center" valign="middle" rowspan="1" colspan="1">1768</td><td align="center" valign="middle" rowspan="1" colspan="1">2639</td><td align="center" valign="middle" rowspan="1" colspan="1">1476</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>SVM fit training time (s)</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">0.019</td><td align="center" valign="middle" rowspan="1" colspan="1">0.016</td><td align="center" valign="middle" rowspan="1" colspan="1">0.018</td><td align="center" valign="middle" rowspan="1" colspan="1">0.012</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>Matrix dimension</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">693</td><td align="center" valign="middle" rowspan="1" colspan="1">580</td><td align="center" valign="middle" rowspan="1" colspan="1">694</td><td align="center" valign="middle" rowspan="1" colspan="1">517</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">
<bold>
<italic toggle="yes">C</italic>
<sub>1</sub>
</bold>
</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">1</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">1</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">1</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">1</td></tr></tbody></table></table-wrap><table-wrap position="float" id="sensors-25-01277-t005"><object-id pub-id-type="pii">sensors-25-01277-t005_Table 5</object-id><label>Table 5</label><caption><p>Accuracy and execution times for three qubits Equation (28), with symmetric matrix, test_size = 80%.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">
</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">PD_NOPD</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">PD_BREAK</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">PD_ARC</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">BREAK_NOPD</th></tr></thead><tbody><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>Accuracy [train]</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">0.99</td><td align="center" valign="middle" rowspan="1" colspan="1">0.95</td><td align="center" valign="middle" rowspan="1" colspan="1">0.92</td><td align="center" valign="middle" rowspan="1" colspan="1">0.95</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>Accuracy [test]</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">0.99</td><td align="center" valign="middle" rowspan="1" colspan="1">0.85</td><td align="center" valign="middle" rowspan="1" colspan="1">0.84</td><td align="center" valign="middle" rowspan="1" colspan="1">0.92</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>Train execution time (s)</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">307</td><td align="center" valign="middle" rowspan="1" colspan="1">177</td><td align="center" valign="middle" rowspan="1" colspan="1">307</td><td align="center" valign="middle" rowspan="1" colspan="1">157</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>Test execution time (s)</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">3509</td><td align="center" valign="middle" rowspan="1" colspan="1">1300</td><td align="center" valign="middle" rowspan="1" colspan="1">3509</td><td align="center" valign="middle" rowspan="1" colspan="1">1290</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>SVM fit training time (s)</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">0.004</td><td align="center" valign="middle" rowspan="1" colspan="1">0.001</td><td align="center" valign="middle" rowspan="1" colspan="1">0.004</td><td align="center" valign="middle" rowspan="1" colspan="1">0.001</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>Matrix dimension</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">173</td><td align="center" valign="middle" rowspan="1" colspan="1">135</td><td align="center" valign="middle" rowspan="1" colspan="1">173</td><td align="center" valign="middle" rowspan="1" colspan="1">129</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">
<bold>
<italic toggle="yes">C</italic>
<sub>1</sub>
</bold>
</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">1</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">1</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">1</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">1</td></tr></tbody></table></table-wrap><table-wrap position="float" id="sensors-25-01277-t006"><object-id pub-id-type="pii">sensors-25-01277-t006_Table 6</object-id><label>Table 6</label><caption><p>Accuracy and execution times for eight qubits Equation (29) with symmetric matrix, test_size = 80%.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">
</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">PD_NOPD</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">PD_BREAK</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">PD_ARC</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">BREAK_NOPD</th></tr></thead><tbody><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>Accuracy [train]</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">1</td><td align="center" valign="middle" rowspan="1" colspan="1">1</td><td align="center" valign="middle" rowspan="1" colspan="1">1</td><td align="center" valign="middle" rowspan="1" colspan="1">1</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>Accuracy [test]</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">0.99</td><td align="center" valign="middle" rowspan="1" colspan="1">0.94</td><td align="center" valign="middle" rowspan="1" colspan="1">0.99</td><td align="center" valign="middle" rowspan="1" colspan="1">0.98</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>Train execution time (s)</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">531</td><td align="center" valign="middle" rowspan="1" colspan="1">323</td><td align="center" valign="middle" rowspan="1" colspan="1">529</td><td align="center" valign="middle" rowspan="1" colspan="1">294</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>Test execution time (s)</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">4229</td><td align="center" valign="middle" rowspan="1" colspan="1">2567</td><td align="center" valign="middle" rowspan="1" colspan="1">4214</td><td align="center" valign="middle" rowspan="1" colspan="1">2352</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>SVM fit training time (s)</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">0.001</td><td align="center" valign="middle" rowspan="1" colspan="1">0.001</td><td align="center" valign="middle" rowspan="1" colspan="1">0.001</td><td align="center" valign="middle" rowspan="1" colspan="1">0.001</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<bold>Matrix dimension</bold>
</td><td align="center" valign="middle" rowspan="1" colspan="1">173</td><td align="center" valign="middle" rowspan="1" colspan="1">135</td><td align="center" valign="middle" rowspan="1" colspan="1">173</td><td align="center" valign="middle" rowspan="1" colspan="1">129</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">
<bold>
<italic toggle="yes">C</italic>
<sub>1</sub>
</bold>
</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">1</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">1</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">1</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">1</td></tr></tbody></table></table-wrap></floats-group></article>