<!DOCTYPE article
PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD with MathML3 v1.3 20210610//EN" "JATS-archivearticle1-3-mathml3.dtd">
<article xmlns:ali="http://www.niso.org/schemas/ali/1.0/" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" article-type="research-article" dtd-version="1.3"><?properties open_access?><processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats"><restricted-by>pmc</restricted-by></processing-meta><front><journal-meta><journal-id journal-id-type="nlm-ta">Autom Softw Eng</journal-id><journal-id journal-id-type="iso-abbrev">Autom Softw Eng</journal-id><journal-title-group><journal-title>Automated Software Engineering</journal-title></journal-title-group><issn pub-type="ppub">0928-8910</issn><issn pub-type="epub">1573-7535</issn><publisher><publisher-name>Springer US</publisher-name><publisher-loc>New York</publisher-loc></publisher></journal-meta>
<article-meta><article-id pub-id-type="pmc">PMC11972209</article-id><article-id pub-id-type="publisher-id">472</article-id><article-id pub-id-type="doi">10.1007/s10515-024-00472-7</article-id><article-categories><subj-group subj-group-type="heading"><subject>Article</subject></subj-group></article-categories><title-group><article-title>Multi-objective improvement of Android applications</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Callan</surname><given-names>James</given-names></name><xref ref-type="aff" rid="Aff1"/></contrib><contrib contrib-type="author" corresp="yes"><name><surname>Petke</surname><given-names>Justyna</given-names></name><address><email>j.petke@ucl.ac.uk</email></address><xref ref-type="aff" rid="Aff1"/></contrib><aff id="Aff1"><institution-wrap><institution-id institution-id-type="ROR">https://ror.org/02jx3x895</institution-id><institution-id institution-id-type="GRID">grid.83440.3b</institution-id><institution-id institution-id-type="ISNI">0000 0001 2190 1201</institution-id><institution>Computer Science Department, </institution><institution>University College London, </institution></institution-wrap>Gower Street, London, Greater London WC1E 6BT UK </aff></contrib-group><pub-date pub-type="epub"><day>4</day><month>11</month><year>2024</year></pub-date><pub-date pub-type="pmc-release"><day>4</day><month>11</month><year>2024</year></pub-date><pub-date pub-type="ppub"><year>2025</year></pub-date><volume>32</volume><issue>1</issue><elocation-id>2</elocation-id><history><date date-type="received"><day>31</day><month>7</month><year>2024</year></date><date date-type="accepted"><day>3</day><month>10</month><year>2024</year></date></history><permissions><copyright-statement>&#x000a9; The Author(s) 2024</copyright-statement><copyright-year>2024</copyright-year><license><ali:license_ref specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref><license-p><bold>Open Access</bold> This article is licensed under a Creative Commons Attribution 4.0 International License, which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons licence, and indicate if changes were made. The images or other third party material in this article are included in the article's Creative Commons licence, unless indicated otherwise in a credit line to the material. If material is not included in the article's Creative Commons licence and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder. To view a copy of this licence, visit <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>.</license-p></license></permissions><abstract id="Abs1"><p id="Par1">Non-functional properties, such as runtime or memory use, are important to mobile app users and developers, as they affect user experience. We propose a practical approach and the first open-source tool, GIDroid for multi-objective automated improvement of Android apps. In particular, we use Genetic Improvement, a search-based technique that navigates the space of software variants to find improved software. We use a simulation-based testing framework to greatly improve the speed of search. GIDroid&#x000a0;contains three state-of-the-art multi-objective algorithms, and two new mutation operators, which cache the results of method calls. Genetic Improvement relies on testing to validate patches. Previous work showed that tests in open-source Android applications are scarce. We thus wrote tests for 21 versions of 7 Android apps, creating a new benchmark for performance improvements. We used GIDroid&#x000a0;to improve versions of mobile apps where developers had previously found improvements to runtime, memory, and bandwidth use. Our technique automatically re-discovers 64% of existing improvements. We then applied our approach to current versions of software in which there were no known improvements. We were able to improve execution time by up to 35%, and memory use by up to 33% in these apps.
</p></abstract><kwd-group xml:lang="en"><title>Keywords</title><kwd>Android apps</kwd><kwd>Genetic improvement</kwd><kwd>Multi-objective optimization</kwd><kwd>Search-based software engineering</kwd></kwd-group><funding-group><award-group><funding-source><institution-wrap><institution-id institution-id-type="FundRef">http://dx.doi.org/10.13039/501100000266</institution-id><institution>Engineering and Physical Sciences Research Council</institution></institution-wrap></funding-source><award-id>EP/P023991/1</award-id></award-group></funding-group><custom-meta-group><custom-meta><meta-name>issue-copyright-statement</meta-name><meta-value>&#x000a9; Springer Science+Business Media, LLC, part of Springer Nature 2025</meta-value></custom-meta></custom-meta-group></article-meta></front><body><sec id="Sec1"><title>Introduction</title><p id="Par2">Android applications (or apps for short) are one of the most widely used types of software&#x000a0;(Kemp <xref ref-type="bibr" rid="CR37">2022</xref>). They are designed for direct user interaction, with the main entry point for the software being its UI components. Due to the small size of Android devices (phones, smartwatches, and tablets) compared to traditional desktop devices, their hardware capabilities are naturally limited. These two factors result in non-functional properties being especially important to both users and developers. In fact, non-functional properties are so important to Android users that 1/3 of instances of users abandoning applications and 59% of bad reviews were due to poor performance&#x000a0;(Lim et&#x000a0;al. <xref ref-type="bibr" rid="CR46">2014</xref>; Inukollu et&#x000a0;al. <xref ref-type="bibr" rid="CR35">2014</xref>).</p><p id="Par3">Hort et&#x000a0;al. (<xref ref-type="bibr" rid="CR34">2022</xref>)&#x02019;s survey on Android performance optimizations lists several approaches for improving non-functional properties of Android apps. These include prefetching online resources to avoid having to wait for them when they are needed&#x000a0;(Mohan et&#x000a0;al. <xref ref-type="bibr" rid="CR57">2013</xref>; Baumann and Santini <xref ref-type="bibr" rid="CR13">2017</xref>) and offloading computation onto remote servers which are faster than the mobile device&#x000a0;(Saarinen et&#x000a0;al. <xref ref-type="bibr" rid="CR68">2012</xref>). Offloading, however, requires external server infrastructure to be set up and applications to be re-engineered to be utilised. Prefetching is only applicable to areas of applications that interact with the network. Other approaches&#x000a0;(Hort et&#x000a0;al. <xref ref-type="bibr" rid="CR34">2022</xref>) include anti-pattern detection, which requires manual implementation, and refactorings, which are limited to specific code fragments. We argue that an approach that does not require external resources and is more easily applicable to all applications regardless of type and structure would make developers more likely to adopt it.</p><p id="Par4">Whilst existing approaches for automated improvement of Android apps are capable of improving multiple properties simultaneously, e.g., by removing unnecessary computation reducing runtime and energy use, in most cases such correlations have not been considered&#x000a0;(Hort et&#x000a0;al. <xref ref-type="bibr" rid="CR34">2022</xref>). Moreover, single-objective improvements can have negative effects on other properties. For example, during prefetching, the resource which is prefetched must be stored, which might result in higher memory use. To get the full picture of how an application is affected by an improvement, properties other than those that are direct targets for improvement should be considered. Hort et&#x000a0;al. (<xref ref-type="bibr" rid="CR34">2022</xref>) reveals only one work that applies multi-objective optimization to non-functional properties of Android apps. Morales et&#x000a0;al. (<xref ref-type="bibr" rid="CR58">2018</xref>) consider energy consumption and the number of anti-patterns. Although the authors release their framework, it is not open-source and requires external hardware for energy measurements.</p><p id="Par5">Rather than targeting specific features or resources, we aim to find source code transformations. There have been a few attempts to find Android app performance optimizations with source code transformations so far. Lin et al. proposed two approaches, Asynchronizer&#x000a0;(Lin et&#x000a0;al. <xref ref-type="bibr" rid="CR47">2014</xref>) and AsyncDroid&#x000a0;(Lin et&#x000a0;al. <xref ref-type="bibr" rid="CR48">2015</xref>), for refactoring code to be executed asynchronously. However, both of these approaches require developers to identify the particular lines of code which they want to execute asynchronously and there has been no work to show the actual impact of these refactorings on performance. Lyu et&#x000a0;al. (<xref ref-type="bibr" rid="CR50">2018</xref>) propose an approach that moves costly database operations out of loops. Whilst this approach can improve performance, it is only applicable to methods that access databases inside loops.</p><p id="Par6">The only tools for Android app performance improvement, which are both available and generally applicable to Android source code, are linters&#x000a0;(Habchi et&#x000a0;al. <xref ref-type="bibr" rid="CR32">2018</xref>). Linters contain rules which aim to identify areas of code that may cause performance issues, leaving to app developers the decisions to implement suggested changes. However, their use comes with challenges&#x000a0;(Habchi et&#x000a0;al. <xref ref-type="bibr" rid="CR32">2018</xref>), including dealing with false positives.</p><p id="Par7">In order to find patches to source code, we propose to use Genetic Improvement. GI is a search-based technique that uses meta-heuristics to perform a guided search over software patches, to find those that improve a given software property. GI makes changes to source code and thus can be applied to a wide range of software types. GI has been used to improve many different properties of software, including runtime&#x000a0;(Langdon et&#x000a0;al. <xref ref-type="bibr" rid="CR42">2015</xref>; Petke et&#x000a0;al. <xref ref-type="bibr" rid="CR63">2013</xref>), memory&#x000a0;(Basios et&#x000a0;al. <xref ref-type="bibr" rid="CR12">2017</xref>; Wu et&#x000a0;al. <xref ref-type="bibr" rid="CR74">2015</xref>), and energy consumption&#x000a0;(Bruce et&#x000a0;al. <xref ref-type="bibr" rid="CR18">2015</xref>; Burles et&#x000a0;al. <xref ref-type="bibr" rid="CR19">2015</xref>).</p><p id="Par8">Extending GI to improve multiple properties can be accomplished by swapping out these single-objective algorithms with multi-objective ones. This allows us to consider patches that find trade-offs between various properties, rather than just those which improve one, without consideration of the impact on others. We can thus provide a choice to developers between different versions of source code, showing different trade-offs. Nevertheless, only a few works explore the potential of multi-objective GI and only in the desktop domain&#x000a0;(Mesecan et&#x000a0;al. <xref ref-type="bibr" rid="CR55">2022</xref>; Wu et&#x000a0;al. <xref ref-type="bibr" rid="CR74">2015</xref>).</p><p id="Par9">GI has been applied to Android applications a handful of times. Callan and Petke attempted to improve the frame rate of Android apps with GI, however, were unsuccessful&#x000a0;(Callan and Petke <xref ref-type="bibr" rid="CR20">2021</xref>). In another work, Callan and Petke (<xref ref-type="bibr" rid="CR21">2022a</xref>) were able to find improvements to the navigation responsiveness of Android apps. Bokhari et&#x000a0;al. (<xref ref-type="bibr" rid="CR16">2017</xref>) improved the energy consumption of Android apps, with a type of GI known as deep parameter optimization. To the best of our knowledge, no GI work so far has attempted to improve and find trade-offs between multiple properties of Android apps, and no approach has attempted to improve either the memory consumption or bandwidth usage of Android apps, which we target in this work.</p><p id="Par10">Previous work on applying GI in the Android domain revealed several practical challenges: (1) due to the complexity of the Android build system and significant use of UI elements, a minor change usually requires a time&#x02013;costly process of installation on the actual device for testing (2) tests themselves are scarce, and (3) performance fitness measurements used in the desktop domain are not accurate enough to witness performance issues in Android apps, yet users deem wait time of just 150 ms as &#x02018;laggy&#x02019;&#x000a0;(Tolia et&#x000a0;al. <xref ref-type="bibr" rid="CR71">2006</xref>). We overcome these challenges. We utilise the Robolectric testing library&#x000a0;(Robolectric Develop. Team <xref ref-type="bibr" rid="CR67">2023</xref>) which mimics UI behaviour, allowing for quick unit testing, without need for installation on an actual mobile or tablet device. This addresses challenge (1) of having to conduct constly runs on actual devices during GI. This simulation-based approach provides us with means of utilising performance measurement tools unavailable on Android devices, addressing challenge (3). When using GI, we validate the patches that we generate using the program&#x02019;s test suite and validate the best-improving final patches manually. This ensures that our patches do not disrupt the functionality of the program. However, most open-source Android applications do not have test suites (challenge (2)), and those that do are limited, achieving a median line coverage of 23%&#x000a0;(Pecorelli et&#x000a0;al. <xref ref-type="bibr" rid="CR62">2020</xref>). This meant that we had to create tests for all the benchmarks on which we ran GI.<xref ref-type="fn" rid="Fn1">1</xref></p><p id="Par12">In order to validate our proposed approach, we created a tool, GIDroid (<xref ref-type="bibr" rid="CR31">2023</xref>), for running multi-objective (MO) GI on Android applications. We provide three fitness functions, to improve runtime, memory, and bandwidth use. GIDroid&#x000a0;contains three MO algorithms (NSGA-II&#x000a0;(Deb et&#x000a0;al. <xref ref-type="bibr" rid="CR28">2000</xref>), NSGA-III&#x000a0;(Deb and Jain <xref ref-type="bibr" rid="CR27">2014</xref>), and SPEA2&#x000a0;(Kim et&#x000a0;al. <xref ref-type="bibr" rid="CR41">2004</xref>)). Based on work by Callan et&#x000a0;al. (<xref ref-type="bibr" rid="CR23">2022</xref>), who mined non-functional improvements made by Android developers, we implement in GIDroid&#x000a0;two novel mutation operators, specifically designed to mimic human-made edits. These cache results of repeated calls, aiming to save memory use.</p><p id="Par13">We selected Android apps that contain real-world non-functional-property-improving commits, in order to see if GIDroid&#x000a0;can re-discover changes made by Android developers. Moreover, we use the latest versions of these applications, to see if we can find as-yet-undiscovered improvements. Overall, we created a benchmark of 21 versions of 7 Android apps, which we open source for future work.</p><p id="Par14">GIDroid&#x000a0;was able to find patches that improve execution time by up to 35%, and memory usage by up to 65%. Unfortunately, no improvements to bandwidth use were found. Such improvements are within GIDroid&#x02019;s search space, which leaves room for future work for more effective search strategies.</p><p id="Par15">To sum up, we present the following novel contributions: <list list-type="order"><list-item><p id="Par16">An open-source, simulation-based tool, GIDroid&#x000a0;(GIDroid <xref ref-type="bibr" rid="CR31">2023</xref>), for automated multi-objective improvement of Android applications&#x02019; runtime, memory, and bandwidth use.</p></list-item><list-item><p id="Par17">A benchmark of 21 versions of 7 Android applications, including tests, for future work on performance improvement in the Android domain.</p></list-item><list-item><p id="Par18">An evaluation of the effectiveness of 3 multi-objective Genetic Improvement algorithms at improving runtime, memory use, and bandwidth of Android applications. No GI work has targeted 3 properties before.</p></list-item><list-item><p id="Par19">A comparison between both multi- and single-objective Genetic Improvement approaches for automated optimization of Android applications.</p></list-item><list-item><p id="Par20">An empirical comparison of our multi-objective GI-based approach for Android application performance improvement with state-of-the-art linters.</p></list-item></list>The rest of this paper is structured as follows: Sect.&#x000a0;<xref rid="Sec2" ref-type="sec">2</xref> describes related work; Sect.&#x000a0;<xref rid="Sec3" ref-type="sec">3</xref> presents an introduction to Genetic Improvement and multi-objective optimization; Sect.&#x000a0;<xref rid="Sec6" ref-type="sec">4</xref> presents challenges of applying GI to the Android domain and our proposed framework that overcomes these challenges; Sect.&#x000a0;<xref rid="Sec11" ref-type="sec">5</xref> presents research questions we aim to answer to evaluate our approach, with Sect.&#x000a0;<xref rid="Sec12" ref-type="sec">6</xref> outlining our methodology; Sect.&#x000a0;<xref rid="Sec16" ref-type="sec">7</xref> presents our results, with threats to validity presented in Sect.&#x000a0;<xref rid="Sec30" ref-type="sec">8</xref>; Sect.&#x000a0;<xref rid="Sec31" ref-type="sec">9</xref> concluding.</p></sec><sec id="Sec2"><title>Android app performance optimization</title><p id="Par21">A number of approaches have been proposed for improving the performance of Android applications. Hort et&#x000a0;al. (<xref ref-type="bibr" rid="CR34">2022</xref>)&#x02019;s survey on this topic presents the following code-level approaches:</p><p id="Par22"><bold>Prefetching:</bold> Network resources are fetched before they are needed by the application and stored locally&#x000a0;(Mohan et&#x000a0;al. <xref ref-type="bibr" rid="CR57">2013</xref>; Baumann and Santini <xref ref-type="bibr" rid="CR13">2017</xref>). When the application needs said resources, it can get them without having to wait for a lengthy network transaction, making the application more responsive. Prefetching can lead to increased memory and storage usage, and lead to the app not having the most up-to-date version of a particular resource. Prefetching can only optimize parts of applications that utilise network resources.</p><p id="Par23"><bold>Anti-patterns:</bold> Approaches that detect patterns in source code that indicate performance defects, for example, repeated expensive memory access operations inside for-loops&#x000a0;(Nistor et&#x000a0;al. <xref ref-type="bibr" rid="CR60">2013</xref>), or incorrect wake lock usage affecting energy use&#x000a0;(Cruz and Abreu <xref ref-type="bibr" rid="CR25">2017</xref>). The only tools which are both available and generally applicable to the source code of Android apps are linters&#x000a0;(Android Development Team <xref ref-type="bibr" rid="CR6">2023b</xref>), PMD&#x000a0;(PMD Development Team <xref ref-type="bibr" rid="CR65">2023</xref>), and FindBugs&#x000a0;(FindBugs Development Team <xref ref-type="bibr" rid="CR30">2015</xref>). These tools have performance rules which aim to identify areas of code that may cause performance issues. However, often these warnings are false-positives&#x000a0;(Habchi et&#x000a0;al. <xref ref-type="bibr" rid="CR32">2018</xref>). The developer must then manually fix the issues. Existing Android linters do not provide any information on the impact of fixing the issues they detect.</p><p id="Par24"><bold>Refactoring:</bold> Refactoring approaches aim to modify the source code of the application to be more performant. In Lin et&#x000a0;al. (<xref ref-type="bibr" rid="CR47">2014</xref>, <xref ref-type="bibr" rid="CR48">2015</xref>)&#x02019;s work applications were refactored to execute code asynchronously, making them execute more quickly. Ayala et&#x000a0;al. (<xref ref-type="bibr" rid="CR8">2019</xref>) investigated three asynchronous communications methods&#x02019; impact on mobile energy use. These approaches require developers to identify each line of code that they wish to execute asynchronously. Lyu et&#x000a0;al. (<xref ref-type="bibr" rid="CR50">2018</xref>) propose to move database operations out of loops. However, this is only applicable to limited areas of code that contain such database calls.</p><p id="Par25"><bold>Offloading:</bold> This approach aims to perform the most costly computation on external servers, rather than Android devices&#x000a0;(Das et&#x000a0;al. <xref ref-type="bibr" rid="CR26">2016</xref>; Chun et&#x000a0;al. <xref ref-type="bibr" rid="CR24">2011</xref>; Ding et&#x000a0;al. <xref ref-type="bibr" rid="CR29">2013</xref>; Berg et&#x000a0;al. <xref ref-type="bibr" rid="CR14">2014</xref>; Saarinen et&#x000a0;al. <xref ref-type="bibr" rid="CR68">2012</xref>). This has the benefit of reducing the amount of energy used by the application, extending the device&#x02019;s battery life, and speeding up the computation to make the app more responsive. Offloading requires external hardware to function, which may not always be suitable.</p><p id="Par26"><bold>Programming Languages:</bold> In the Android environment, a number of different programming languages are available to developers. The majority of Android apps are written in either Java or Kotlin, which usually compile to JVM bytecode. This bytecode is then (optionally) obfuscated and recompiled into dex code. This allows Java and Kotlin APIs to be used across both languages interchangeably and some applications even use a mixture of both languages. There is little performance difference between the two languages&#x000a0;(Mateus et&#x000a0;al. <xref ref-type="bibr" rid="CR54">2021</xref>). C/C++ can also be used to write native code. Such code is generally faster than the Java/Kotlin code and thus can be used to find performance improvements. However, changing a programming language can be time-consuming, with no upfront knowledge of the magnitude of possible performance gains.</p><p id="Par27">The above works have all proved useful, but they either do not perform fully automatic improvement&#x000a0;(Lin et&#x000a0;al. <xref ref-type="bibr" rid="CR47">2014</xref>, <xref ref-type="bibr" rid="CR48">2015</xref>; Habchi et&#x000a0;al. <xref ref-type="bibr" rid="CR32">2018</xref>; FindBugs Development Team <xref ref-type="bibr" rid="CR30">2015</xref>; Android Development Team <xref ref-type="bibr" rid="CR6">2023b</xref>), are only applicable to specific areas of code&#x000a0;(Lyu et&#x000a0;al. <xref ref-type="bibr" rid="CR50">2018</xref>; Mohan et&#x000a0;al. <xref ref-type="bibr" rid="CR57">2013</xref>; Baumann and Santini <xref ref-type="bibr" rid="CR13">2017</xref>), or require external infrastructure&#x000a0;(Das et&#x000a0;al. <xref ref-type="bibr" rid="CR26">2016</xref>; Chun et&#x000a0;al. <xref ref-type="bibr" rid="CR24">2011</xref>; Ding et&#x000a0;al. <xref ref-type="bibr" rid="CR29">2013</xref>; Berg et&#x000a0;al. <xref ref-type="bibr" rid="CR14">2014</xref>; Saarinen et&#x000a0;al. <xref ref-type="bibr" rid="CR68">2012</xref>).</p><p id="Par28">Given the shortcomings of the above-mentioned approaches, we propose to use multi-objective GI to improve several software properties in the Android domain. By using GI, we will be able to apply our approach to any source code and will not be limited to only improving code using certain patterns. GI is fully automated. Developers will only have to review the patches produced by GI once the process is finished to ensure that they do not have unintended side effects. Such patches would thus undergo a standard code review process. Furthermore, GI does not require the setup of any external infrastructure to achieve optimisations and can be performed in the local development environment of the application developer. We illustrate this in Table&#x000a0;<xref rid="Tab1" ref-type="table">1</xref>. We aim to find multiple patches, which may find trade-offs between different properties that can allow developers to choose the best patches for their particular needs, and be fully aware of the consequences that a particular patch will have on other properties. We note that prefetching, offloading, and others are complementary to GI, and could still offer benefits to applications that have been optimized using GI.
<table-wrap id="Tab1"><label>Table 1</label><caption><p>Comparison of existing strategies for improvement of non-functional properties of Android apps with our tool&#x02014;GIDroid</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Work</th><th align="left">Properties</th><th align="left">Source</th><th align="left">Fully</th><th align="left">Trade-offs</th></tr><tr><th align="left"/><th align="left"/><th align="left">Code</th><th align="left">Automatic</th><th align="left">Considered</th></tr></thead><tbody><tr><td align="left">Prefetching</td><td align="left">Runtime</td><td align="left">x</td><td align="left"><inline-formula id="IEq1"><alternatives><tex-math id="d33e539">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\checkmark $$\end{document}</tex-math><mml:math id="d33e544"><mml:mo stretchy="false">&#x02713;</mml:mo></mml:math><inline-graphic xlink:href="10515_2024_472_Article_IEq1.gif"/></alternatives></inline-formula></td><td align="left">x</td></tr><tr><td align="left">Anti-patterns</td><td align="left">Runtime, memory, energy use</td><td align="left"><inline-formula id="IEq2"><alternatives><tex-math id="d33e557">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\checkmark $$\end{document}</tex-math><mml:math id="d33e562"><mml:mo stretchy="false">&#x02713;</mml:mo></mml:math><inline-graphic xlink:href="10515_2024_472_Article_IEq2.gif"/></alternatives></inline-formula></td><td align="left">x</td><td align="left">x</td></tr><tr><td align="left">Refactoring-asynchronous</td><td align="left">Runtime, energy use</td><td align="left"><inline-formula id="IEq3"><alternatives><tex-math id="d33e577">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\checkmark $$\end{document}</tex-math><mml:math id="d33e582"><mml:mo stretchy="false">&#x02713;</mml:mo></mml:math><inline-graphic xlink:href="10515_2024_472_Article_IEq3.gif"/></alternatives></inline-formula></td><td align="left">x</td><td align="left">x</td></tr><tr><td align="left">Refactoring-database loops</td><td align="left">Runtime</td><td align="left"><inline-formula id="IEq4"><alternatives><tex-math id="d33e597">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\checkmark $$\end{document}</tex-math><mml:math id="d33e602"><mml:mo stretchy="false">&#x02713;</mml:mo></mml:math><inline-graphic xlink:href="10515_2024_472_Article_IEq4.gif"/></alternatives></inline-formula></td><td align="left"><inline-formula id="IEq5"><alternatives><tex-math id="d33e608">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\checkmark $$\end{document}</tex-math><mml:math id="d33e613"><mml:mo stretchy="false">&#x02713;</mml:mo></mml:math><inline-graphic xlink:href="10515_2024_472_Article_IEq5.gif"/></alternatives></inline-formula></td><td align="left">x</td></tr><tr><td align="left">Offloading</td><td align="left">Runtime, energy use</td><td align="left">x</td><td align="left"><inline-formula id="IEq6"><alternatives><tex-math id="d33e628">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\checkmark $$\end{document}</tex-math><mml:math id="d33e633"><mml:mo stretchy="false">&#x02713;</mml:mo></mml:math><inline-graphic xlink:href="10515_2024_472_Article_IEq6.gif"/></alternatives></inline-formula></td><td align="left">x</td></tr><tr><td align="left"><bold>GIDroid</bold></td><td align="left">Runtime, memory, bandwidth</td><td align="left"><inline-formula id="IEq7"><alternatives><tex-math id="d33e648">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\checkmark $$\end{document}</tex-math><mml:math id="d33e653"><mml:mo stretchy="false">&#x02713;</mml:mo></mml:math><inline-graphic xlink:href="10515_2024_472_Article_IEq7.gif"/></alternatives></inline-formula></td><td align="left"><inline-formula id="IEq8"><alternatives><tex-math id="d33e659">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\checkmark $$\end{document}</tex-math><mml:math id="d33e664"><mml:mo stretchy="false">&#x02713;</mml:mo></mml:math><inline-graphic xlink:href="10515_2024_472_Article_IEq8.gif"/></alternatives></inline-formula></td><td align="left"><inline-formula id="IEq9"><alternatives><tex-math id="d33e670">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\checkmark $$\end{document}</tex-math><mml:math id="d33e675"><mml:mo stretchy="false">&#x02713;</mml:mo></mml:math><inline-graphic xlink:href="10515_2024_472_Article_IEq9.gif"/></alternatives></inline-formula></td></tr></tbody></table><table-wrap-foot><p>Bold font indicates our approach, different to previous work</p></table-wrap-foot></table-wrap></p></sec><sec id="Sec3"><title>Background</title><p id="Par29">Before we outline our proposed framework for automatic performance improvement of Android applications, we first provide a short introduction to Genetic Improvement (GI) and Multi-Objective (MO) optimization.</p><sec id="Sec4"><title>Genetic improvement</title><p id="Par30">Genetic Improvement (GI)&#x000a0;(Petke et&#x000a0;al. <xref ref-type="bibr" rid="CR64">2018</xref>) is a search-based software engineering technique that utilises search to iterate over different versions of software in order to find improved program variants. These improvements can be bug repairs or improvements to non-functional properties like execution time or memory use. GI has already proven useful for improvement of traditional software, fixing bugs during the development of commercial software&#x000a0;(Haraldsson et&#x000a0;al. <xref ref-type="bibr" rid="CR33">2017</xref>), improving the execution time of large bioinformatics software&#x000a0;(Langdon et&#x000a0;al. <xref ref-type="bibr" rid="CR42">2015</xref>), improving compiler optimizations&#x000a0;(Li et&#x000a0;al. <xref ref-type="bibr" rid="CR44">2022</xref>), and more&#x000a0;(Petke et&#x000a0;al. <xref ref-type="bibr" rid="CR64">2018</xref>).</p><p id="Par31">Each program in GI is represented as a patch to existing software. Patches are constructed from a set of edits to code, i.e., mutations, which describe modifications to the program being improved. The most common mutation operators used in previous work have been: <sc>delete</sc>, <sc>copy</sc>, and <sc>replace</sc>. These operations can be applied at the level of lines of source code, bytecode, or other. The vast majority of GI work operates at statement-level, applying mutation operators to nodes of an abstract syntax tree&#x000a0;(AST).</p><p id="Par32">Each GI patch is applied to the original software for evaluation, measured using a fitness function. In the case of program repair, this fitness can be the number of passing tests, and for execution time improvement it could be the time taken by the tests. This fitness measurement is used to guide search through the landscape of patches to find improved software variants. Traditionally, genetic programming has been used for this purpose, though other search techniques, such as local search, have also proven effective&#x000a0;(Blot and Petke <xref ref-type="bibr" rid="CR15">2021</xref>).</p><p id="Par33">Although there is a lot of literature on the improvement of traditional software using GI, little is known about how the technique would fare in the mobile domain. Initial approaches have shown mixed results, with none trying to optimize multiple properties. Bokhari et&#x000a0;al. (<xref ref-type="bibr" rid="CR16">2017</xref>) were able to reduce the energy consumption of Android apps, using deep parameter optimization, i.e., mutating parameters within source code, not exposed to the user. Callan and Petke (<xref ref-type="bibr" rid="CR21">2022a</xref>) were able to reduce the time taken to move between Activities, the main UI components, of Android apps. However, when attempting to improve the frame rate of Android apps, Callan and Petke did not find improving patches&#x000a0;(Callan and Petke <xref ref-type="bibr" rid="CR20">2021</xref>).</p></sec><sec id="Sec5"><title>Multi-objective optimization</title><p id="Par34">Performance properties such as runtime and memory consumption often are at odds with each other, i.e., one can improve runtime by caching results, thus increasing memory use, and vice versa. In order to improve such conflicting properties, multi-objective (MO) algorithms have been proposed&#x000a0;(Srinivas and Deb <xref ref-type="bibr" rid="CR69">1994</xref>), which produce a Pareto front of non-dominated solutions. A solution <italic>x</italic> Pareto dominates another <italic>y</italic> if all of <italic>x</italic>&#x02019;s objectives are as good as <italic>y</italic>&#x02019;s and at least one objective is better than <italic>y</italic>&#x02019;s.</p><p id="Par35">Past work utilising MO algorithms for GI is sparse, with the majority of work focusing on single-objective improvement. However, in the work where MO improvement has been successful Genetic Algorithm (GA) based algorithms have been used. Wu et&#x000a0;al. (<xref ref-type="bibr" rid="CR74">2015</xref>) and Callan and Petke (<xref ref-type="bibr" rid="CR22">2022b</xref>) used NSGA-II&#x000a0;(Deb et&#x000a0;al. <xref ref-type="bibr" rid="CR28">2000</xref>), White et&#x000a0;al. (<xref ref-type="bibr" rid="CR73">2011</xref>) used SPEA2&#x000a0;(Kim et&#x000a0;al. <xref ref-type="bibr" rid="CR41">2004</xref>), with Mesecan et&#x000a0;al. (<xref ref-type="bibr" rid="CR55">2022</xref>) comparing four MO algorithms, with SPEA2 and NSGA-III&#x000a0;(Deb and Jain <xref ref-type="bibr" rid="CR27">2014</xref>) performing best.</p><p id="Par36">In each algorithm, a population of solutions (in our case program variants) is generated and their fitnesses are measured. In order to generate new patches, mutation, and crossover operators are used to generate child populations and then individuals are selected for the next generation from both child and parent populations.</p><p id="Par37">The algorithms vary in their selection phases. The algorithms use Pareto dominance to compare different individuals who may find trade-offs between different properties.</p><p id="Par38">Both NSGA-II and NSGA-III sort the population into Pareto fronts based on their fitnesses. The population of the next generation is then selected from the top fronts, one at a time, until a set number of individuals are chosen. If a front needs to be split, as it is too big for the population size, it is sorted by a crowding metric, and the least crowded members are selected. In NSGA-II, crowding is based on distance from other individuals in the fitness landscape. Whereas in NSGA-III, crowding is based on reference lines and the number of individuals that are closest to them, or niched to them. NSGA-III selects individuals spread across as many niches as possible in the final front to maintain diversity.</p><p id="Par39">Unlike the NSGA algorithms, SPEA2 does not separate the population into Pareto fronts. Instead, the strength of each individual is calculated. This is equal to the number of other individuals that the individual Pareto dominates. The raw fitness of an individual is then calculated as the sum of the strengths of all other individuals which it dominates. Like the NSGA algorithms crowding metric is calculated. For this, all other individuals are sorted into a list based on proximity to the individual of interest. The metric is inversely proportional to the distance of the <italic>kth</italic> individual in the list. The parameter <italic>k</italic> is equal to the square root of the total population size. Finally, the raw fitness and the crowding metric are simply added together and used to select individuals.</p><p id="Par40">It is yet unclear which multi-objective approach works best for the purpose of Genetic Improvement, thus we explore the capabilities of these three algorithms shown successful in previous work.</p></sec></sec><sec id="Sec6"><title>Multi-objective GI for android</title><p id="Par41">There are a number of practical changes when using Genetic Improvement to enhance the performance of Android apps when compared to traditional desktop environments.</p><p id="Par42">Android applications make use of APIs for features like UI elements which are only present on actual devices. The Android library available when testing applications on desktop operating systems overwrites the APIs such that they throw errors when invoked. Most Android code utilises the Context class&#x000a0;(Android Development Team <xref ref-type="bibr" rid="CR3">2022a</xref>), in the applications we use in our experiments, the context class is explicitly imported in over 1/3 of files. This does not include the instances where it is implicitly imported as a nested dependency. This class gives the code access to the shared state of the application but is only available on devices. This means that in order to run tests that exercise any component of an application&#x02019;s code that accesses this state, the entire application must be compiled, packaged, transpiled, installed, and launched before it can be tested. This can take a considerable amount of time, often longer than the tests themselves&#x000a0;(Callan and Petke <xref ref-type="bibr" rid="CR20">2021</xref>).</p><p id="Par43">Android apps are generally built using Gradle with the Android Gradle plugin. This makes them incompatible with much of the tooling surrounding automatic compilation and testing of code&#x000a0;(Android Development Team <xref ref-type="bibr" rid="CR4">2022b</xref>, <xref ref-type="bibr" rid="CR5">2023a</xref>).</p><p id="Par44">Another challenge of applying GI to the mobile domain is the accurate measurement of the fitness function. Previous work has only applied GI to problems that take seconds/minutes to run. In the mobile domain, it was shown that app functionalities or UI interatcions that take more than 150 ms are considered to be &#x02018;laggy&#x02019; by users&#x000a0;(Tolia et&#x000a0;al. <xref ref-type="bibr" rid="CR71">2006</xref>). Therefore, although previous work used approximate fitness measurements, these are not appropriate in the mobile domain as they may not capture such minor, yet important, differences in non-functional behaviour.<fig id="Fig1"><label>Fig. 1</label><caption><p>GI framework for Android app improvement, with search based on a genetic algorithm. In the case of local search, only mutation is applied</p></caption><graphic xlink:href="10515_2024_472_Fig1_HTML" id="MO1"/></fig></p><p id="Par45">In order to overcome the aforementioned challenges, we propose the GI framework shown in Fig.&#x000a0;<xref rid="Fig1" ref-type="fig">1</xref>. The framework is split into two main components: the Search, and the Fitness sections. These components can be swapped out depending on the properties being improved.</p><sec id="Sec7"><title>Representation</title><p id="Par46">We use a program representation consisting of a list of edits, which are applied sequentially to the source code. This representation has been used in GI many times in the past and proven successful&#x000a0;(Petke et&#x000a0;al. <xref ref-type="bibr" rid="CR64">2018</xref>). We use a list of edits, rather than representing the whole program in the genome, as may be done in traditional genetic programming, to reduce the memory footprint of the search process. An example of this representation, as used in GIDroid, is shown in Listing&#x000a0;1. <graphic position="anchor" xlink:href="10515_2024_472_Figa_HTML" id="MO2"/></p></sec><sec id="Sec8"><title>Fitness</title><p id="Par47">In the Fitness section in our framework (see Fig.&#x000a0;<xref rid="Fig1" ref-type="fig">1</xref>), we measure the properties that we are improving. As in previous GI work, we patch the application, compile it and run unit tests on it. If all unit tests pass, the patch is considered valid, if not, it is discarded. Then, the property being improved is measured. For example, if we are improving execution time, the time taken by the test suite is measured. Multiple different properties are measured in the case of MO improvement.</p><p id="Par48">Due to the complexity of the Android build system and significant use of UI elements, a minor change usually requires a time&#x02013;costly process of installation on the actual device for testing. Our framework thus utilises only the local tests which run on the JVM. This would normally limit the components that could be tested to only those which do not use the device-only APIs. If we attempt to use these APIs in a local test, we will simply call stubbed versions of the methods which throw exceptions. However, by using the simulation-based Robolectric testing library, we are able to test any application component with fast local tests. Robolectric has two main features that allow us to test apps. Firstly, the simulation of the application and Android environment, which creates a headless version of the application within a local JVM. Secondly, shadowing which allows the bytecode of classes to be overwritten at runtime. This is used to overwrite the API calls with simulated API calls and allows the simulated app to be exercised. Shadowing is useful for mocking hard dependencies and can be used to avoid the complex setup needed when testing certain components. Using this simulation-based approach, we can quickly compile and test application variants, and use measurement tools that aren&#x02019;t available in the Android operating system. Callan and Petke (<xref ref-type="bibr" rid="CR21">2022a</xref>) found that improvements that could be demonstrated with unit tests written in the Robolectric library translated to improvements on Android applications run on real devices, in every case where improvements were found. Thus, with a combination of Robolectric testing and manual review of improvements, we can be confident whether we have found an actual improvement or not. We use the Gradle build system with the Android plugin to compile and test applications.</p><p id="Par49">Khalid et&#x000a0;al. (<xref ref-type="bibr" rid="CR40">2015</xref>) identified execution time, memory, bandwidth, and energy usage as the most complained about and impactful non-functional properties of Android apps. In this work, we will attempt to improve execution time, memory, and bandwidth. Previous work on automatically improving energy usage of Android apps&#x000a0;(Bokhari et&#x000a0;al. <xref ref-type="bibr" rid="CR16">2017</xref>; Morales et&#x000a0;al. <xref ref-type="bibr" rid="CR58">2018</xref>) found energy estimates to be too noisy, thus requiring external devices for physical energy measurements. Although GI can be used to optimize energy consumption&#x000a0;(Bokhari et&#x000a0;al. <xref ref-type="bibr" rid="CR16">2017</xref>), we want to provide a general, easy-to-use tool that does not require extra hardware. It is worth mentioning that thus far the primary technique for improving bandwidth has been prefetching&#x000a0;(Mohan et&#x000a0;al. <xref ref-type="bibr" rid="CR57">2013</xref>). No previous attempts have been made to improve it using source-code transformations, despite such changes being made by developers&#x000a0;(Callan et&#x000a0;al. <xref ref-type="bibr" rid="CR23">2022</xref>).</p></sec><sec id="Sec9"><title>Search</title><p id="Par50">The Search section of our framework for Android app improvement (see Fig.&#x000a0;<xref rid="Fig1" ref-type="fig">1</xref>) determines how the search space of patches is navigated. Most GI work so far has used single-objective algorithms, such as genetic programming and local search. Only a few consider more than one objective. We pose that consideration of multiple objectives in the mobile domain is especially important, due to limited resources. To fill this gap, we propose to utilise multi-objective approaches in the search process. Multi-objective algorithms will allow us to evolve patches that will balance different trade-offs, producing Pareto fronts of solutions. The user will then be left with a choice of which patch fulfills their particular needs. The multi-objective approach will provide relevant information on how runtime reductions might for impact memory use etc.</p><p id="Par51">To start our search we need to generate an initial set of patches. Our patch representation is not of fixed size and may contain any number of edits. We create an initial population containing individuals consisting of single random edits. Further creation is guided by a given search algorithm, where mutations and crossover are applied to create new patches.</p><sec id="Sec10"><title>Mutation and crossover</title><p id="Par52">Patches are created via mutation and crossover on the list of edits representation. In the single-objective search used in GI so far crossover typically appends the lists of edits together from patches selected using binary tournament selection. We apply this type of crossover in our MO algorithms as well. A mutation simply adds or deletes an edit. In our case we operate on the statement-level, thus each mutation can delete, insert, or replace another statement. Additionally, we investigated which other mutation operators might be beneficial in the Android domain.</p><p id="Par53">Callan et&#x000a0;al. (<xref ref-type="bibr" rid="CR23">2022</xref>).&#x02019;s work showed that one of the most common techniques for improving non-functional properties of Android apps is caching. Caching was found to be effective across all properties studied (execution time, memory consumption, bandwidth use, and frame rate) and improved a number of different applications in different domains. Outside of the changes already implemented by standard GI mutation operators (remove code, change order of operations), caching is the most generically applicable strategy found, and thus, the most suitable for multi-objective improvement. Based on manual analysis of the commits from Callan et al.&#x02019;s work, in which caching is used, we propose two new mutation operators. Caching could prove useful for the three properties which we wish to improve. Firstly, if we no longer need to execute a method as we already have the result we will save time. If the method has a larger memory footprint than the stored result, we will reduce the memory footprint of the app. Finally, if the cached method accesses the network, we will be able to avoid this operation and reduce network usage. However, caching may negatively impact memory usage if the stored result is large. This will mean that we will have to consider possible tensions between objectives when we run our search.</p><p id="Par54">First, we propose a simple <bold>In-Method Caching Operator</bold>. This operator simply stores the result of calling a method in a local variable and replaces future calls to this method with the local variable (see Algorithm&#x000a0;1). An example of this operator can be seen in Fig.&#x000a0;<xref rid="Fig2" ref-type="fig">2</xref>. The second caching operator creates new fields in the associated class for storing cached method calls. This <bold>Class Caching Operator</bold> allows cached variables to persist beyond the end of individual method calls and could prove particularly useful if a method is called repeatedly. An example of this operator is shown in Fig.&#x000a0;<xref rid="Fig3" ref-type="fig">3</xref>. We wrap the statement which accesses the cached variable with a null guard so that the first time it is called we actually call the method. For both of these operators, we consider method call expressions to be cachable to the same variable only if their arguments consist of the same variables. As shown in Algorithm&#x000a0;2, the class caching operator can be applied to any method call expression. However, as local variables do not persist after a method is executed, there must be at least two instances of the expression for it to be cached. These operators will not disrupt the source code syntax as they simply replace a method call expression with a variable name expression which is the same type as the method&#x02019;s return type.</p><p id="Par55">
<fig position="anchor" id="Figb"><label>Algorithm 1</label><caption><p>Find method calls to cache in Method M</p></caption><graphic position="anchor" xlink:href="10515_2024_472_Figb_HTML" id="MO3"/></fig>
<fig id="Fig2"><label>Fig. 2</label><caption><p>An example of the In-Method Cache Operator. The resultant code stores the results of a method call <italic>foo</italic>, with parameters <italic>a</italic>, <italic>b</italic> and <italic>c</italic>. This stored result can then be used later in the same method</p></caption><graphic xlink:href="10515_2024_472_Fig2_HTML" id="MO4"/></fig>
</p><p id="Par56">
<fig position="anchor" id="Figc"><label>Algorithm 2</label><caption><p>Find method calls to cache in Class C</p></caption><graphic position="anchor" xlink:href="10515_2024_472_Figc_HTML" id="MO5"/></fig>
<fig id="Fig3"><label>Fig. 3</label><caption><p>An example of the Class Cache Operator. The result of a method call is stored in a field of the class for later use in any method</p></caption><graphic xlink:href="10515_2024_472_Fig3_HTML" id="MO6"/></fig>
</p></sec></sec></sec><sec id="Sec11"><title>Research questions</title><p id="Par57">To evaluate how effective the multi-objective GI approach for improvement of Android apps&#x02019; runtime, memory, and bandwidth use is, we pose the following research questions:</p><p id="Par58">
<bold>RQ1: Can Multi-Objective Genetic Improvement (MO-GI) optimize Android apps in the same way as real developers?</bold>
</p><p id="Par59">In order to validate our approach, we want to see if MO-GI can reproduce real-world improvements that Android developers have manually implemented in the past.</p><p id="Par60">
<bold>RQ2: How effective is MO-GI at optimising Android apps without known improvements?</bold>
</p><p id="Par61">Answering this question will allow us to see how well our approach generalises. In particular, if it&#x02019;s able to find improvements in current code.</p><p id="Par62">
<bold>RQ3: Which MO algorithm is the most effective for MO-GI for Android?</bold>
</p><p id="Par63">There are a number of different MO algorithms available. We want to ensure that our approach utilises the most effective one, thus we investigate and compare a selection of MO algorithms successfully used in the GI domain in the past.</p><p id="Par64">
<bold>RQ4: How do the improvements found by MO-GI compare to those found by Single-Objective Genetic Improvement (SO-GI) for Android apps?</bold>
</p><p id="Par65">We wish to see if using MO algorithms limits GI&#x02019;s ability to improve apps, when compared to improving only a single objective. This is especially important in cases where one improvement can enhance two objectives (e.g., deletion can improve both runtime and memory use). We want to see if MO are still competitive in such cases.</p><p id="Par66">
<bold>RQ5: What is the runtime cost of MO-GI for Android?</bold>
</p><p id="Par67">Any improvements found by MO-GI must be considered against the cost of running it. The improvements found must justify this cost.</p><p id="Par68">
<bold>RQ6: How does GI compare with available state-of-the-art techniques for Android performance improvement via code modification?</bold>
</p><p id="Par69">We want to compare GIDroid&#x000a0;with state-of-the-art tools that are readily available to developers to see if our tool could offer an attractive alternative.</p></sec><sec id="Sec12"><title>Methodology</title><p id="Par70">In order to answer our research questions, we propose a series of experiments, running both multi- and single-objective GI on a benchmark of real-world Android applications.</p><p id="Par71">To answer <bold>RQ1</bold>, <bold>RQ3</bold>, and <bold>RQ5</bold>, we run GI with three multi-objective algorithms on a set of applications, in some of which we know potential improvements are present, in order to validate our approach. To answer <bold>RQ2</bold>, we use the same setup to improve the latest versions of applications, to see if our framework can find yet-undiscovered optimizations</p><p id="Par72">Next, to answer <bold>RQ4</bold>, we run GI with a single-objective hill climbing algorithm, to compare with a multi-objective approach. With this set of experiments, we can evaluate whether or not our multi-objective algorithms can find improvements that are as good as those found by single-objective search. This allows us to compare the trade-offs found by different search algorithms.</p><p id="Par73">Finally, to answer <bold>RQ6</bold>, we use an Android linter to identify performance issues within our benchmarks. Linters are the only tools available to Android developers which can identify issues with source code that may affect performance properties we target. By manually repairing these issues we can see how our tool compares in terms of both effort and effectiveness with respect to existing tools available to developers. Given the popularity of large language models (LLMs) to address a variety of software engineering tasks, we also ask ChatGPT<xref ref-type="fn" rid="Fn2">2</xref> to find improvements on our benchmark set with known improvements.</p><sec id="Sec13"><title>Genetic improvement framework</title><p id="Par75">We implement our multi-objective GI approach for Android in a tool called&#x000a0;GIDroid, and use it to answer our RQs. Although there are many existing GI frameworks, Zuo et&#x000a0;al. (<xref ref-type="bibr" rid="CR76">2022</xref>) found that PYGGI&#x000a0;(An et&#x000a0;al. <xref ref-type="bibr" rid="CR2">2019</xref>) and the Genetic Improvement In No time tool (Gin)&#x000a0;(Brownlee et&#x000a0;al. <xref ref-type="bibr" rid="CR17">2019</xref>) were the only GI tools that could be readily applied to new software, with more recent tool by Mesecan et&#x000a0;al. (<xref ref-type="bibr" rid="CR55">2022</xref>) not yet available. However, none of the aforementioned work can be run upon Android applications. Whilst Gin is compatible with most Java programs, and thus could potentially easiest to extend, it is not compatible with the Android compilation and testing environments.</p><p id="Par76">In GIDroid, we implement three MO algorithms: NSGA-II&#x000a0;(Deb et&#x000a0;al. <xref ref-type="bibr" rid="CR28">2000</xref>) as it is one of the most widely used multi-objective algorithms; NSGA-III&#x000a0;(Deb and Jain <xref ref-type="bibr" rid="CR27">2014</xref>), that was specifically developed for problems with 3 or more objectives in mind; and SPEA2&#x000a0;(Kim et&#x000a0;al. <xref ref-type="bibr" rid="CR41">2004</xref>), which has recently proven successful for MO-GI in the desktop domain&#x000a0;(Mesecan et&#x000a0;al. <xref ref-type="bibr" rid="CR55">2022</xref>). We use MO algorithms, as we believe that we will be able to find better improvements to some properties if we are able to sacrifice others. In particular, with our caching operators&#x02014;these operators are likely to negatively impact the memory consumption of the applications, however a small increase in memory consumption may be worth it if it can sufficiently improve another property. The parameters used in these implementations can be found in Table&#x000a0;<xref rid="Tab3" ref-type="table">3</xref>.</p><p id="Par77">To measure execution time we use Linux&#x02019;s time tool&#x000a0;(Kerrisk <xref ref-type="bibr" rid="CR38">2019</xref>), we measure memory usage with the Java class Runtime&#x02019;s memory allocation tracking&#x000a0;(Oracle Development Team <xref ref-type="bibr" rid="CR61">2020</xref>) and we use Linux&#x02019;s built-in process-level network traffic tracking&#x000a0;(Kerrisk <xref ref-type="bibr" rid="CR39">2022</xref>) to measure bandwidth.</p></sec><sec id="Sec14"><title>Benchmarks</title><p id="Par78">Genetic improvement requires a set of tests that cover the areas of code being improved, in order to validate that a non-functional property-improving patch does not negatively affect the app&#x02019;s functionality. Unfortunately, most open-source Android applications do not have test suites, and those that do are limited, achieving a median line coverage of 23%&#x000a0;(Pecorelli et&#x000a0;al. <xref ref-type="bibr" rid="CR62">2020</xref>). It is worth pointing out, however, that testing is simply good practice in software development. Therefore, our approach will be more easily applicable to projects following this practice. Furthermore, there is not a single tool that we have found in an extensive search of the literature which can automatically generate unit tests for Android applications. All automated testing tools for Android found&#x000a0;(Auer et&#x000a0;al. <xref ref-type="bibr" rid="CR7">2022</xref>; Amalfitano et&#x000a0;al. <xref ref-type="bibr" rid="CR1">2015</xref>; Azim and Neamtiu <xref ref-type="bibr" rid="CR9">2013</xref>; Baek and Bae <xref ref-type="bibr" rid="CR11">2016</xref>; Mahmood et&#x000a0;al. <xref ref-type="bibr" rid="CR52">2014</xref>; Mao et&#x000a0;al. <xref ref-type="bibr" rid="CR53">2016</xref>; Su et&#x000a0;al. <xref ref-type="bibr" rid="CR70">2017</xref>; Li et&#x000a0;al. <xref ref-type="bibr" rid="CR45">2017</xref>; Yasin et&#x000a0;al. <xref ref-type="bibr" rid="CR75">2021</xref>) focus on testing UI via input generation in order to induce crashes and only run on devices/emulators, so would not be compatible with our framework. Moreover, they do not generate assertions&#x02014;crucial for capturing correct app behaviour.</p><p id="Par79">This meant that we had to manually construct unit tests for every single benchmark. We first had to attempt to understand each application and the component being improved and then attempt to create thorough, high-quality tests for them. In many cases, we had to account for asynchronous code, which was scheduled by the target code, and ensure that it executed completely during test execution. In other instances, we had to hunt down various parts of the state of the application to ensure they were correct. For each test we created, we ensured that it covered the methods which we wished to improve. We also added assertions about the state of the components of the application that were modified during execution. We achieved at least 75% branch coverage for methods used in our study. We do, however, note that developers would find this process simpler, as they already have an understanding of the application. They would get many other benefits from writing tests&#x000a0;(Mockus et&#x000a0;al. <xref ref-type="bibr" rid="CR56">2009</xref>; Bach et&#x000a0;al. <xref ref-type="bibr" rid="CR10">2017</xref>) so the cost cannot be only placed upon the application of GI. Given the cost associated with manual testing, we set a threshold of 20 benchmarks for all our experiments.</p><p id="Par80">To validate our approach, we first run GIDroid&#x000a0;on applications with known performance issues. Callan et&#x000a0;al. (<xref ref-type="bibr" rid="CR23">2022</xref>) has recently conducted a study of the changes that Android developers make to improve app performance. They pose that some of those changes are within the GI search-space. For instance, moving an operation outside of a <sc>for</sc> loop, if only need to be executed once. While others are not yet achievable, e.g., requiring new code to be added that could not be achieved via mutation of the existing code base. We thus use Callan et&#x000a0;al. (<xref ref-type="bibr" rid="CR23">2022</xref>)&#x02019;s criteria to iteratively analyse the commits from their dataset that improve runtime, bandwidth, or memory use, until we reached our 20 benchmark target. In particular, we found 14 commits in previous work, spread over different versions of 7 applications. Since we also want to find improvements in current software, we stop our selection procedure here and use the current versions of the 7 apps, giving us a total of 21 benchmarks. These are presented in Table&#x000a0;<xref rid="Tab2" ref-type="table">2</xref>.<xref ref-type="fn" rid="Fn3">3</xref><table-wrap id="Tab2"><label>Table 2</label><caption><p>Benchmarks: details of Android apps used in our study</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Application version</th><th align="left">Acronym</th><th align="left">Commit</th><th align="left">Type</th><th align="left">LoC</th></tr></thead><tbody><tr><td align="left">PortAuthority 1</td><td align="left">PA1</td><td align="left">e0163e20d1a67c22c2f7ed0f0345206ce1a050f0</td><td align="left">Port Scanner</td><td align="left">4k</td></tr><tr><td align="left">PortAuthority 2</td><td align="left">PA2</td><td align="left">e37a1a522a15773710f051d9fff5c0ce68ade5cb</td><td align="left"/><td align="left">16k</td></tr><tr><td align="left">PortAuthority 3</td><td align="left">PA3</td><td align="left">3a1329297881aff069cdbc80c92de386ac952d77</td><td align="left"/><td align="left">5k</td></tr><tr><td align="left">PortAuthority 4</td><td align="left">PA4</td><td align="left">adc73aac9c7dba5c61e1e18a96dfe7dd9712d100</td><td align="left"/><td align="left">16k</td></tr><tr><td align="left">PortAuthority 5</td><td align="left">PA5</td><td align="left">3e6846b6a377c35780ddb49e21eeab5749381bf2</td><td align="left"/><td align="left">16k</td></tr><tr><td align="left">PortAuthority 6</td><td align="left">PA6</td><td align="left">a02a0170a38ec257e1f390388e4b5d1414b3cf36</td><td align="left"/><td align="left">16k</td></tr><tr><td align="left">PortAuthority Current</td><td align="left">PAN</td><td align="left">9dbc43ebe454195b1610eee9b7473a83d400d48b</td><td align="left"/><td align="left">6k</td></tr><tr><td align="left">Tower Collector 1</td><td align="left">TC1</td><td align="left">956ea2213c1f7f012d6ab1388536a0c6d5202bd9</td><td align="left">Location Collector</td><td align="left">27k</td></tr><tr><td align="left">Tower Collector 2</td><td align="left">TC2</td><td align="left">0632608d26667e3a1864bf436086cf9422a913cb</td><td align="left"/><td align="left">12k</td></tr><tr><td align="left">Tower Collector Current</td><td align="left">TCN</td><td align="left">b069a973031823339bf62a8330086b8e9a1cda6e</td><td align="left"/><td align="left"/></tr><tr><td align="left">Gadgetbridge 1</td><td align="left">GB1</td><td align="left">c75362c5ea489247cc00b473a0ef91dbb1cc1569</td><td align="left">SmartBand Software</td><td align="left">106k</td></tr><tr><td align="left">Gadgetbridge Current</td><td align="left">GBN</td><td align="left">305078f2535f5508c13b089bc68deeff7bf7b1cc</td><td align="left"/><td align="left"/></tr><tr><td align="left">Fosdem Companion 1</td><td align="left">FS1</td><td align="left">b79e29a67c29699b9b8d4ad9c09a3349ce32c59f</td><td align="left">Schedule Browser</td><td align="left">11k</td></tr><tr><td align="left">Fosdem Companion Curr.</td><td align="left">FSN</td><td align="left">4d6914e2765712f86af02fec0538121d7dda197c</td><td align="left"/><td align="left"/></tr><tr><td align="left">Fdroid 1</td><td align="left">FD1</td><td align="left">e44ca193dd0adcbc5e240410aec4c681f5053dae</td><td align="left">Repository System</td><td align="left">77k</td></tr><tr><td align="left">Fdroid 2</td><td align="left">FD2</td><td align="left">bf8aa30a576144524e83731a1bad20a1dab3f1bc</td><td align="left"/><td align="left">2k</td></tr><tr><td align="left">Fdroid Current</td><td align="left">FDN</td><td align="left">bc6fba88fada1dcb186a40d0aead430bcc0031f8</td><td align="left"/><td align="left"/></tr><tr><td align="left">Lightning Browser 1</td><td align="left">LB1</td><td align="left">460da386ec10cb82b97bd2def2724fe41f709a88</td><td align="left">Web Browser</td><td align="left">69k</td></tr><tr><td align="left">Lightning Browser Curr.</td><td align="left">LBN</td><td align="left">ca7da585bdfcfdd89f85bc2a03d6a62cec28220f</td><td align="left"/><td align="left">71k</td></tr><tr><td align="left">Frozen Bubble 1</td><td align="left">FB1</td><td align="left">e9f6a51be9f7c4ad9f11d8712b06cb906e9ddf28</td><td align="left">Game</td><td align="left">36k</td></tr><tr><td align="left">Frozen Bubble Current</td><td align="left">FBN</td><td align="left">c3ac715a03370389d0d649a0eb5b7b5b3005e8b8</td><td align="left"/><td align="left">40k</td></tr></tbody></table></table-wrap></p><p id="Par82">Once we had our set of versions of apps, we prepared them for GI. Firstly, we had to ensure the apps would build. Over time, a number of changes have been made to the Android build tools, making older versions of code incompatible with modern Android Studio. We require these build tools to function with Android Studio, so we can test and measure the test coverage of applications confirming that they can be safely improved. This meant that we had to update build scripts with newer versions of libraries and build tools. In some cases, there were bugs such as unescaped apostrophes in resource files, which prevented applications from building. These bugs were fixed. In a few cases, the benchmarks also used outdated non-Gradle build systems, so we wrote the necessary build scripts, and modified the project&#x02019;s directory structure, to be compatible with Gradle and thus with GIDroid. No source code was modified in this process.</p><p id="Par83">We ran the PMD static analyser on the 7 applications and ran GIDroid&#x000a0;on the classes which showed the most performance issues. This way we could see how our approach compares against human effort for finding performance-improving code transformations of existing code bases, for the 14 previously patched app variants. We could also see whether our approach is able to find yet unknown performance improvements in the current versions of the 7 apps.</p></sec><sec id="Sec15"><title>Experimental setup</title><p id="Par84">
<table-wrap id="Tab3"><label>Table 3</label><caption><p>Parameter settings for the MO algorithms used in our study</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Parameter</th><th align="left">Value</th></tr></thead><tbody><tr><td align="left">Mutation rate</td><td align="left">0.5</td></tr><tr><td align="left">Crossover rate</td><td align="left">0.2</td></tr><tr><td align="left">No. generations</td><td align="left">10</td></tr><tr><td align="left">No. individuals</td><td align="left">40</td></tr><tr><td align="left">Selection</td><td align="left">Binary tournament</td></tr><tr><td align="left">Crossover</td><td align="left">Append lists of edits</td></tr><tr><td align="left">Mutation</td><td align="left">Add/remove an edit</td></tr><tr><td align="left">Reference points</td><td align="left">Worst observation (for each prop. and bench.)</td></tr></tbody></table><table-wrap-foot><p>Each edit represents one mutation operation (see Sect.&#x000a0;<xref rid="Sec10" ref-type="sec">4.3.1</xref>)</p></table-wrap-foot></table-wrap>
</p><p id="Par85">For each version of code we improve, we run GIDroid 20 times with 400 evaluations. To minimise measurement noise, we use the Mann-Whitney U test at the 5% confidence level to determine whether there is an improvement of a given property (i.e., runtime, memory or bandwidth use). For the evolutionary algorithms, we divide these 400 evaluations into 10 generations with 40 individuals each, as was shown to be effective in previous work, including in the Android domain&#x000a0;(Motwani et&#x000a0;al. <xref ref-type="bibr" rid="CR59">2022</xref>; Callan and Petke <xref ref-type="bibr" rid="CR21">2022a</xref>). We set number of evaluations to 400 as, even when using simulation-based testing, the evaluation of an individual is slow, taking up to 2&#x000a0;min. We use the Genetic programming parameters in Table&#x000a0;<xref rid="Tab3" ref-type="table">3</xref> as they have been used successfully in the past&#x000a0;(Callan and Petke <xref ref-type="bibr" rid="CR22">2022b</xref>).</p><p id="Par86">We had 2520 runs in total, taking a mean of 3&#x000a0;h per run, resulting in roughly 7500&#x000a0;h of computing time to test our approach.</p><p id="Par87">All of our experiments were performed on a high-performance cloud computer, with 16GB RAM and 8-core Intel Xenon CPUs. We ran jobs across 10 nodes, each running separately to avoid interference between fitness measurements.</p></sec></sec><sec id="Sec16"><title>Results and discussion</title><p id="Par88">In this section, we present and analyse the results of our experiments, answering our Research Questions (Sect.&#x000a0;<xref rid="Sec11" ref-type="sec">5</xref>). Throughout this section we will refer to the CPU time (s) of the test process as execution time, the size of the occupied Java heap as memory consumption (MB), and the number of bytes sent and received by the test process as network usage (B). Each of these objectives is a fitness function which we aim to minimize.</p><sec id="Sec17"><title>RQ1: known improvements</title><p id="Par89">Figures&#x000a0;<xref rid="Fig4" ref-type="fig">4</xref> and &#x000a0;<xref rid="Fig5" ref-type="fig">5</xref> show the improvements found in the benchmarks in which we knew improvements were possible. We find improvements to both execution time and memory, but not bandwidth. We believe this is due to the nature of the benchmarks. Although feasible, only one application had bandwidth improvements in its history that would be achievable by GI. This improvement<xref ref-type="fn" rid="Fn4">4</xref> required 2 insertions and 2 deletions at once to be achieved and thus was more difficult to evolve over time.</p><p id="Par91">We find improvements to execution time of up to 26% and memory of up to 69%. We manually analysed the patches found in order to determine whether GI was capable of finding the same patches that developers made to improve their applications. The result of this analysis can be found in Table&#x000a0;<xref rid="Tab4" ref-type="table">4</xref>. In &#x000a0;64% of benchmarks GIDroid&#x000a0;is able to find patches containing edits semantically-equivalent to developer patches, providing at least the same percentage performance improvement. In other words, aside from reproducing improvements, in some cases, we find additional edits, further improving app performance.<table-wrap id="Tab4"><label>Table 4</label><caption><p>No. of times GIDroid finds patches that contain edits semantically-equivalent to developer patches, providing at least the same % performance improvement (Rep.) and no. runs where an improvement was found (Imp.)</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Application version</th><th align="left" colspan="2">NSGAII</th><th align="left" colspan="2">NSGAIII</th><th align="left" colspan="2">SPEA2</th></tr><tr><th align="left"/><th align="left">Rep.</th><th align="left">Imp.</th><th align="left">Rep.</th><th align="left">Imp.</th><th align="left">Rep.</th><th align="left">Imp.</th></tr></thead><tbody><tr><td align="left">Port Authority 1</td><td align="left">4</td><td align="left">16</td><td align="left">8</td><td align="left">18</td><td align="left">3</td><td align="left">15</td></tr><tr><td align="left">Port Authority 2</td><td align="left">0</td><td align="left">17</td><td align="left">0</td><td align="left">15</td><td align="left">0</td><td align="left">14</td></tr><tr><td align="left">Port Authority 3</td><td align="left">0</td><td align="left">13</td><td align="left">0</td><td align="left">14</td><td align="left">0</td><td align="left">18</td></tr><tr><td align="left">Port Authority 4</td><td align="left">4</td><td align="left">15</td><td align="left">8</td><td align="left">17</td><td align="left">10</td><td align="left">13</td></tr><tr><td align="left">Port Authority 5</td><td align="left">5</td><td align="left">19</td><td align="left">3</td><td align="left">19</td><td align="left">0</td><td align="left">12</td></tr><tr><td align="left">Port Authority 6</td><td align="left">4</td><td align="left">13</td><td align="left">7</td><td align="left">18</td><td align="left">2</td><td align="left">11</td></tr><tr><td align="left">Tower Collector 1</td><td align="left">10</td><td align="left">14</td><td align="left">6</td><td align="left">13</td><td align="left">8</td><td align="left">20</td></tr><tr><td align="left">Tower Collector 2</td><td align="left">0</td><td align="left">15</td><td align="left">0</td><td align="left">18</td><td align="left">0</td><td align="left">19</td></tr><tr><td align="left">Gadgetbridge 1</td><td align="left">0</td><td align="left">15</td><td align="left">0</td><td align="left">12</td><td align="left">0</td><td align="left">13</td></tr><tr><td align="left">Fosdem Companion 1</td><td align="left">3</td><td align="left">13</td><td align="left">4</td><td align="left">12</td><td align="left">7</td><td align="left">14</td></tr><tr><td align="left">Fdroid 1</td><td align="left">0</td><td align="left">19</td><td align="left">0</td><td align="left">17</td><td align="left">0</td><td align="left">13</td></tr><tr><td align="left">Fdroid 2</td><td align="left">8</td><td align="left">14</td><td align="left">4</td><td align="left">12</td><td align="left">6</td><td align="left">16</td></tr><tr><td align="left">Lightning Browser 1</td><td align="left">2</td><td align="left">12</td><td align="left">3</td><td align="left">18</td><td align="left">4</td><td align="left">17</td></tr><tr><td align="left">Frozen Bubble 1</td><td align="left">13</td><td align="left">15</td><td align="left">12</td><td align="left">16</td><td align="left">12</td><td align="left">18</td></tr></tbody></table><table-wrap-foot><p>Each MO run was repeated 20 times</p></table-wrap-foot></table-wrap></p><p id="Par92">
<fig id="Fig4"><label>Fig. 4</label><caption><p>Execution time improvements (%) achieved by patches generated by GIDroid&#x000a0;using three MO algorithms on 21 versions of 7 Android apps (see Table&#x000a0;<xref rid="Tab2" ref-type="table">2</xref>). Each boxplot shows best patches from 20 runs per MO algorithm and benchmark</p></caption><graphic xlink:href="10515_2024_472_Fig4_HTML" id="MO7"/></fig>
<fig id="Fig5"><label>Fig. 5</label><caption><p>Memory consumption improvements (%) achieved by patches generated by GIDroid&#x000a0;using three MO algorithms on 21 versions of 7 Android apps (see Table&#x000a0;<xref rid="Tab2" ref-type="table">2</xref>). Each boxplot shows best patches from 20 runs per MO algorithm and benchmark</p></caption><graphic xlink:href="10515_2024_472_Fig5_HTML" id="MO8"/></fig>
<graphic position="anchor" xlink:href="10515_2024_472_Figd_HTML" id="MO9"/>
</p></sec><sec id="Sec18"><title>RQ2: improvements of current apps</title><p id="Par93">Next, we analyse the results of the experiments on the benchmarks of current versions of applications, to see how well our approach generalizes to code in which there are no known improvements.</p><p id="Par94">The performance of each algorithm on versions of software is shown in Figs.&#x000a0;<xref rid="Fig4" ref-type="fig">4</xref> and <xref rid="Fig5" ref-type="fig">5</xref>. We find improvements to the execution time of up to 35% (this patch improved memory use by 9% and had no effect on bandwidth usage) and to memory consumption of up to 32% (with a 3% increase in execution time and no effect on bandwidth usage). Again no improvements were found to bandwidth. We believe this is due to the nature of our benchmarks, where only FDroid 2 uses bandwidth extensively (Figs.&#x000a0;<xref rid="Fig6" ref-type="fig">6</xref>, <xref rid="Fig7" ref-type="fig">7</xref>).
</p><p id="Par95">We have compiled the best changes found by GIDroid&#x000a0;in these experiments to demonstrate the capabilities of GIDroid.</p><p id="Par96">We have also issued pull request, however, these have not yet been actioned by the developers. We detail each of these patches below<xref ref-type="fn" rid="Fn5">5</xref></p><sec id="Sec19"><title>Port-authority (PAN)</title><p id="Par98">In the Port Authority application, our best change found consisted of removing an unnecessary try-catch statement, which resolved the IP address of a URL. It would not only attempt to resolve URLs, but also, redundantly, IP addresses. Furthermore, the resolved IP address is then passed to the constructor of the InetSocketAdress class, which already performs IP resolution, rendering the statement completely redundant. The error handling is also performed in the same way when the IP address is passed to the InetSocket. This improved execution time by 8% and memory usage by 24%.<graphic position="anchor" xlink:href="10515_2024_472_Fige_HTML" id="MO10"/></p></sec><sec id="Sec20"><title>F-Droid (FDN)</title><p id="Par99">The improvement for F-droid refactored an if/else statement. Before, the statement checked if an object was null or not, instantiating it if it were null, and canceling its animation if not. However, after this statement, the object was instantly re-initialised. Meaning that in the case where the object was null, it would be instantiated once and then instantiated immediately after. We refactor the statement to remove the null clause and only cancel the animation if the object is not null. This improved execution time by 19% and memory usage by 29%. <graphic position="anchor" xlink:href="10515_2024_472_Figf_HTML" id="MO11"/></p></sec><sec id="Sec21"><title>Tower collector (TCN)</title><p id="Par100">In the TowerCollector, the best-evolved change consisted of changes to the way in which a database is handled. It ensured that the connection to the database is closed when no longer needed and that the database is only instantiated when it is actually needed. This change reduces memory usage by 21% but slightly increases execution time due to an extra function call. <graphic position="anchor" xlink:href="10515_2024_472_Figg_HTML" id="MO12"/></p></sec><sec id="Sec22"><title>Frozen bubble (FBN)</title><p id="Par101">In the Frozen Bubble application, the best improving change consisted of modifying how new rows of bubbles were instantiated in a row. This improved execution time by 15%.</p><p id="Par102">We found that checking for <inline-formula id="IEq17"><alternatives><tex-math id="d33e1836">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$-1$$\end{document}</tex-math><mml:math id="d33e1841"><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math><inline-graphic xlink:href="10515_2024_472_Article_IEq17.gif"/></alternatives></inline-formula> in the newly generated row was redundant as the row cannot contain a <inline-formula id="IEq18"><alternatives><tex-math id="d33e1847">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$-1$$\end{document}</tex-math><mml:math id="d33e1852"><mml:mrow><mml:mo>-</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math><inline-graphic xlink:href="10515_2024_472_Article_IEq18.gif"/></alternatives></inline-formula>, it can only contain positive integers. We also found that the game pushed the sprite to the back of the board, but inspecting the application with and without this change shows no noticeable difference. <graphic position="anchor" xlink:href="10515_2024_472_Figh_HTML" id="MO13"/></p></sec><sec id="Sec23"><title>Fosdem-companion (FSN)</title><p id="Par103">In the Fosdem application the most improving change consists of moving the instantiation of two objects outside of a loop. This means the same object can be reused in the loop, with the need for a new object to be assigned, thus saving both memory 24% and execution time 23%. <graphic position="anchor" xlink:href="10515_2024_472_Figi_HTML" id="MO14"/></p></sec><sec id="Sec24"><title>Gadget bridge (GBN)</title><p id="Par104">In the best change for the Gadget Bridge Application we remove the redundant rendering of a view that is already visible. reducing execution time by 35% <graphic position="anchor" xlink:href="10515_2024_472_Figj_HTML" id="MO15"/></p></sec><sec id="Sec25"><title>Lightning browser (LBN)</title><p id="Par105">In Lightning Browser, the best-evolved mutation consists of removing a check for whether or not a list of bookmarks is null. This improved execution time by 19%. The list is an argument decorated with @NonNull so should never be null, and in the case that is there will be no errors. <graphic position="anchor" xlink:href="10515_2024_472_Figk_HTML" id="MO16"/><graphic position="anchor" xlink:href="10515_2024_472_Figl_HTML" id="MO17"/><table-wrap id="Tab5"><label>Table 5</label><caption><p>Normalised hypervolumes of the Pareto fronts found by GIDroid across our experiments, by algorithm</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Application version</th><th align="left">NSGAII</th><th align="left">NSGAIII</th><th align="left">SPEA2</th></tr></thead><tbody><tr><td align="left">PortAuthority 1 (PA1)</td><td align="left">0.145</td><td align="left">0.186</td><td align="left"><bold>0</bold>.<bold>458</bold></td></tr><tr><td align="left">PortAuthority 2 (PA2)</td><td align="left">0.223</td><td align="left">0.267</td><td align="left"><bold>0</bold>.<bold>327</bold></td></tr><tr><td align="left">PortAuthority 3 (PA3)</td><td align="left">0.259</td><td align="left"><bold>0</bold>.<bold>285</bold></td><td align="left">0.249</td></tr><tr><td align="left">PortAuthority 4 (PA4)</td><td align="left"><bold>0</bold>.<bold>429</bold></td><td align="left">0.225</td><td align="left">0.112</td></tr><tr><td align="left">PortAuthority 5 (PA5)</td><td align="left"><bold>0</bold>.<bold>247</bold></td><td align="left">0.073</td><td align="left">0.196</td></tr><tr><td align="left">PortAuthority 6 (PA6)</td><td align="left">0.053</td><td align="left">0.053</td><td align="left"><bold>0</bold>.<bold>143</bold></td></tr><tr><td align="left">PortAuthority Current (PAN)</td><td align="left">0.051</td><td align="left">0.133</td><td align="left"><bold>0</bold>.<bold>59</bold></td></tr><tr><td align="left">Tower Collector 1 (TC1)</td><td align="left">0.03</td><td align="left">0.019</td><td align="left"><bold>0.127</bold></td></tr><tr><td align="left">Tower Collector 2 (TC2)</td><td align="left">0.027</td><td align="left">0.052</td><td align="left"><bold>0</bold>.<bold>088</bold></td></tr><tr><td align="left">Tower Collector Current (TCN)</td><td align="left">0.254</td><td align="left">0.017</td><td align="left"><bold>0</bold>.<bold>309</bold></td></tr><tr><td align="left">Gadgetbridge 1 (GB1)</td><td align="left"><bold>0</bold>.<bold>611</bold></td><td align="left">0.568</td><td align="left">0.158</td></tr><tr><td align="left">Gadgetbridge Current (GBN)</td><td align="left">0.008</td><td align="left"><bold>0</bold>.<bold>384</bold></td><td align="left">0.007</td></tr><tr><td align="left">Fosdem Companion 1 (FS1)</td><td align="left">0.318</td><td align="left"><bold>0</bold>.<bold>383</bold></td><td align="left">0.359</td></tr><tr><td align="left">Fosdem Companion Curr. (FSN)</td><td align="left">0.105</td><td align="left"><bold>0.138</bold></td><td align="left">0.021</td></tr><tr><td align="left">Fdroid 1 (FD1)</td><td align="left">0.016</td><td align="left"><bold>0</bold>.<bold>206</bold></td><td align="left">0.012</td></tr><tr><td align="left">Fdroid 2 (FD2)</td><td align="left">0.022</td><td align="left">0.042</td><td align="left"><bold>0</bold>.<bold>525</bold></td></tr><tr><td align="left">Fdroid Current (FDN)</td><td align="left">0.206</td><td align="left">0.065</td><td align="left"><bold>0</bold>.<bold>233</bold></td></tr><tr><td align="left">Lightning Browser 1 (LB1)</td><td align="left"><bold>0</bold>.<bold>322</bold></td><td align="left">0.159</td><td align="left">0.028</td></tr><tr><td align="left">Lightning Browser Curr. (LBN)</td><td align="left">0.038</td><td align="left">0.037</td><td align="left"><bold>0</bold>.<bold>039</bold></td></tr><tr><td align="left">Frozen Bubble 1 (FB1)</td><td align="left"><bold>0</bold>.<bold>097</bold></td><td align="left">0.094</td><td align="left">0.076</td></tr><tr><td align="left">Frozen Bubble Current (FBN)</td><td align="left">0.024</td><td align="left">0.024</td><td align="left"><bold>0</bold>.<bold>026</bold></td></tr></tbody></table></table-wrap></p><p id="Par106">
<fig id="Fig6"><label>Fig. 6</label><caption><p>Pareto Front from NSGA-II experiments on the FB1 Benchmark</p></caption><graphic xlink:href="10515_2024_472_Fig6_HTML" id="MO18"/></fig>
<fig id="Fig7"><label>Fig. 7</label><caption><p>Boxplot of improvements found to execution time by each algorithm</p></caption><graphic xlink:href="10515_2024_472_Fig7_HTML" id="MO19"/></fig>
<fig id="Fig8"><label>Fig. 8</label><caption><p>Boxplot of improvements found to memory consumption by each algorithm</p></caption><graphic xlink:href="10515_2024_472_Fig8_HTML" id="MO20"/></fig>
</p></sec></sec><sec id="Sec26"><title>RQ3: multi-objective search</title><p id="Par107">In order to compare the different algorithms used in search, we consider the procedure proposed by Li et&#x000a0;al. (<xref ref-type="bibr" rid="CR43">2020</xref>), for comparing different multi-objective algorithms in a search-based software engineering context. We choose to measure the hypervolume (HV) of the data, as it is considered to be a good indication of the general quality of the Pareto fronts produced and is considered appropriate when there is no preference between the different properties being improved. In order to measure the hypervolume we specify the reference points as the worst observation for all fitness measurements, for each objective, as done in previous work&#x000a0;(Ji et&#x000a0;al. <xref ref-type="bibr" rid="CR36">2018</xref>; Liu et&#x000a0;al. <xref ref-type="bibr" rid="CR49">2021</xref>). Due to different fitness scales, we normalise the values, though also present raw ones in our online repository, including all Pareto fronts&#x000a0;(GIDroid <xref ref-type="bibr" rid="CR31">2023</xref>). Normalised hypervolume values are presented in Table&#x000a0;<xref rid="Tab5" ref-type="table">5</xref>. The Pareto fronts from all of our multi-objective experiments can be found in our repository&#x000a0;(GIDroid <xref ref-type="bibr" rid="CR31">2023</xref>). We find that across our experiment we find patches spread across the Pareto front (see Figs. <xref rid="Fig6" ref-type="fig">6</xref>, <xref rid="Fig7" ref-type="fig">7</xref>, and <xref rid="Fig8" ref-type="fig">8</xref>), showing that trade-offs between properties must be considered in the search process, due to the natural tension between them.<table-wrap id="Tab6"><label>Table 6</label><caption><p>A effect size for each algorithm on each benchmark</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left" rowspan="2">Benchmark</th><th align="left" colspan="3">Exec. time</th><th align="left" colspan="3">Mem. Con.</th></tr><tr><th align="left">NSGA-II</th><th align="left">NSGA-III</th><th align="left">SPEA2</th><th align="left">NSGA-II</th><th align="left">NSGA-III</th><th align="left">SPEA2</th></tr></thead><tbody><tr><td align="left">PortAuthority 1</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td><td align="left">0.93 (L)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td></tr><tr><td align="left">PortAuthority 2</td><td align="left">0.98 (L)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td></tr><tr><td align="left">PortAuthority 3</td><td align="left">0.97 (L)</td><td align="left">0.97 (L)</td><td align="left">0.97 (L)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td><td align="left">0.93 (L)</td></tr><tr><td align="left">PortAuthority 4</td><td align="left">0.99 (L)</td><td align="left">0.99 (L)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td></tr><tr><td align="left">PortAuthority 5</td><td align="left">0.67 (M)</td><td align="left">0.81 (L)</td><td align="left">0.18 (L)</td><td align="left">0.82 (L)</td><td align="left">1.0 (L)</td><td align="left">0.79 (M)</td></tr><tr><td align="left">PortAuthority 6</td><td align="left">0.88 (L)</td><td align="left">0.99 (L)</td><td align="left">0.71 (M)</td><td align="left">0.91 (L)</td><td align="left">1.0 (L)</td><td align="left">0.9 (L)</td></tr><tr><td align="left">PortAuthority Current</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td><td align="left">0.67 (M)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td></tr><tr><td align="left">Tower Collector 1</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td><td align="left">0.89 (L)</td><td align="left">0.98 (L)</td><td align="left">1.0 (L)</td><td align="left">0.92 (L)</td></tr><tr><td align="left">Tower Collector 2</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td></tr><tr><td align="left">Tower Collector Current</td><td align="left">0.92 (L)</td><td align="left">1.0 (L)</td><td align="left">0.85 (L)</td><td align="left">1.0 (L)</td><td align="left">0.67 (M)</td><td align="left">0.98 (L)</td></tr><tr><td align="left">Gadgetbridge 1</td><td align="left">0.87 (L)</td><td align="left">0.96 (L)</td><td align="left">0.53 (N)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td><td align="left">0.54 (N)</td></tr><tr><td align="left">Gadgetbridge Current 1</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td></tr><tr><td align="left">FosdemComp. 1</td><td align="left">1.0 (L)</td><td align="left">0.95 (L)</td><td align="left">0.67(M)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td><td align="left">0.83 (L)</td></tr><tr><td align="left">FosdemComp. Current</td><td align="left">1.0 (L)</td><td align="left">0.95 (L)</td><td align="left">0.67(M)</td><td align="left">1.0 (L)</td><td align="left">0.83 (L)</td><td align="left">1.0 (L)</td></tr><tr><td align="left">Fdroid 1</td><td align="left">0.77 (L)</td><td align="left">0.92 (L)</td><td align="left">0.73 (L)</td><td align="left">0.82 (L)</td><td align="left">1.0 (L)</td><td align="left">0.76 (L)</td></tr><tr><td align="left">Fdroid 2</td><td align="left">0.99 (L)</td><td align="left">0.93 (L)</td><td align="left">0.92 (L)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td></tr><tr><td align="left">Fdroid Current</td><td align="left">0.74 (L)</td><td align="left">1.0 (L)</td><td align="left">0.99 (L)</td><td align="left">0.98 (L)</td><td align="left">1.0 (L)</td><td align="left">0.99 (L)</td></tr><tr><td align="left">LightningBro</td><td align="left">0.79 (L)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td><td align="left">0.95 (L)</td><td align="left">1.0 (L)</td></tr><tr><td align="left">LightningBro. Current</td><td align="left">0.9 (L)</td><td align="left">0.83 (L)</td><td align="left">0.59 (S)</td><td align="left">1.0 (L)</td><td align="left">0.9 (L)</td><td align="left">0.92 (L)</td></tr><tr><td align="left">FrozenBubble 1</td><td align="left">0.98 (L)</td><td align="left">1.0 (L)</td><td align="left">0.97 (L)</td><td align="left">0.98 (L)</td><td align="left">1.0 (L)</td><td align="left">0.97 (L)</td></tr><tr><td align="left">FrozenBubble Current</td><td align="left">1.0 (L)</td><td align="left">0.93 (L)</td><td align="left">0.88 (L)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td><td align="left">1.0 (L)</td></tr></tbody></table><table-wrap-foot><p>Effect sizes larger than 0.5 show positive improvement. differences: N = negligible, S = small, M = medium, L = large</p></table-wrap-foot></table-wrap></p><p id="Par108">We find that NSGA-II performs similarly to NSGA-III, with the biggest hypervolume in 5 cases for both algorithms. We find that SPEA2 performs best, finding the best fronts in 11 cases. In general, the different algorithms seem to perform similarly in terms of the best improvements found, as shown in Figs.&#x000a0;<xref rid="Fig4" ref-type="fig">4</xref> and <xref rid="Fig5" ref-type="fig">5</xref>. We find that the caching operators we introduced turned out to be highly effective, appearing in 26% of improving patches.<table-wrap id="Tab7"><label>Table 7</label><caption><p>Frequency in which each operator was found in the best patches of each run</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Operator</th><th align="left">% of best patches using operator</th></tr></thead><tbody><tr><td align="left">Delete</td><td align="left">24.0</td></tr><tr><td align="left">Swap</td><td align="left">17.1</td></tr><tr><td align="left">Replace</td><td align="left">15.4</td></tr><tr><td align="left">Copy</td><td align="left">20.1</td></tr><tr><td align="left">Cache</td><td align="left">7.0</td></tr><tr><td align="left">ClassCache</td><td align="left">4.5</td></tr></tbody></table></table-wrap></p><p id="Par109">We find improving patches in 1092 out of 1260 experiments.</p><p id="Par110">We also evaluate the effect size of the improvements found by each of the MO algorithms, as show in Table&#x000a0;<xref rid="Tab6" ref-type="table">6</xref>. We use the Vargha and Delaney A measure&#x000a0;(Vargha and Delaney <xref ref-type="bibr" rid="CR72">2000</xref>) to calculate the magnitude of the differences between the observations of the NFPs of original applications and the improved versions. This measure is non-parametric so does assume data is normally distributed. We find that in all but 8 cases we find large effect sizes, and only find negligible differences in 2 cases (Table&#x000a0;<xref rid="Tab7" ref-type="table">7</xref>).<graphic position="anchor" xlink:href="10515_2024_472_Figm_HTML" id="MO21"/></p></sec><sec id="Sec27"><title>RQ4: comparison to SO-GI</title><p id="Par111">
<table-wrap id="Tab8"><label>Table 8</label><caption><p>Maximum improvements to execution time and memory use found by GIDroid using SO-GI (no bandwidth improvements were found)</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Application version</th><th align="left">Exec. time (%)</th><th align="left">Mem. Con. (%)</th></tr></thead><tbody><tr><td align="left">PortAuthority 1</td><td align="left">23.39</td><td align="left">71.69</td></tr><tr><td align="left">PortAuthority 2</td><td align="left">21.2</td><td align="left">53.05</td></tr><tr><td align="left">PortAuthority 3</td><td align="left">23.13</td><td align="left">33.76</td></tr><tr><td align="left">PortAuthority 4</td><td align="left">26.32</td><td align="left">60.59</td></tr><tr><td align="left">PortAuthority 5</td><td align="left">28.03</td><td align="left">59.13</td></tr><tr><td align="left">PortAuthority 6</td><td align="left">24.44</td><td align="left">24.43</td></tr><tr><td align="left">PortAuthority Current</td><td align="left">29.9</td><td align="left">9.32</td></tr><tr><td align="left">Tower Collector 1</td><td align="left">16.01</td><td align="left">30.82</td></tr><tr><td align="left">Tower Collector 2</td><td align="left">26.92</td><td align="left">34.61</td></tr><tr><td align="left">Tower Collector Current</td><td align="left">20.9</td><td align="left">32.43</td></tr><tr><td align="left">Gadgetbridge 1</td><td align="left">29.52</td><td align="left">31.29</td></tr><tr><td align="left">Gadgetbridge Current</td><td align="left">26.73</td><td align="left">5.89</td></tr><tr><td align="left">FosdemComp. 1</td><td align="left">32.8</td><td align="left">36.81</td></tr><tr><td align="left">FosdemComp. Current</td><td align="left">10.31</td><td align="left">13.62</td></tr><tr><td align="left">Fdroid 1</td><td align="left">21.82</td><td align="left">17.06</td></tr><tr><td align="left">Fdroid 2</td><td align="left">27.94</td><td align="left">33.01</td></tr><tr><td align="left">Fdroid Current</td><td align="left">14.14</td><td align="left">32.18</td></tr><tr><td align="left">LightningBrow. 1</td><td align="left">28.45</td><td align="left">8.96</td></tr><tr><td align="left">LightningBro. Current</td><td align="left">23.71</td><td align="left">32.43</td></tr><tr><td align="left">FrozenBubble 1</td><td align="left">16.67</td><td align="left">36.11</td></tr><tr><td align="left">FrozenBubble Current</td><td align="left">19.88</td><td align="left">4.09</td></tr></tbody></table></table-wrap>
</p><p id="Par112">Next, we run single-objective Genetic Improvement on each of our benchmarks. We measure the effects of the changes found by SO-GI on our other properties. The results of this evaluation can be found in Table&#x000a0;<xref rid="Tab8" ref-type="table">8</xref>. We found improvements to execution time of up to 33% and memory consumption of up to 72%.</p><p id="Par113">We find that SO search generally performs better when improving individual properties than multi-objective search. However, a multi-objective search was capable of finding improvements to both execution time and memory in a similar time as a single-objective search could find improvements to individual properties. Single-objective search produces results that improve one property in 753 of 1260 cases (21 benchmarks <inline-formula id="IEq19"><alternatives><tex-math id="d33e2854">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$*$$\end{document}</tex-math><mml:math id="d33e2859"><mml:mrow><mml:mrow/><mml:mo>&#x02217;</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="10515_2024_472_Article_IEq19.gif"/></alternatives></inline-formula> 20 runs <inline-formula id="IEq20"><alternatives><tex-math id="d33e2865">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$*$$\end{document}</tex-math><mml:math id="d33e2870"><mml:mrow><mml:mrow/><mml:mo>&#x02217;</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="10515_2024_472_Article_IEq20.gif"/></alternatives></inline-formula> 3 properties) but in 47% of these cases, patches are detrimental to another property.<graphic position="anchor" xlink:href="10515_2024_472_Fign_HTML" id="MO22"/></p></sec><sec id="Sec28"><title>RQ5: cost of GI</title><p id="Par114">
<fig id="Fig9"><label>Fig. 9</label><caption><p>Time taken by GIDroid using different MO algorithms to evolve 10 generations, each with 40 individuals</p></caption><graphic xlink:href="10515_2024_472_Fig9_HTML" id="MO23"/></fig>
</p><p id="Par115">In order to evaluate the applicability of our approach, we analyze its cost. Figure&#x000a0;<xref rid="Fig9" ref-type="fig">9</xref> shows a boxplot of the time taken in hours for our experiments. We find that the time taken varies a lot between different benchmarks and in some cases even across different runs on the same benchmark. We find that MO-GI takes between 0.1 and 20.6&#x000a0;h, with a median time across the benchmarks of 2.6&#x000a0;h. The main source of variation across the benchmarks is the difference in time taken by the test suites. In the slowest benchmark, the test suite takes 8&#x000a0;s to execute, whereas the quickest one takes 2&#x000a0;s. In the slowest experiments, there were more patches that compiled, rather than instantly failing, further slowing down the experiments.</p><p id="Par116">We find that SO-GI takes longer than MO-GI, with a minimum of 0.4&#x000a0;h, a maximum of 19.0&#x000a0;h, and a median of 3.5&#x000a0;h. SO-GI can only find improvements to one property at a time, showing the much-improved efficiency of using MO-GI. Despite hour-long runtimes, we note that this is a one-off cost. Given that app users consider wait time of 150 ms &#x02018;laggy&#x02019;, which might lead to them abandoning an app, and considering the difficulty of manually optimising non-functional properties, especially in large codebases, we deem the cost of running MO-GI worth it.<graphic position="anchor" xlink:href="10515_2024_472_Figo_HTML" id="MO24"/></p></sec><sec id="Sec29"><title>RQ6: comparison to linter and ChatGPT</title><p id="Par117">In order to compare our approach to the currently available tooling for improving performance for Android, we run a well-known Linter (PMD) on all of the benchmarks which we improved. We configured it to provide warnings when any of its performance rules were violated. We then manually analyzed each of the warnings that it provided, and in the cases where they could be repaired without disrupting the functionality of the application, we repaired them.</p><p id="Par118">We then measured the performance differences between the repaired and unrepaired versions of the applications. We found that in our 21 benchmarks, 5 had either no warnings or warnings that could not be repaired without introducing buggy behavior. For example, a warning about instantiating an object in a loop could be &#x0201c;unfixable&#x0201d; as a reference to each instantiated object is held in an array. So, moving the instantiation outside of the loop would result in an array with the same reference repeated multiple times.</p><p id="Par119">In all cases where possible, the fixes were easily created and very similar to the examples given in the PMD documentation, and are available in our online repository&#x000a0;(GIDroid <xref ref-type="bibr" rid="CR31">2023</xref>).</p><p id="Par120">Of the 16 where fixes were possible, only 9 actually offered any improvement. The maximum improvement to execution time was 4.5%, while to memory it was 10.42%, when compared with 35% and 69%, respectively, achieved by GIDroid. No improvements to bandwidth usage were found. Only a single one of these patches improved multiple properties, and 6 were detrimental to other properties. Of those improvements, none had any impact on the bandwidth of the applications. The linters were, however, significantly quicker than GI, taking a maximum time of 20&#x000a0;min to repair the warnings. However, unlike GI this process is not automatic and requires a developer to be engaged at all times and the improvements found were much smaller than those found by GI (Table&#x000a0;<xref rid="Tab9" ref-type="table">9</xref>).<table-wrap id="Tab9"><label>Table 9</label><caption><p>Improvements (%) from repairing linter warnings, for benchmarks where viable improvements were found</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Application version</th><th align="left">Exec. time</th><th align="left">Mem. Con</th><th align="left">Time (min.)</th></tr></thead><tbody><tr><td align="left">PortAuthority 1</td><td align="left"><inline-formula id="IEq21"><alternatives><tex-math id="d33e2943">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$-$$\end{document}</tex-math><mml:math id="d33e2948"><mml:mo>-</mml:mo></mml:math><inline-graphic xlink:href="10515_2024_472_Article_IEq21.gif"/></alternatives></inline-formula>2.5</td><td align="left">2.8</td><td align="left">2</td></tr><tr><td align="left">PortAuthority 5</td><td align="left">2.4</td><td align="left">10.4</td><td align="left">9</td></tr><tr><td align="left">PortAuthority Current</td><td align="left">0.9</td><td align="left"><inline-formula id="IEq22"><alternatives><tex-math id="d33e2972">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$-$$\end{document}</tex-math><mml:math id="d33e2977"><mml:mo>-</mml:mo></mml:math><inline-graphic xlink:href="10515_2024_472_Article_IEq22.gif"/></alternatives></inline-formula>2.8</td><td align="left">1</td></tr><tr><td align="left">TowerCollector 2</td><td align="left">0 1</td><td align="left">0</td><td align="left">5</td></tr><tr><td align="left">TowerCollector Current</td><td align="left">0.0</td><td align="left">1.9</td><td align="left">7</td></tr><tr><td align="left">Fdroid 1</td><td align="left">4.5</td><td align="left">0</td><td align="left">13</td></tr><tr><td align="left">Fdroid Current</td><td align="left">2.3</td><td align="left"><inline-formula id="IEq23"><alternatives><tex-math id="d33e3017">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$-$$\end{document}</tex-math><mml:math id="d33e3022"><mml:mo>-</mml:mo></mml:math><inline-graphic xlink:href="10515_2024_472_Article_IEq23.gif"/></alternatives></inline-formula>0.2</td><td align="left">9</td></tr><tr><td align="left">LightningBrow. 1</td><td align="left"><inline-formula id="IEq24"><alternatives><tex-math id="d33e3033">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$-$$\end{document}</tex-math><mml:math id="d33e3038"><mml:mo>-</mml:mo></mml:math><inline-graphic xlink:href="10515_2024_472_Article_IEq24.gif"/></alternatives></inline-formula>2.2</td><td align="left">0.4</td><td align="left">1</td></tr><tr><td align="left">LightningBrow. Current</td><td align="left">0.9</td><td align="left"><inline-formula id="IEq25"><alternatives><tex-math id="d33e3053">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$-$$\end{document}</tex-math><mml:math id="d33e3058"><mml:mo>-</mml:mo></mml:math><inline-graphic xlink:href="10515_2024_472_Article_IEq25.gif"/></alternatives></inline-formula>1.6</td><td align="left">5</td></tr><tr><td align="left">FrozenBubble 1</td><td align="left">3.5</td><td align="left"><inline-formula id="IEq26"><alternatives><tex-math id="d33e3071">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$-$$\end{document}</tex-math><mml:math id="d33e3076"><mml:mo>-</mml:mo></mml:math><inline-graphic xlink:href="10515_2024_472_Article_IEq26.gif"/></alternatives></inline-formula>0.1</td><td align="left">20</td></tr><tr><td align="left">FrozenBubble Current</td><td align="left"><inline-formula id="IEq27"><alternatives><tex-math id="d33e3087">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$-$$\end{document}</tex-math><mml:math id="d33e3092"><mml:mo>-</mml:mo></mml:math><inline-graphic xlink:href="10515_2024_472_Article_IEq27.gif"/></alternatives></inline-formula>1.6</td><td align="left">0.4</td><td align="left">15</td></tr></tbody></table></table-wrap></p><p id="Par121">ChatGPT, on the other hand, failed to find any improvements,<xref ref-type="fn" rid="Fn6">6</xref> while GIDroid&#x000a0;re-discovered 64% of those.<graphic position="anchor" xlink:href="10515_2024_472_Figp_HTML" id="MO25"/></p></sec></sec><sec id="Sec30"><title>Threats to validity</title><p id="Par123">There are a number of threats to the validity of our study. We discuss these next, including steps we took to mitigate them.</p><p id="Par124">The measurements we use for our fitnesses are noisy. In scenarios with multiple processes or extensive I/O operations, the CPU time may not accurately represent the execution time. To mitigate such threats, we run the garbage collector before taking final memory measurements so we can consistently measure the memory usage. We also measure the runtime so increase in this due to garbage collection triggers would be detected and the changes where this had a large impact discarded. We repeat each measurement 20 times during search and after the search is complete. We use the Mann&#x02013;Whitney U test at the 5% confidence level to determine whether there is an improvement. We tested our measurements on known improvements and found that they are consistently detected. Finally, we validate all improvements both with extra evaluations after experiments and manual analysis.</p><p id="Par125">Furthermore, we use tests to determine whether or not a patch is valid. This does not guarantee correctness. We test areas of code in which we either know there is a performance defect, as either they have been fixed by developers previously, or a static analyser has indicated there may be a performance defect. Each test suite achieves at least 75% branch coverage. The test cases were found to be good enough that the majority of the patches validated against them were actually valid and allow us to find real improvements, thus, for GI they were certainly good enough. Moreover, during search, we exclusively utilise local unit testing, not testing patches on actual devices or emulators. We utilise the Robolectric library to simulate Android UI rendering. Patches that are produced are validated using this library and any discrepancies between this library and the actual APIs may result in patches that are correct with respect to Robolectric, but patches that are not actually correct. However, the patches produced can undergo the standard code review procedure as any other code being integrated into a project would. We conducted a manual analysis of all the patches on the Pareto fronts (1753 total), to ensure the improvements reported here do not disturb app functionality. Through manual analysis, we found that 1352 out of the 1753 best patches found did not disrupt the functionality of the apps, demonstrating the strength of our test suites. Disruptive patches included the removal of some error handling and the deletion of some components rendered on screen that could not be detected with unit tests. They would be easily discarded by code review.</p><p id="Par126">Using stochastic search may result in us finding improvements out of sheer luck. In order to avoid this issue, reliably compare different algorithms, and demonstrate generalisability of our approach, we run each of the algorithms tested 20 times on each of our 21 benchmarks.</p><p id="Par127">The search algorithms we use rely on parameters such as mutation and crossover rate. The values of these parameters can have an effect on the effectiveness of the algorithms. To mitigate this threat, we use the same parameters across all experiments for fair comparison. We use settings used in previous work that found improvements in software.</p><p id="Par128">We tested our approach on 21 versions of 7 Android apps, which poses a threat to generalisability to other software. However, these apps are diverse in size and type (see Table&#x000a0;<xref rid="Tab2" ref-type="table">2</xref>). Moreover, we found improvements in current app versions, which were previously undiscovered. Some of them simply removed redundant calls, an optimisation that can be applied to any software and found using the delete mutation operator in GIDroid&#x000a0;(see&#x000a0;Sect.&#x000a0;<xref rid="Sec18" ref-type="sec">7.2</xref>). Unfortunately, currently, the big obstacle to wider adoption is test availability. For each benchmark, these took us hours to produce. However, the benefits of testing go beyond the applicability of our approach. We envision with the development of more fine-grained automated test generation tooling for Android and better testing practices, further benefits of GI can be unlocked.</p><p id="Par129">To mitigate such threats further, we make all our code and results freely available&#x000a0;(GIDroid <xref ref-type="bibr" rid="CR31">2023</xref>), allowing other researchers and developers to use and extend our tool and validate our work.</p></sec><sec id="Sec31"><title>Conclusions and future work</title><p id="Par130">We propose to use multi-objective Genetic Improvement (MO-GI) to automatically improve Android apps. We are the first to apply MO-GI with three objectives to improve software performance and evaluate feasibility of MO-GI for bandwidth and memory use in the Android domain. To evaluate the effectiveness of the proposed approach we developed GIDroid, which contains 3 MO algorithms and 2 novel cache-based mutation operators. We have tested GIDroid on 21 benchmarks, targeting runtime, memory, and bandwidth use. We find improvements to the execution time of up to 35% and memory consumption of up to 65%. However, we find that for the benchmarks we used, our approach cannot find improvements to bandwidth, even though they are within GIDroid&#x02019;s search space. Future work could explore the capabilities of large language models for generating non-functional property-improving patches. Although the techniques currently only perform well on relatively small programs&#x000a0;(Madaan et&#x000a0;al. <xref ref-type="bibr" rid="CR51">2023</xref>), trained on source code from programming competitions or puzzles which is short and self-contained&#x000a0;(Puri et&#x000a0;al. <xref ref-type="bibr" rid="CR66">2021</xref>). These examples do not contain the complex shared state and interaction with external components that are commonplace in Android apps.
</p></sec></body><back><fn-group><fn id="Fn1"><label>1</label><p id="Par11">At the time of our experiments, none of the automated test generation tools for Android were compatible with latest Android software, thus we had to manually create tests to evaluate our MO-GI approach.</p></fn><fn id="Fn2"><label>2</label><p id="Par74"><ext-link ext-link-type="uri" xlink:href="https://openai.com/blog/chatgpt/">https://openai.com/blog/chatgpt/</ext-link>.</p></fn><fn id="Fn3"><label>3</label><p id="Par81">Links to the apps are available in our repository: <ext-link ext-link-type="uri" xlink:href="https://github.com/SOLAR-group/GIDroid/tree/main/Benchmark">https://github.com/SOLAR-group/GIDroid/tree/main/Benchmark</ext-link>.</p></fn><fn id="Fn4"><label>4</label><p id="Par90"><ext-link ext-link-type="uri" xlink:href="https://github.com/erikusaj/fdroidTvClient/commit/bf8aa30a576144524e83731a1bad20a1dab3f1bc">https://github.com/erikusaj/fdroidTvClient/commit/bf8aa30a576144524e83731a1bad20a1dab3f1bc</ext-link>.</p></fn><fn id="Fn5"><label>5</label><p id="Par97">These can be found in our repository&#x000a0;(GIDroid <xref ref-type="bibr" rid="CR31">2023</xref>) under &#x02018;bestPatch&#x02019; in each of the 7 applications (PAN,FDN,TCN,FBN,FSN,GBN,LBN): in the &#x02018;Benchmark&#x02019; folder.</p></fn><fn id="Fn6"><label>6</label><p id="Par122">All responses are in our repo&#x000a0;(GIDroid <xref ref-type="bibr" rid="CR31">2023</xref>), in the &#x02018;Results/ChatGPT&#x02019; folder.</p></fn><fn><p><bold>Publisher's Note</bold></p><p>Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p></fn></fn-group><notes notes-type="funding-information"><title>Funding</title><p>This work was supported by EPSRC Grant No. EP/P023991/1.</p></notes><notes notes-type="data-availability"><title>Data Availability</title><p>All code and results are available in our repository GIDroid (<xref ref-type="bibr" rid="CR31">2023</xref>).</p></notes><notes><title>Declarations</title><notes id="FPar1" notes-type="COI-statement"><title>Conflict of interest</title><p id="Par134">Prof. Petke is a Deputy Editor-in-Chief for the Automated Software Engineering journal. There are no other conflict of interest to declare.</p></notes></notes><ref-list id="Bib1"><title>References</title><ref id="CR1"><mixed-citation publication-type="other">Amalfitano, D., Amatucci, N., Fasolino, A.R., et&#x000a0;al.: Agrippin: a novel search based testing technique for Android applications. In: DeMobile@SIGSOFT FSE, pp. 5&#x02013;12. ACM (2015)</mixed-citation></ref><ref id="CR2"><mixed-citation publication-type="other">An, G., Blot, A., Petke, J., et&#x000a0;al.: Pyggi 2.0: language independent genetic improvement framework. In: Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering, ESEC/FSE 2019, pp. 1100&#x02013;1104 (2019)</mixed-citation></ref><ref id="CR3"><mixed-citation publication-type="other">Android Development Team: Android context. <ext-link ext-link-type="uri" xlink:href="https://developer.android.com/reference/android/content/Context">https://developer.android.com/reference/android/content/Context</ext-link> (2022a). Accessed 12 May 2023</mixed-citation></ref><ref id="CR4"><mixed-citation publication-type="other">Android Development Team: Android testing guide. <ext-link ext-link-type="uri" xlink:href="https://developer.android.com/studio/test">https://developer.android.com/studio/test</ext-link> (2022b). Accessed 07 Feb 2023</mixed-citation></ref><ref id="CR5"><mixed-citation publication-type="other">Android Development Team: Android compilation guide. <ext-link ext-link-type="uri" xlink:href="https://developer.android.com/studio/build">https://developer.android.com/studio/build</ext-link> (2023a). Accessed 07 Feb 2023</mixed-citation></ref><ref id="CR6"><mixed-citation publication-type="other">Android Development Team: Android lint tool. <ext-link ext-link-type="uri" xlink:href="https://developer.android.com/studio/write/lint">https://developer.android.com/studio/write/lint</ext-link> (2023b). Accessed 06 Feb 2023</mixed-citation></ref><ref id="CR7"><mixed-citation publication-type="other">Auer, M., Adler, F., Fraser, G.: Improving search-based Android test generation using surrogate models. In: SSBSE, Lecture Notes in Computer Science, vol. 13711, pp. 51&#x02013;66. Springer (2022)</mixed-citation></ref><ref id="CR8"><citation-alternatives><element-citation id="ec-CR8" publication-type="journal"><person-group person-group-type="author"><name><surname>Ayala</surname><given-names>I</given-names></name><name><surname>Amor</surname><given-names>M</given-names></name><name><surname>Fuentes</surname><given-names>L</given-names></name></person-group><article-title>An energy efficiency study of web-based communication in android phones</article-title><source>Sci. Program.</source><year>2019</year><volume>8235458</volume><issue>1&#x02013;8235458</issue><fpage>19</fpage><pub-id pub-id-type="doi">10.1155/2019/8235458</pub-id></element-citation><mixed-citation id="mc-CR8" publication-type="journal">Ayala, I., Amor, M., Fuentes, L.: An energy efficiency study of web-based communication in android phones. Sci. Program. <bold>8235458</bold>(1&#x02013;8235458), 19 (2019). 10.1155/2019/8235458</mixed-citation></citation-alternatives></ref><ref id="CR9"><mixed-citation publication-type="other">Azim, T., Neamtiu, I.: Targeted and depth-first exploration for systematic testing of android apps. In: OOPSLA, pp. 641&#x02013;660. ACM (2013)</mixed-citation></ref><ref id="CR10"><mixed-citation publication-type="other">Bach, T., Andrzejak, A., Pannemans, R., et&#x000a0;al.: The impact of coverage on bug density in a large industrial software project. In: ESEM, pp. 307&#x02013;313. IEEE (2017)</mixed-citation></ref><ref id="CR11"><mixed-citation publication-type="other">Baek, Y.M., Bae, D.: Automated model-based Android GUI testing using multi-level GUI comparison criteria. In: ASE, pp. 238&#x02013;249. ACM (2016)</mixed-citation></ref><ref id="CR12"><mixed-citation publication-type="other">Basios, M., Li, L., Wu, F., et&#x000a0;al.: Optimising Darwinian data structures on Google Guava. In: SSBSE, Lecture Notes in Computer Science, vol. 10452, pp. 161&#x02013;167. Springer (2017)</mixed-citation></ref><ref id="CR13"><citation-alternatives><element-citation id="ec-CR13" publication-type="journal"><person-group person-group-type="author"><name><surname>Baumann</surname><given-names>P</given-names></name><name><surname>Santini</surname><given-names>S</given-names></name></person-group><article-title>Every byte counts: selective prefetching for mobile applications</article-title><source>Proc. ACM Interact. Mob. Wearable Ubiquitous Technol.</source><year>2017</year><volume>1</volume><issue>2</issue><fpage>6:1</fpage><lpage>6:29</lpage></element-citation><mixed-citation id="mc-CR13" publication-type="journal">Baumann, P., Santini, S.: Every byte counts: selective prefetching for mobile applications. Proc. ACM Interact. Mob. Wearable Ubiquitous Technol. <bold>1</bold>(2), 6:1-6:29 (2017)</mixed-citation></citation-alternatives></ref><ref id="CR14"><mixed-citation publication-type="other">Berg, F., Durr, F., Rothermel, K.: Increasing the efficiency and responsiveness of mobile applications with preemptable code offloading. In: 2014 IEEE International Conference on Mobile Services (MS) &#x000c2;, pp. 76&#x02013;83 (2014)</mixed-citation></ref><ref id="CR15"><citation-alternatives><element-citation id="ec-CR15" publication-type="journal"><person-group person-group-type="author"><name><surname>Blot</surname><given-names>A</given-names></name><name><surname>Petke</surname><given-names>J</given-names></name></person-group><article-title>Empirical comparison of search heuristics for genetic improvement of software</article-title><source>IEEE Trans. Evol. Comput.</source><year>2021</year><volume>25</volume><issue>5</issue><fpage>1001</fpage><lpage>1011</lpage></element-citation><mixed-citation id="mc-CR15" publication-type="journal">Blot, A., Petke, J.: Empirical comparison of search heuristics for genetic improvement of software. IEEE Trans. Evol. Comput. <bold>25</bold>(5), 1001&#x02013;1011 (2021)</mixed-citation></citation-alternatives></ref><ref id="CR16"><mixed-citation publication-type="other">Bokhari, M.A., Bruce, B.R., Alexander, B., et&#x000a0;al.: Deep parameter optimisation on Android smartphones for energy minimisation: a tale of woe and a proof-of-concept. In: GECCO (Companion), pp. 1501&#x02013;1508. ACM (2017)</mixed-citation></ref><ref id="CR17"><mixed-citation publication-type="other">Brownlee, A.E.I., Petke, J., Alexander, B., et&#x000a0;al.: Gin: genetic improvement research made easy. In: GECCO, pp. 985&#x02013;993. ACM (2019)</mixed-citation></ref><ref id="CR18"><mixed-citation publication-type="other">Bruce, B.R., Petke, J., Harman, M.: Reducing energy consumption using genetic improvement. In: GECCO, pp. 1327&#x02013;1334. ACM (2015)</mixed-citation></ref><ref id="CR19"><mixed-citation publication-type="other">Burles, N., Bowles, E., Brownlee, A.E.I., et&#x000a0;al.: Object-oriented genetic improvement for improved energy consumption in Google Guava. In: SSBSE, Lecture Notes in Computer Science, vol. 9275, pp. 255&#x02013;261. Springer (2015)</mixed-citation></ref><ref id="CR20"><mixed-citation publication-type="other">Callan, J., Petke, J.: Improving Android app responsiveness through automated frame rate reduction. In: SSBSE, Lecture Notes in Computer Science, vol. 12914, pp. 136&#x02013;150. Springer (2021)</mixed-citation></ref><ref id="CR21"><mixed-citation publication-type="other">Callan, J., Petke, J.: Improving responsiveness of Android activity navigation via genetic improvement. In: ICSE-Companion, pp. 356&#x02013;357. ACM/IEEE (2022a)</mixed-citation></ref><ref id="CR22"><mixed-citation publication-type="other">Callan, J., Petke, J.: Multi-objective genetic improvement: a case study with EvoSuite. In: SSBSE, Lecture Notes in Computer Science, vol. 13711, pp. 111&#x02013;117. Springer (2022b)</mixed-citation></ref><ref id="CR23"><citation-alternatives><element-citation id="ec-CR23" publication-type="journal"><person-group person-group-type="author"><name><surname>Callan</surname><given-names>J</given-names></name><name><surname>Krauss</surname><given-names>O</given-names></name><name><surname>Petke</surname><given-names>J</given-names></name><etal/></person-group><article-title>How do Android developers improve non-functional properties of software?</article-title><source>Empir. Softw. Eng.</source><year>2022</year><volume>27</volume><issue>5</issue><fpage>113</fpage><pub-id pub-id-type="pmid">35663289</pub-id>
</element-citation><mixed-citation id="mc-CR23" publication-type="journal">Callan, J., Krauss, O., Petke, J., et al.: How do Android developers improve non-functional properties of software? Empir. Softw. Eng. <bold>27</bold>(5), 113 (2022)<pub-id pub-id-type="pmid">35663289</pub-id>
</mixed-citation></citation-alternatives></ref><ref id="CR24"><citation-alternatives><element-citation id="ec-CR24" publication-type="book"><person-group person-group-type="author"><name><surname>Chun</surname><given-names>BG</given-names></name><name><surname>Ihm</surname><given-names>S</given-names></name><name><surname>Maniatis</surname><given-names>P</given-names></name><etal/></person-group><source>Clonecloud: Elastic Execution Between Mobile Device and Cloud</source><year>2011</year><publisher-loc>New York</publisher-loc><publisher-name>Association for Computing Machinery</publisher-name></element-citation><mixed-citation id="mc-CR24" publication-type="book">Chun, B.G., Ihm, S., Maniatis, P., et al.: Clonecloud: Elastic Execution Between Mobile Device and Cloud. Association for Computing Machinery, New York (2011)</mixed-citation></citation-alternatives></ref><ref id="CR25"><mixed-citation publication-type="other">Cruz, L., Abreu, R.: Performance-based guidelines for energy efficient mobile applications. In: 4th IEEE/ACM International Conference on Mobile Software Engineering and Systems, MOBILESoft@ICSE 2017, Buenos Aires, Argentina, May 22&#x02013;23, 2017, pp. 46&#x02013;57. IEEE (2017). 10.1109/MOBILESOFT.2017.19</mixed-citation></ref><ref id="CR26"><mixed-citation publication-type="other">Das, P.K., Shome, S., Sarkar, A.K.: Apps: accelerating performance and power saving in smartphones using code offload. In: 2016 IEEE 6th International Conference on Advanced Computing (IACC), pp. 759&#x02013;765 (2016)</mixed-citation></ref><ref id="CR27"><citation-alternatives><element-citation id="ec-CR27" publication-type="journal"><person-group person-group-type="author"><name><surname>Deb</surname><given-names>K</given-names></name><name><surname>Jain</surname><given-names>H</given-names></name></person-group><article-title>An evolutionary many-objective optimization algorithm using reference-point-based nondominated sorting approach, part I: solving problems with box constraints</article-title><source>IEEE Trans. Evol. Comput.</source><year>2014</year><volume>18</volume><issue>4</issue><fpage>577</fpage><lpage>601</lpage></element-citation><mixed-citation id="mc-CR27" publication-type="journal">Deb, K., Jain, H.: An evolutionary many-objective optimization algorithm using reference-point-based nondominated sorting approach, part I: solving problems with box constraints. IEEE Trans. Evol. Comput. <bold>18</bold>(4), 577&#x02013;601 (2014)</mixed-citation></citation-alternatives></ref><ref id="CR28"><mixed-citation publication-type="other">Deb, K., Agrawal, S., Pratap, A., et&#x000a0;al.: A fast elitist non-dominated sorting genetic algorithm for multi-objective optimisation: NSGA-II. In: PPSN, Lecture Notes in Computer Science, vol. 1917, pp. 849&#x02013;858. Springer (2000)</mixed-citation></ref><ref id="CR29"><mixed-citation publication-type="other">Ding, A.Y., Bo Han, Yu., Xiao, et al.: Enabling energy-aware collaborative mobile data offloading for smartphones. In: 2013 IEEE International Conference on Sensing, Communications and Networking (SECON), pp. 487&#x02013;495 (2013)</mixed-citation></ref><ref id="CR30"><mixed-citation publication-type="other">FindBugs Development Team: FindBugs Lint Tool. <ext-link ext-link-type="uri" xlink:href="https://findbugs.sourceforge.net/">https://findbugs.sourceforge.net/</ext-link> (2015). Accessed 06 Feb 2023</mixed-citation></ref><ref id="CR31"><mixed-citation publication-type="other">GIDroid: a tool for multi-objective GI in Android (2023). <ext-link ext-link-type="uri" xlink:href="https://github.com/SOLAR-group/GIDroid">https://github.com/SOLAR-group/GIDroid</ext-link></mixed-citation></ref><ref id="CR32"><mixed-citation publication-type="other">Habchi, S., Blanc, X., Rouvoy, R.: On adopting linters to deal with performance concerns in Android apps. In: Huchard, M., K&#x000e4;stner, C., Fraser, G. (eds.) Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering, ASE 2018, Montpellier, France, September 3&#x02013;7, 2018, pp. 6&#x02013;16. ACM (2018)</mixed-citation></ref><ref id="CR33"><mixed-citation publication-type="other">Haraldsson, S.O., Woodward, J.R., Brownlee, A.E.I., et&#x000a0;al.: Fixing bugs in your sleep: how genetic improvement became an overnight success. In: Bosman, P.A.N. (ed.) GECCO, Berlin, Germany, July 15&#x02013;19, 2017, Companion Material Proceedings, pp. 1513&#x02013;1520. ACM (2017)</mixed-citation></ref><ref id="CR34"><citation-alternatives><element-citation id="ec-CR34" publication-type="journal"><person-group person-group-type="author"><name><surname>Hort</surname><given-names>M</given-names></name><name><surname>Kechagia</surname><given-names>M</given-names></name><name><surname>Sarro</surname><given-names>F</given-names></name><etal/></person-group><article-title>A survey of performance optimization for mobile applications</article-title><source>IEEE Trans. Softw. Eng.</source><year>2022</year><volume>48</volume><issue>8</issue><fpage>2879</fpage><lpage>2904</lpage></element-citation><mixed-citation id="mc-CR34" publication-type="journal">Hort, M., Kechagia, M., Sarro, F., et al.: A survey of performance optimization for mobile applications. IEEE Trans. Softw. Eng. <bold>48</bold>(8), 2879&#x02013;2904 (2022)</mixed-citation></citation-alternatives></ref><ref id="CR35"><mixed-citation publication-type="other">Inukollu, V., Keshamoni, D., Kang, T., et&#x000a0;al.: Factors influencing quality of mobile apps: role of mobile app development life cycle. Int. J. Soft Eng. Appl. <bold>5</bold>, 15&#x02013;34 (2014)</mixed-citation></ref><ref id="CR36"><mixed-citation publication-type="other">Ji, R., Li, Z., Chen, S., et&#x000a0;al.: Uncovering unknown system behaviors in uncertain networks with model and search-based testing. In: ICST, pp. 204&#x02013;214. IEEE (2018)</mixed-citation></ref><ref id="CR37"><mixed-citation publication-type="other">Kemp, S.: Digital 2022: mobile duopoly consolidates its grip&#x02014;datareportal&#x02014;global digital insights. <ext-link ext-link-type="uri" xlink:href="https://datareportal.com/reports/digital-2022-mobile-duopoly-consolidates-grip">https://datareportal.com/reports/digital-2022-mobile-duopoly-consolidates-grip</ext-link> (2022). Accessed 01 Mar 2024</mixed-citation></ref><ref id="CR38"><mixed-citation publication-type="other">Kerrisk, M.: Linux time. <ext-link ext-link-type="uri" xlink:href="https://man7.org/linux/man-pages/man1/time.1.html">https://man7.org/linux/man-pages/man1/time.1.html</ext-link> (2019). Accessed 10 Feb 2023</mixed-citation></ref><ref id="CR39"><mixed-citation publication-type="other">Kerrisk, M.: Linux process tracking. <ext-link ext-link-type="uri" xlink:href="https://man7.org/linux/man-pages/man5/proc.5.html">https://man7.org/linux/man-pages/man5/proc.5.html</ext-link> (2022). Accessed 10 Feb 2023</mixed-citation></ref><ref id="CR40"><citation-alternatives><element-citation id="ec-CR40" publication-type="journal"><person-group person-group-type="author"><name><surname>Khalid</surname><given-names>H</given-names></name><name><surname>Shihab</surname><given-names>E</given-names></name><name><surname>Nagappan</surname><given-names>M</given-names></name><etal/></person-group><article-title>What do mobile app users complain about?</article-title><source>IEEE Softw.</source><year>2015</year><volume>32</volume><issue>3</issue><fpage>70</fpage><lpage>77</lpage></element-citation><mixed-citation id="mc-CR40" publication-type="journal">Khalid, H., Shihab, E., Nagappan, M., et al.: What do mobile app users complain about? IEEE Softw. <bold>32</bold>(3), 70&#x02013;77 (2015)</mixed-citation></citation-alternatives></ref><ref id="CR41"><mixed-citation publication-type="other">Kim, M., Hiroyasu, T., Miki, M., et&#x000a0;al.: SPEA2+: improving the performance of the strength Pareto evolutionary algorithm 2. In: PPSN, Lecture Notes in Computer Science, vol. 3242, pp. 742&#x02013;751. Springer (2004)</mixed-citation></ref><ref id="CR42"><mixed-citation publication-type="other">Langdon, W.B., Lam, B.Y.H., Petke, J., et&#x000a0;al.: Improving CUDA DNA analysis software with genetic programming. In: Silva, S., Esparcia-Alc&#x000e1;zar, A.I. (eds.) Proceedings of the Genetic and Evolutionary Computation Conference, GECCO 2015, Madrid, Spain, July 11&#x02013;15, 2015, pp. 1063&#x02013;1070. ACM (2015)</mixed-citation></ref><ref id="CR43"><citation-alternatives><element-citation id="ec-CR43" publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>M</given-names></name><name><surname>Chen</surname><given-names>T</given-names></name><name><surname>Yao</surname><given-names>X</given-names></name></person-group><article-title>How to evaluate solutions in Pareto-based search-based software engineering: A critical review and methodological guidance</article-title><source>IEEE Trans. Softw. Eng.</source><year>2020</year><volume>48</volume><fpage>1</fpage><lpage>1</lpage></element-citation><mixed-citation id="mc-CR43" publication-type="journal">Li, M., Chen, T., Yao, X.: How to evaluate solutions in Pareto-based search-based software engineering: A critical review and methodological guidance. IEEE Trans. Softw. Eng. <bold>48</bold>, 1&#x02013;1 (2020)</mixed-citation></citation-alternatives></ref><ref id="CR44"><mixed-citation publication-type="other">Li, S.S., Peeler, H., Sloss, A.N., et&#x000a0;al.: Genetic improvement in the Shackleton framework for optimizing LLVM pass sequences. In: GECCO Companion. ACM, pp. 1938&#x02013;1939 (2022)</mixed-citation></ref><ref id="CR45"><mixed-citation publication-type="other">Li, Y., Yang, Z., Guo, Y., et&#x000a0;al.: DroidBot: a lightweight UI-guided test input generator for Android. In: ICSE (Companion Volume), pp. 23&#x02013;26. IEEE (2017)</mixed-citation></ref><ref id="CR46"><citation-alternatives><element-citation id="ec-CR46" publication-type="journal"><person-group person-group-type="author"><name><surname>Lim</surname><given-names>SL</given-names></name><name><surname>Bentley</surname><given-names>P</given-names></name><name><surname>Kanakam</surname><given-names>N</given-names></name><etal/></person-group><article-title>Investigating country differences in mobile app user behavior and challenges for software engineering</article-title><source>IEEE TSE</source><year>2014</year><volume>41</volume><fpage>40</fpage><lpage>64</lpage></element-citation><mixed-citation id="mc-CR46" publication-type="journal">Lim, S.L., Bentley, P., Kanakam, N., et al.: Investigating country differences in mobile app user behavior and challenges for software engineering. IEEE TSE <bold>41</bold>, 40&#x02013;64 (2014)</mixed-citation></citation-alternatives></ref><ref id="CR47"><mixed-citation publication-type="other">Lin, Y., Radoi, C., Dig, D.: Retrofitting concurrency for Android applications through refactoring. In: FSE, pp. 341&#x02013;352. ACM (2014)</mixed-citation></ref><ref id="CR48"><mixed-citation publication-type="other">Lin, Y., Okur, S., Dig, D.: Study and refactoring of Android asynchronous programming (T). In: ASE, pp. 224&#x02013;235. IEEE (2015)</mixed-citation></ref><ref id="CR49"><citation-alternatives><element-citation id="ec-CR49" publication-type="journal"><person-group person-group-type="author"><name><surname>Liu</surname><given-names>Y</given-names></name><name><surname>Zhu</surname><given-names>N</given-names></name><name><surname>Li</surname><given-names>M</given-names></name></person-group><article-title>Solving many-objective optimization problems by a Pareto-based evolutionary algorithm with preprocessing and a penalty mechanism</article-title><source>IEEE Trans. Cybern.</source><year>2021</year><volume>51</volume><issue>11</issue><fpage>5585</fpage><lpage>5594</lpage><pub-id pub-id-type="pmid">32452796</pub-id>
</element-citation><mixed-citation id="mc-CR49" publication-type="journal">Liu, Y., Zhu, N., Li, M.: Solving many-objective optimization problems by a Pareto-based evolutionary algorithm with preprocessing and a penalty mechanism. IEEE Trans. Cybern. <bold>51</bold>(11), 5585&#x02013;5594 (2021)<pub-id pub-id-type="pmid">32452796</pub-id>
</mixed-citation></citation-alternatives></ref><ref id="CR50"><mixed-citation publication-type="other">Lyu, Y., Li, D., Halfond, W.G.J.: Remove rats from your code: automated optimization of resource inefficient database writes for mobile applications. In: ISSTA, pp. 310&#x02013;321. ACM (2018)</mixed-citation></ref><ref id="CR51"><mixed-citation publication-type="other">Madaan, A., Shypula, A., Alon, U., et&#x000a0;al.: Learning performance-improving code edits. CoRR abs/2302.07867 (2023)</mixed-citation></ref><ref id="CR52"><mixed-citation publication-type="other">Mahmood, R., Mirzaei, N., Malek, S.: Evodroid: segmented evolutionary testing of Android apps. In: SIGSOFT FSE, pp. 599&#x02013;609. ACM (2014)</mixed-citation></ref><ref id="CR53"><mixed-citation publication-type="other">Mao, K., Harman, M., Jia, Y.: Sapienz: multi-objective automated testing for Android applications. In: ISSTA, pp. 94&#x02013;105. ACM (2016)</mixed-citation></ref><ref id="CR54"><mixed-citation publication-type="other">Mateus, B.G., Martinez, M., Kolski, C.: An experience-based recommendation system to support migrations of Android applications from Java to Kotlin. CoRR abs/2103.09728 (2021)</mixed-citation></ref><ref id="CR55"><mixed-citation publication-type="other">Mesecan, I., Blackwell, D., Clark, D., et&#x000a0;al.: Keeping secrets: multi-objective genetic improvement for detecting and reducing information leakage. In: ASE, pp. 61:1&#x02013;61:12. ACM (2022)</mixed-citation></ref><ref id="CR56"><mixed-citation publication-type="other">Mockus, A., Nagappan, N., Dinh-Trong, T.T.: Test coverage and post-verification defects: a multiple case study. In: ESEM, pp. 291&#x02013;301. IEEE (2009)</mixed-citation></ref><ref id="CR57"><citation-alternatives><element-citation id="ec-CR57" publication-type="book"><person-group person-group-type="author"><name><surname>Mohan</surname><given-names>P</given-names></name><name><surname>Nath</surname><given-names>S</given-names></name><name><surname>Riva</surname><given-names>O</given-names></name></person-group><source>Prefetching Mobile Ads: Can Advertising Systems Afford it?</source><year>2013</year><publisher-loc>New York</publisher-loc><publisher-name>Association for Computing Machinery</publisher-name></element-citation><mixed-citation id="mc-CR57" publication-type="book">Mohan, P., Nath, S., Riva, O.: Prefetching Mobile Ads: Can Advertising Systems Afford it? Association for Computing Machinery, New York (2013)</mixed-citation></citation-alternatives></ref><ref id="CR58"><citation-alternatives><element-citation id="ec-CR58" publication-type="journal"><person-group person-group-type="author"><name><surname>Morales</surname><given-names>R</given-names></name><name><surname>Saborido</surname><given-names>R</given-names></name><name><surname>Khomh</surname><given-names>F</given-names></name><etal/></person-group><article-title>EARMO: an energy-aware refactoring approach for mobile apps</article-title><source>IEEE Trans. Softw. Eng.</source><year>2018</year><volume>44</volume><issue>12</issue><fpage>1176</fpage><lpage>1206</lpage></element-citation><mixed-citation id="mc-CR58" publication-type="journal">Morales, R., Saborido, R., Khomh, F., et al.: EARMO: an energy-aware refactoring approach for mobile apps. IEEE Trans. Softw. Eng. <bold>44</bold>(12), 1176&#x02013;1206 (2018)</mixed-citation></citation-alternatives></ref><ref id="CR59"><citation-alternatives><element-citation id="ec-CR59" publication-type="journal"><person-group person-group-type="author"><name><surname>Motwani</surname><given-names>M</given-names></name><name><surname>Soto</surname><given-names>M</given-names></name><name><surname>Brun</surname><given-names>Y</given-names></name><etal/></person-group><article-title>Quality of automated program repair on real-world defects</article-title><source>IEEE TSE</source><year>2022</year><volume>48</volume><issue>2</issue><fpage>637</fpage><lpage>661</lpage></element-citation><mixed-citation id="mc-CR59" publication-type="journal">Motwani, M., Soto, M., Brun, Y., et al.: Quality of automated program repair on real-world defects. IEEE TSE <bold>48</bold>(2), 637&#x02013;661 (2022)</mixed-citation></citation-alternatives></ref><ref id="CR60"><mixed-citation publication-type="other">Nistor, A., Song, L., Marinov, D., et&#x000a0;al.: Toddler: detecting performance problems via similar memory-access patterns. In: ICSE, pp. 562&#x02013;571 (2013)</mixed-citation></ref><ref id="CR61"><mixed-citation publication-type="other">Oracle Development Team: Java&#x02019;s runtime class. <ext-link ext-link-type="uri" xlink:href="https://docs.oracle.com/javase/7/docs/api/java/lang/Runtime.html">https://docs.oracle.com/javase/7/docs/api/java/lang/Runtime.html</ext-link> (2020). Accessed 10 Feb 2023</mixed-citation></ref><ref id="CR62"><mixed-citation publication-type="other">Pecorelli, F., Catolino, G., Ferrucci, F., et&#x000a0;al.: Testing of mobile applications in the wild: a large-scale empirical study on Android apps. In: ICPC, pp. 296&#x02013;307. ACM (2020)</mixed-citation></ref><ref id="CR63"><mixed-citation publication-type="other">Petke, J., Langdon, W.B., Harman, M.: Applying genetic improvement to MiniSAT. In: SSBSE, Lecture Notes in Computer Science, vol. 8084, pp. 257&#x02013;262. Springer (2013)</mixed-citation></ref><ref id="CR64"><citation-alternatives><element-citation id="ec-CR64" publication-type="journal"><person-group person-group-type="author"><name><surname>Petke</surname><given-names>J</given-names></name><name><surname>Haraldsson</surname><given-names>SO</given-names></name><name><surname>Harman</surname><given-names>M</given-names></name><etal/></person-group><article-title>Genetic improvement of software: a comprehensive survey</article-title><source>IEEE Trans. Evol. Comput.</source><year>2018</year><volume>22</volume><issue>3</issue><fpage>415</fpage><lpage>432</lpage></element-citation><mixed-citation id="mc-CR64" publication-type="journal">Petke, J., Haraldsson, S.O., Harman, M., et al.: Genetic improvement of software: a comprehensive survey. IEEE Trans. Evol. Comput. <bold>22</bold>(3), 415&#x02013;432 (2018)</mixed-citation></citation-alternatives></ref><ref id="CR65"><mixed-citation publication-type="other">PMD Development Team: PMD: an extensible cross-language static code analyzer. <ext-link ext-link-type="uri" xlink:href="https://pmd.github.io/">https://pmd.github.io/</ext-link> (2023). Accessed 06 Feb 2023</mixed-citation></ref><ref id="CR66"><mixed-citation publication-type="other">Puri, R., Kung, D.S., Janssen, G., et&#x000a0;al.: Project codenet: a large-scale AI for code dataset for learning a diversity of coding tasks. CoRR abs/2105.12655 (2021)</mixed-citation></ref><ref id="CR67"><mixed-citation publication-type="other">Robolectric Develop. Team: Robolectric.<ext-link ext-link-type="uri" xlink:href="https://robolectric.org/">https://robolectric.org/</ext-link> (2023). Accessed 12 May 2023</mixed-citation></ref><ref id="CR68"><mixed-citation publication-type="other">Saarinen, A., Siekkinen, M., Xiao, Y., et&#x000a0;al.: Can offloading save energy for popular apps? In: Proceedings of the Seventh ACM International Workshop on Mobility in the Evolving Internet Architecture (2012)</mixed-citation></ref><ref id="CR69"><citation-alternatives><element-citation id="ec-CR69" publication-type="journal"><person-group person-group-type="author"><name><surname>Srinivas</surname><given-names>N</given-names></name><name><surname>Deb</surname><given-names>K</given-names></name></person-group><article-title>Multiobjective optimization using nondominated sorting in genetic algorithms</article-title><source>Evol. Comput.</source><year>1994</year><volume>2</volume><issue>3</issue><fpage>221</fpage><lpage>248</lpage></element-citation><mixed-citation id="mc-CR69" publication-type="journal">Srinivas, N., Deb, K.: Multiobjective optimization using nondominated sorting in genetic algorithms. Evol. Comput. <bold>2</bold>(3), 221&#x02013;248 (1994)</mixed-citation></citation-alternatives></ref><ref id="CR70"><mixed-citation publication-type="other">Su, T., Meng, G., Chen, Y., et&#x000a0;al.: Guided, stochastic model-based GUI testing of Android apps. In: ESEC/SIGSOFT FSE, pp. 245&#x02013;256. ACM (2017)</mixed-citation></ref><ref id="CR71"><citation-alternatives><element-citation id="ec-CR71" publication-type="journal"><person-group person-group-type="author"><name><surname>Tolia</surname><given-names>N</given-names></name><name><surname>Andersen</surname><given-names>DG</given-names></name><name><surname>Satyanarayanan</surname><given-names>M</given-names></name></person-group><article-title>Quantifying interactive user experience on thin clients</article-title><source>Computer</source><year>2006</year><volume>39</volume><issue>3</issue><fpage>46</fpage><lpage>52</lpage></element-citation><mixed-citation id="mc-CR71" publication-type="journal">Tolia, N., Andersen, D.G., Satyanarayanan, M.: Quantifying interactive user experience on thin clients. Computer <bold>39</bold>(3), 46&#x02013;52 (2006)</mixed-citation></citation-alternatives></ref><ref id="CR72"><citation-alternatives><element-citation id="ec-CR72" publication-type="journal"><person-group person-group-type="author"><name><surname>Vargha</surname><given-names>A</given-names></name><name><surname>Delaney</surname><given-names>HD</given-names></name></person-group><article-title>A critique and improvement of the &#x0201c;CL&#x0201d; common language effect size statistics of McGraw and Wong</article-title><source>J. Educ. Behav. Stat.</source><year>2000</year><volume>25</volume><issue>2</issue><fpage>101</fpage><lpage>132</lpage></element-citation><mixed-citation id="mc-CR72" publication-type="journal">Vargha, A., Delaney, H.D.: A critique and improvement of the &#x0201c;CL&#x02019;&#x02019; common language effect size statistics of McGraw and Wong. J. Educ. Behav. Stat. <bold>25</bold>(2), 101&#x02013;132 (2000)</mixed-citation></citation-alternatives></ref><ref id="CR73"><citation-alternatives><element-citation id="ec-CR73" publication-type="journal"><person-group person-group-type="author"><name><surname>White</surname><given-names>DR</given-names></name><name><surname>Arcuri</surname><given-names>A</given-names></name><name><surname>Clark</surname><given-names>JA</given-names></name></person-group><article-title>Evolutionary improvement of programs</article-title><source>IEEE Trans. Evol. Comput.</source><year>2011</year><volume>15</volume><issue>4</issue><fpage>515</fpage><lpage>538</lpage></element-citation><mixed-citation id="mc-CR73" publication-type="journal">White, D.R., Arcuri, A., Clark, J.A.: Evolutionary improvement of programs. IEEE Trans. Evol. Comput. <bold>15</bold>(4), 515&#x02013;538 (2011)</mixed-citation></citation-alternatives></ref><ref id="CR74"><mixed-citation publication-type="other">Wu, F., Weimer, W., Harman, M., et&#x000a0;al.: Deep parameter optimisation. In: GECCO, pp. 1375&#x02013;1382. ACM (2015)</mixed-citation></ref><ref id="CR75"><citation-alternatives><element-citation id="ec-CR75" publication-type="journal"><person-group person-group-type="author"><name><surname>Yasin</surname><given-names>HN</given-names></name><name><surname>Hamid</surname><given-names>SHA</given-names></name><name><surname>Yusof</surname><given-names>RJR</given-names></name></person-group><article-title>Droidbotx: test case generation tool for Android applications using q-learning</article-title><source>Symmetry</source><year>2021</year><volume>13</volume><issue>2</issue><fpage>310</fpage></element-citation><mixed-citation id="mc-CR75" publication-type="journal">Yasin, H.N., Hamid, S.H.A., Yusof, R.J.R.: Droidbotx: test case generation tool for Android applications using q-learning. Symmetry <bold>13</bold>(2), 310 (2021)</mixed-citation></citation-alternatives></ref><ref id="CR76"><mixed-citation publication-type="other">Zuo, S., Blot, A., Petke, J.: Evaluation of genetic improvement tools for improvement of non-functional properties of software. In: GECCO Companion, pp. 1956&#x02013;1965. ACM (2022)</mixed-citation></ref></ref-list></back></article>