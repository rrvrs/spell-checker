<!DOCTYPE article
PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD with MathML3 v1.3 20210610//EN" "JATS-archivearticle1-3-mathml3.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.3" xml:lang="en" article-type="research-article"><?properties open_access?><processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats"><restricted-by>pmc</restricted-by></processing-meta><front><journal-meta><journal-id journal-id-type="nlm-ta">Sensors (Basel)</journal-id><journal-id journal-id-type="iso-abbrev">Sensors (Basel)</journal-id><journal-id journal-id-type="publisher-id">sensors</journal-id><journal-title-group><journal-title>Sensors (Basel, Switzerland)</journal-title></journal-title-group><issn pub-type="epub">1424-8220</issn><publisher><publisher-name>MDPI</publisher-name></publisher></journal-meta>
<article-meta><article-id pub-id-type="pmid">40006485</article-id><article-id pub-id-type="pmc">PMC11861856</article-id><article-id pub-id-type="doi">10.3390/s25041256</article-id><article-id pub-id-type="publisher-id">sensors-25-01256</article-id><article-categories><subj-group subj-group-type="heading"><subject>Article</subject></subj-group></article-categories><title-group><article-title>Method for Detecting Disorder of a Nonlinear Dynamic Plant</article-title></title-group><contrib-group><contrib contrib-type="author"><contrib-id contrib-id-type="orcid" authenticated="true">https://orcid.org/0009-0006-1319-6374</contrib-id><name><surname>Wang</surname><given-names>Xuechun</given-names></name><role vocab="credit" vocab-identifier="https://credit.niso.org/" vocab-term="Methodology" vocab-term-identifier="https://credit.niso.org/contributor-roles/methodology/">Methodology</role><role vocab="credit" vocab-identifier="https://credit.niso.org/" vocab-term="Software" vocab-term-identifier="https://credit.niso.org/contributor-roles/software/">Software</role><role vocab="credit" vocab-identifier="https://credit.niso.org/" vocab-term="Validation" vocab-term-identifier="https://credit.niso.org/contributor-roles/validation/">Validation</role><role vocab="credit" vocab-identifier="https://credit.niso.org/" vocab-term="Formal analysis" vocab-term-identifier="https://credit.niso.org/contributor-roles/formal-analysis/">Formal analysis</role><role vocab="credit" vocab-identifier="https://credit.niso.org/" vocab-term="Investigation" vocab-term-identifier="https://credit.niso.org/contributor-roles/investigation/">Investigation</role><role vocab="credit" vocab-identifier="https://credit.niso.org/" vocab-term="Resources" vocab-term-identifier="https://credit.niso.org/contributor-roles/resources/">Resources</role><role vocab="credit" vocab-identifier="https://credit.niso.org/" vocab-term="Writing &#x02013; original draft" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-original-draft/">Writing &#x02013; original draft</role><role vocab="credit" vocab-identifier="https://credit.niso.org/" vocab-term="Writing &#x02013; review &#x00026; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing/">Writing &#x02013; review &#x00026; editing</role><role vocab="credit" vocab-identifier="https://credit.niso.org/" vocab-term="Visualization" vocab-term-identifier="https://credit.niso.org/contributor-roles/visualization/">Visualization</role><xref rid="af1-sensors-25-01256" ref-type="aff">1</xref><xref rid="c1-sensors-25-01256" ref-type="corresp">*</xref></contrib><contrib contrib-type="author"><contrib-id contrib-id-type="orcid" authenticated="true">https://orcid.org/0000-0002-9341-7475</contrib-id><name><surname>Eliseev</surname><given-names>Vladimir</given-names></name><role vocab="credit" vocab-identifier="https://credit.niso.org/" vocab-term="Conceptualization" vocab-term-identifier="https://credit.niso.org/contributor-roles/conceptualization/">Conceptualization</role><role vocab="credit" vocab-identifier="https://credit.niso.org/" vocab-term="Methodology" vocab-term-identifier="https://credit.niso.org/contributor-roles/methodology/">Methodology</role><role vocab="credit" vocab-identifier="https://credit.niso.org/" vocab-term="Writing &#x02013; review &#x00026; editing" vocab-term-identifier="https://credit.niso.org/contributor-roles/writing-review-editing/">Writing &#x02013; review &#x00026; editing</role><xref rid="af1-sensors-25-01256" ref-type="aff">1</xref><xref rid="af2-sensors-25-01256" ref-type="aff">2</xref></contrib></contrib-group><contrib-group><contrib contrib-type="editor"><name><surname>Agarwal</surname><given-names>Ramesh K.</given-names></name><role>Academic Editor</role></contrib><contrib contrib-type="editor"><name><surname>Wang</surname><given-names>Wilson Q.</given-names></name><role>Academic Editor</role></contrib></contrib-group><aff id="af1-sensors-25-01256"><label>1</label>Department of Control and Intelligent Technologies, National Research University &#x0201c;Moscow Power Engineering Institute&#x0201d;, Krasnokazarmennaya 14, Moscow 111250, Russia; <email>vlad-eliseev@mail.ru</email></aff><aff id="af2-sensors-25-01256"><label>2</label>InfoTeCS JSC, Mishina 56, Moscow 127083, Russia</aff><author-notes><corresp id="c1-sensors-25-01256"><label>*</label>Correspondence: <email>wexw@163.com</email></corresp></author-notes><pub-date pub-type="epub"><day>19</day><month>2</month><year>2025</year></pub-date><pub-date pub-type="collection"><month>2</month><year>2025</year></pub-date><volume>25</volume><issue>4</issue><elocation-id>1256</elocation-id><history><date date-type="received"><day>30</day><month>12</month><year>2024</year></date><date date-type="rev-recd"><day>11</day><month>2</month><year>2025</year></date><date date-type="accepted"><day>18</day><month>2</month><year>2025</year></date></history><permissions><copyright-statement>&#x000a9; 2025 by the authors.</copyright-statement><copyright-year>2025</copyright-year><license><ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref><license-p>Licensee MDPI, Basel, Switzerland. This article is an open access article distributed under the terms and conditions of the Creative Commons Attribution (CC BY) license (<ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</ext-link>).</license-p></license></permissions><abstract><p>This paper proposes a new disorder detection method CCF-AE for a scalar dynamic plant based only on its input&#x02013;output relation using a cross-correlation function and neural network autoencoder. The CCF-AE method does not use the reference model of the dynamic object, but only considers real-time behavior changes, given by input and output time series. The proposed method was used to detect disorder in the process of a nonlinear pH neutralization reaction, and was compared with the cumulative sum control chart (CUSUM) and the exponentially weighted moving variance control chart (EWMV). The CCF-AE method demonstrates a better true detection rate and lower false alarm rate than CUSUM and EWMV. Also, CCF-AE has more advantages in detecting disorder of complex nonlinear processes.</p></abstract><kwd-group><kwd>disorder detection</kwd><kwd>time series</kwd><kwd>dynamic plant</kwd><kwd>cross-correlation function</kwd><kwd>neural network autoencoder</kwd><kwd>cumulative sum algorithm</kwd><kwd>exponentially weighted moving variance</kwd><kwd>pH neutralization reaction</kwd></kwd-group><funding-group><funding-statement>This research received no external funding.</funding-statement></funding-group></article-meta></front><body><sec sec-type="intro" id="sec1-sensors-25-01256"><title>1. Introduction</title><p>In increasingly complex industrial environments, the stable operation of automation control systems is crucial to ensuring improved production efficiency and product quality. With the development of information technology, traditional control system design has gradually shifted from analog circuit architectures that rely on continuous signal processing to discrete time control technology using intelligent algorithms. However, this change also brings with it new challenges&#x02014;the increasing complexity of systems and the diversity of failure modes [<xref rid="B1-sensors-25-01256" ref-type="bibr">1</xref>]. The complexity of systems highlights the problem of detecting disorder and anomalies. Disorder is an unpredictable change in system parameters and an anomaly is a visible effect of system behavior change.</p><p>Disorder detection plays a vital role in modern automated control systems. It means dynamic monitoring for the rapid detection of any behavior or pattern deviating from the regular operating state during system operation by analyzing real-time data, which is a so-called abnormal situation. The root of abnormal situations includes but is not limited to hardware performance degradation, operation errors, and communication interruptions, which may cause system instability or even crashes.</p><p>The use of disorder detection technology helps to provide an early warning, enables the taking of preventive measures to prevent potential problems from worsening, and helps to maintain the efficient operation and safety of the entire system.</p><p>There are many situations that can lead to anomalies in the behavior of dynamic plants. Anomalies can occur individually or simultaneously due to defects in sensors, actuators, or plants. However, in complex industrial systems, it is sometimes not easy to accurately monitor whether a certain performance status as a system health indicator is normal (i.e., whether it is a fault or not); for example, the degree of machine wear and changes in material properties. These subtle changes may not be obvious at first, and we realize the problem only when they reach a certain level and cause system performance to degrade or fail. When monitoring multiple process parameters simultaneously, skilled operators often must make operating decisions based solely on their experience. Another reason for disorder in the behavior of dynamic plants can be changes in external influences on the system. This may be a change in both external conditions leading to a change in the dynamic characteristics of the system components and the setpoint signal being different from expected.</p><p>In the maintenance of complex systems, fault detection faces severe challenges. First of all, real-time monitoring is crucial. The system must react and handle exceptions almost instantly and is sensitive to delays. Secondly, the data sent by the sensor may contain errors, such as inaccurate measurements or random fluctuations caused by changes in the external environment, which requires the algorithm to be highly reliable and resistant to interference. Furthermore, the continuous updating and adaptability of the fault detection rules is also a challenge. Such rules are usually based on some reference model of normal system behavior and threshold settings. However, such rules (the model and thresholds) sometimes need to updated due to a possible slow shift in normal behavior. The update procedure should not require maintenance by a serviceman or an engineer, otherwise it would be too expensive and not practical.</p><p>Modern approaches to disorder detection combine machine learning [<xref rid="B2-sensors-25-01256" ref-type="bibr">2</xref>] and big data analytics, and may incorporate cloud computing and IoT technology to enable data analysis using information not available in traditional control systems. From a practical perspective, the challenge for such approaches is to process large amounts of data efficiently in real time, while identifying disorder and ensuring the reliability of the detection algorithms so that they can cope with changing conditions and new causes of abnormal behavior in dynamic plants.</p></sec><sec id="sec2-sensors-25-01256"><title>2. Background</title><p>The detection of a disorder in the behavior of dynamic plants has been an active research area for many years [<xref rid="B3-sensors-25-01256" ref-type="bibr">3</xref>,<xref rid="B4-sensors-25-01256" ref-type="bibr">4</xref>].</p><p>Algorithms for detecting disorder are usually based on real-time data. If the deviation between the plant output and the output of its reference model increases, an alarm or automatic adjustment mechanism is triggered. The simplest approach was to monitor the range of variation in the observed characteristics of the plant [<xref rid="B5-sensors-25-01256" ref-type="bibr">5</xref>]. More complex approaches, such as the cumulative sum algorithm (CUSUM), are based on detecting the deviation in the statistical characteristics of the observed process from the normal behavior specified by the stochastic model of the norm. Typically, such a model implies the specification of the type and parameters of the distribution of the normal process.</p><p>In recent years, thanks to the significant enhancements in computer performance, disorder detection techniques using machine learning have gradually emerged, such as autoencoders [<xref rid="B6-sensors-25-01256" ref-type="bibr">6</xref>,<xref rid="B7-sensors-25-01256" ref-type="bibr">7</xref>]. As a powerful tool, the autoencoder can autonomously learn the basic structure and distribution of data and then reconstruct them. So, the data samples of normal working conditions will be mapped to similar ones, while the abnormal samples will not, resulting in a large difference between input and output vectors of the autoencoder. Therefore, these points that deviate from the norm will be effectively identified. This not only improves the accuracy and reliability of anomaly detection, but also reduces the need for manual intervention, which helps to build a more intelligent and adaptive industrial monitoring system.</p><sec id="sec2dot1-sensors-25-01256"><title>2.1. Model-Based Methods</title><p>Model-based disorder detection is a widely used technology in science and engineering. Its basic principle is to provide a mathematical description or algorithm for the behavior of the main characteristics of a system. This requires the use of mathematical formalisms to analyze the key physical principles and observed dependencies, often by constructing differential equations to characterize the dynamic processes. Model-based analysis is particularly effective when designing systems with clear structures and well-defined rules, such as simple mechanical devices in mechanical engineering or linear control systems in the field of automatic control, because models are easy to create and debug.</p><p>The task of detecting faults in systems and processes is to automatically identify dependencies between measured signals and subsequently detect changes in these dependencies. Based on the measured output signals of the plant and its reference model, modeling error values, estimated values of parameters, or estimated values of state variable values called features can be calculated. Changes or deviations in the detected features compared to normal features will lead to the analysis of symptoms [<xref rid="B8-sensors-25-01256" ref-type="bibr">8</xref>,<xref rid="B9-sensors-25-01256" ref-type="bibr">9</xref>].</p><p>A typical reference model-based disorder detection scheme is shown in <xref rid="sensors-25-01256-f001" ref-type="fig">Figure 1</xref>.</p><p>This approach is based on the assumption that when the physical characteristics within the plant are slightly adjusted, the measured output signal will change accordingly. If this change deviates from the standard signal pattern estimated by the reference model, it will become obvious and can be identified as an abnormal situation. When using this approach, it is necessary to take into account that the reference model must accurately repeat the behavior of the plant itself and similarly respond to input effects on the plant.</p><p>For simple processes, model-based methods give good results. However, when dealing with complex dynamic systems, such as chemical reaction processes or systems involving a large number of variables, building an accurate reference model is often difficult or even nearly impossible. In such complex situations, detection methods that rely on building models of dynamic plants may not be applicable. Instead, a data-driven approach that does not require building accurate models of dynamic plants may be considered. Data-driven approaches are better suited for complex systems with high uncertainty because of their greater emphasis on analyzing empirical data rather than building detailed analytical mathematical models of the plant.</p></sec><sec id="sec2dot2-sensors-25-01256"><title>2.2. Data-Driven Methods</title><p>Data-driven anomaly detection, as a modern anomaly diagnosis strategy, is based on a large amount of operational data as a primary resource. Its main idea is to collect data generated by the equipment under normal operating conditions, such as temperature, vibration, current, and other measured parameters, and then use these time series to build a model. Data-based models can capture the evolution of plant performance over time and use it as the basis for distinguishing whether the plant is in normal condition.</p><p>The specific process includes data collection, pre-processing (cleaning, normalization, etc.), feature engineering (extracting key features that cause failures), and then training a model to define the normal operating mode of the plant.</p><p>When new data are fed into the model, if they significantly deviate from the known data distribution under normal operating conditions, an alarm will be triggered, indicating a potential failure. Data-driven methods such as machine learning can automatically learn patterns from observed historical data, better capture nonlinear correlations, and avoid relying on precise physical models, making them superior in dealing with nonlinear system problems.</p><p>Data-driven disorder detection technology is now widely used in various industrial processes including the chemical industry [<xref rid="B10-sensors-25-01256" ref-type="bibr">10</xref>], polymer manufacturing, microelectronics, the steel industry, pharmaceutical processes, power distribution networks [<xref rid="B11-sensors-25-01256" ref-type="bibr">11</xref>], and flow systems.</p><p>Especially in the last three decades, it has become one of the most fruitful areas of research and practice and an important tool for quality control [<xref rid="B12-sensors-25-01256" ref-type="bibr">12</xref>,<xref rid="B13-sensors-25-01256" ref-type="bibr">13</xref>].</p><sec id="sec2dot2dot1-sensors-25-01256"><title>2.2.1. Multivariate Statistical Process Control</title><p>Multivariate statistical process control in process monitoring emerged in the 1990s [<xref rid="B14-sensors-25-01256" ref-type="bibr">14</xref>]. It uses statistical models to monitor manufacturing processes in real time by extracting key information from complex datasets. For example, statistical process control charts are used to compare the current state of a process to normal operating conditions. Most commonly, control charts are used to monitor the mean or deviation of selected variables that affect a process; these include the Shewhart control chart [<xref rid="B15-sensors-25-01256" ref-type="bibr">15</xref>], the CUSUM chart [<xref rid="B16-sensors-25-01256" ref-type="bibr">16</xref>], and the EWMA chart [<xref rid="B17-sensors-25-01256" ref-type="bibr">17</xref>]. Each of the above types of control charts has its own advantages and disadvantages. The Shewhart control chart is a statistical tool based on past data fluctuations. It is designed with the assumption that samples are collected and analyzed continuously. When focusing only on existing test data, if improvements, anomalies, or slight changes in the process occur in a short period of time, the control chart may not immediately reflect these short-term changes due to the slow sample update, because it relies on historical means and standard deviations to determine the normal range. In short, control charts have a good ability to identify stable long-term trends, but they may not be sensitive enough for dynamic and fast-changing processes, especially those with frequent small adjustments. In contrast, the CUSUM and EWMA control charts are more sensitive in detecting small changes in the process because they use information from long-sequence samples. Therefore, for large-scale process failures that require an immediate response, the Shewhart control chart is an effective tool, but for continuous improvement or monitoring quality trends, other methods such as EWMA or CUSUM control charts may be needed to monitor the process in more detail. In practical applications, they are often used together to detect anomalies and evaluate process stability [<xref rid="B18-sensors-25-01256" ref-type="bibr">18</xref>].</p><p>In general, multivariate statistical methods for disorder detection use the typical Hotelling&#x02019;s <inline-formula><mml:math id="mm1" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> statistic and the Q statistic, which is also known as the squared prediction error. When the <inline-formula><mml:math id="mm2" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> value exceeds a certain threshold, it means that the data points deviate from the normal pattern, i.e., deviations from the normal plane may be observed and, thus, disorder is detected.</p><p>In the field of process control, principal component analysis (PCA) is one of the most popular statistical methods for extracting information from measured data [<xref rid="B19-sensors-25-01256" ref-type="bibr">19</xref>]. The main step of PCA is to transform the original data into a low-dimensional linear independent space and residual space by linear projection. <inline-formula><mml:math id="mm3" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> and Q statistics and their control limits are set in the corresponding space for fault detection.</p><p>However, when dealing with complex processes in fields such as industrial chemistry and biology, the use of PCA can be problematic if these processes involve significant nonlinear features such as periodic changes or adaptive responses within the system. Since the basic assumption of using PCA is that data changes are normally distributed and linearly related, its ability to detect nonlinear outliers will be weakened. For example, when outliers are generated by nonlinear relationships or the behavior of the data evolves over time rather than following a simple linear trend, a simple linear transformation of PCA may not accurately capture this outlier behavior of the system. To overcome this shortcoming, several improved PCA schemes have been proposed. For instance, a previous paper [<xref rid="B20-sensors-25-01256" ref-type="bibr">20</xref>] presented a nonlinear principal component analysis based on a five-layer neural network.</p><p>Partial least squares (PLS) is also a classic multivariate statistical analysis technique, and is used to establish a linear relationship between the input and output. By building a model based on normal data in an a priori order, PLS can be implemented in forecasting and monitoring applications. Assuming that all measurements follow a normal distribution, <inline-formula><mml:math id="mm4" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> and the Q index are adopted as statistical indicators for detecting quality and non-quality defects [<xref rid="B21-sensors-25-01256" ref-type="bibr">21</xref>]. In contrast to PCA, independent component analysis has been used for process monitoring by projecting correlated variables into an independent space without orthogonality constraints, making it more applicable to non-Gaussian processes [<xref rid="B22-sensors-25-01256" ref-type="bibr">22</xref>]. Another method for dealing with non-Gaussian processes is the Gaussian mixture model, which fits multiple Gaussian models to approximate non-Gaussian data. It has been widely used for process monitoring in arbitrary datasets that do not follow a normal distribution [<xref rid="B23-sensors-25-01256" ref-type="bibr">23</xref>,<xref rid="B24-sensors-25-01256" ref-type="bibr">24</xref>].</p></sec><sec id="sec2dot2dot2-sensors-25-01256"><title>2.2.2. Combination of Reference Model and Control Chart Approach</title><p>Model-based methods may be combined with control charts to detect disorder as a systematic difference between the plant and reference model behavior (<xref rid="sensors-25-01256-f001" ref-type="fig">Figure 1</xref>). Assuming a stochastic input signal, the difference between plant output and the expected behavior predicted by the reference model may be observed as an increase in the variance of the error <inline-formula><mml:math id="mm5" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>=</mml:mo><mml:mi>y</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:math></inline-formula>, representing the discrepancy between the measured plant output <inline-formula><mml:math id="mm6" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>y</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> and the modeled output <inline-formula><mml:math id="mm7" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p>Let us collect a set of errors <inline-formula><mml:math id="mm8" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, initially assumed to follow a probability density function <inline-formula><mml:math id="mm9" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>&#x003c1;</mml:mi><mml:mo>(</mml:mo><mml:mi>d</mml:mi><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. When a disorder occurs at some unknown moment, these errors would then follow a different distribution characterized by another probability density function <inline-formula><mml:math id="mm10" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>&#x003c1;</mml:mi><mml:mo>(</mml:mo><mml:mi>d</mml:mi><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p>When running a one-sided CUSUM control chart to identify process disorders, the statistics <inline-formula><mml:math id="mm11" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> is calculated as:<disp-formula id="FD1-sensors-25-01256"><label>(1)</label><mml:math id="mm12" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced open="{" close="" separators="|"><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mrow><mml:mi mathvariant="normal">max</mml:mi></mml:mrow><mml:mo>&#x02061;</mml:mo><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mn>0</mml:mn><mml:mo>;</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mrow><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>&#x0003e;</mml:mo><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></disp-formula>
where the term <inline-formula><mml:math id="mm13" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> denotes a statistic used to detect shifts or changes in the process variance and is defined as follows:<disp-formula id="FD2-sensors-25-01256"><label>(2)</label><mml:math id="mm14" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mstyle><mml:mi>l</mml:mi><mml:mi>n</mml:mi><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:msubsup><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:mfrac></mml:mstyle><mml:mo>&#x02212;</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:mfrac></mml:mstyle><mml:mfenced separators="|"><mml:mrow><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:mfrac></mml:mstyle><mml:mo>&#x02212;</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:mfrac></mml:mstyle></mml:mrow></mml:mfenced><mml:msubsup><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>When the cumulative sum exceeds the control limit <inline-formula><mml:math id="mm15" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>H</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>, the process is considered out of control and the disorder is detected.<disp-formula id="FD3-sensors-25-01256"><label>(3)</label><mml:math id="mm16" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>&#x0003e;</mml:mo><mml:mi>H</mml:mi></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>In this case, the elementary verification procedure concludes. If further analysis is required, the CUSUM control chart can be reapplied to the sequence <inline-formula><mml:math id="mm17" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="mm18" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> denotes the iteration index.</p><p>The one-sided exponentially weighted moving variance control chart (EWMV) is also used to detect process disorder. The EWMV statistic at the current time <inline-formula><mml:math id="mm19" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> is:<disp-formula id="FD4-sensors-25-01256"><label>(4)</label><mml:math id="mm20" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>&#x02212;</mml:mo><mml:mi>r</mml:mi></mml:mrow></mml:mfenced><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>r</mml:mi><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003bc;</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></disp-formula>
where <inline-formula><mml:math id="mm21" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is a weighting factor that governs the rate of exponential discounting of the past data, <inline-formula><mml:math id="mm22" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> represents the initial estimate of the mean squared error, and <inline-formula><mml:math id="mm23" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003bc;</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> is the estimation of the process mean at time <inline-formula><mml:math id="mm24" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> by exponentially weighted moving average (EWMA), calculated by:<disp-formula id="FD5-sensors-25-01256"><label>(5)</label><mml:math id="mm25" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003bc;</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:mn>1</mml:mn><mml:mo>&#x02212;</mml:mo><mml:mi>&#x003bb;</mml:mi></mml:mrow></mml:mfenced><mml:msub><mml:mrow><mml:mi>&#x003bc;</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mi>&#x003bb;</mml:mi><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></disp-formula>
where <inline-formula><mml:math id="mm26" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>&#x003bb;</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mo>(</mml:mo><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mn>1</mml:mn><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is a smoothing coefficient.</p><p>The current EWMV statistic should also be compared to a predefined control limit <inline-formula><mml:math id="mm27" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>H</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>. Specifically, if <inline-formula><mml:math id="mm28" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>&#x0003e;</mml:mo><mml:mi>H</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>, it indicates potential disorder. The determination of the control limit (threshold) <inline-formula><mml:math id="mm29" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>H</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> for control charts generally depends on empirical experience and involves balancing the true detection rate with the false alarm rate.</p></sec><sec id="sec2dot2dot3-sensors-25-01256"><title>2.2.3. Machine Learning-Based Approach</title><p>Machine learning models can automatically extract features and learn complex patterns from large amounts of data without manually developing complex hypotheses or hypothesis distributions. This is especially effective when dealing with nonlinear and non-Gaussian distributed data. Some machine learning methods, such as support vector machines or artificial neural networks, have a certain noise resistance and the ability to handle isolated points. In recent years, there has been a growing interest in the application of artificial neural networks in fault detection and diagnostic systems [<xref rid="B25-sensors-25-01256" ref-type="bibr">25</xref>,<xref rid="B26-sensors-25-01256" ref-type="bibr">26</xref>,<xref rid="B27-sensors-25-01256" ref-type="bibr">27</xref>].</p><p>The neural network replaces the analytical model describing the process under normal operating conditions. It must be trained to perform this task, and the training data can be collected directly from the process or from a simulation model that is as realistic as possible. Once the training is complete, the neural network can generate residuals that indicate anomalies. For example, a previous paper [<xref rid="B28-sensors-25-01256" ref-type="bibr">28</xref>] described using the residuals between the output of a plant and its neural network model to detect anomalies in a real sugar evaporation process.</p><p>However, it is necessary to consider dynamics when modeling dynamic plants in automatic control systems using neural networks or detecting disorder in the behavior of a plant. In order to be able to record the dynamic behavior of the system, the neural network must have dynamic characteristics, such as recurrent neural networks. A previous paper [<xref rid="B29-sensors-25-01256" ref-type="bibr">29</xref>] discusses a method for online detection of sensor disorder in substations based on a long-term short-term memory network and an adaptive threshold selection algorithm.</p><p>Using only a single fault detection algorithm may lead to false positive problems. In order to improve the accuracy and stability of detection, a common approach is to integrate multiple technical means, such as combining statistical analysis and machine learning methods. Such a comprehensive strategy can complement the advantages of each method, reduce the possibility of errors, and enhance the credibility of the final result.</p><p>A previous paper [<xref rid="B30-sensors-25-01256" ref-type="bibr">30</xref>] proposed a process monitoring method using Gaussian mixture model and weighted kernel-independent component analysis, in which the Gaussian mixture model is used to estimate the probability of kernel-independent components, and the important kernel-independent components that dominate the process change are given a higher weight according to the estimated probability of collecting important information in the online disorder detection process.</p><p>Another paper [<xref rid="B31-sensors-25-01256" ref-type="bibr">31</xref>] adopted a method using automatic noise accumulation coding and a K nearest neighbor (KNN) rule. An autoencoder with multi-level noise reduction is used to model nonlinear process data and automatically extract important features. The original nonlinear space is then mapped to the feature space and residual space using the multi-level denoising autoencoder. Two new statistics for detecting disorder in the above spaces are constructed by introducing a KNN rule with corresponding control limits determined by the kernel density estimation.</p><p>Although machine learning has shown great potential in the field of disorder detection, it still faces some challenges. In an industrial environment, continuous evolutionary processes may occur, such as equipment aging and changing failure modes. It can be difficult for traditional static anomaly detection methods to account for these changes. In addition, anomalies are often not a single pattern, but contain noise and unknown variables. If a model relies too heavily on a known data distribution, it may fail when it encounters new anomalies that were not previously noticed.</p><p>The main idea of this work is the use of the cross-correlation function (CCF) between the input and output of the plant as a characteristic of its nonlinear dynamics, combined with a neural network autoencoder, which helps detect when the plant operation shifts to a new pattern and when anomalies occur compared to the reference period of system operation. The proposed method does not rely on external reference signals, but directly analyzes real-time data from nonlinear dynamic systems, which can respond more quickly to real-time changes within the monitored plant. In addition, the autoencoder can dynamically learn the normal distribution of the data during the training process, thereby avoiding the subjectivity and variability caused by manual threshold setting.</p><p>This idea was developed by the authors earlier and was applied to tasks of operating mode change detection [<xref rid="B32-sensors-25-01256" ref-type="bibr">32</xref>], disorder detection for linear ARMA and nonlinear AR dynamic processes [<xref rid="B33-sensors-25-01256" ref-type="bibr">33</xref>], and quality control of an autonomous neural network dynamic model [<xref rid="B34-sensors-25-01256" ref-type="bibr">34</xref>]. In this study, we extend the application of the CCF and neural network autoencoder approach to solving the problem of detecting disorder of a nonlinear dynamic object defined by a mathematical model.</p><p>For comparison, we conducted experiments using the proposed method, the CUSUM control chart, and the EWMV control chart to detect disorder in the behavior of the same plant.</p></sec></sec></sec><sec id="sec3-sensors-25-01256"><title>3. Method</title><sec id="sec3dot1-sensors-25-01256"><title>3.1. Cross-Correlation Functions as Characteristics of a Dynamic System</title><p>The cross-correlation function (CCF) is a statistical measure that quantifies the similarity between two signals as they change over time. In dynamic systems, any change in the operational state&#x02014;whether caused by internal hardware variations or external disturbances&#x02014;can impact the CCF between the input and output signals. Such impacts often appear as shifts in correlation peaks, variations in amplitude, or irregular waveform distortions. Therefore, by regularly monitoring the CCF between inputs and outputs, one can observe and remember how the dynamic system behaves under different operating conditions [<xref rid="B34-sensors-25-01256" ref-type="bibr">34</xref>].</p><p>For each successive time step <italic toggle="yes">t</italic> of the control system, the CCF between the input <inline-formula><mml:math id="mm30" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and the corresponding output <inline-formula><mml:math id="mm31" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is given as follows:<disp-formula id="FD6-sensors-25-01256"><label>(6)</label><mml:math id="mm32" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mrow><mml:msubsup><mml:mo stretchy="false">&#x0222b;</mml:mo><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mo>&#x0221e;</mml:mo></mml:mrow><mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:mrow></mml:msubsup><mml:mrow><mml:mi>u</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced><mml:mi>y</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:mfenced><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>
where <inline-formula><mml:math id="mm33" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> is a shift distance variable between the input and the output.</p><p>The discrete sampling of continuous signals <italic toggle="yes">u</italic>(<italic toggle="yes">t</italic>) and <italic toggle="yes">y</italic>(<italic toggle="yes">t</italic>) is denoted as <italic toggle="yes">u</italic>(<italic toggle="yes">n</italic>) and <italic toggle="yes">y</italic>(<italic toggle="yes">n</italic>), respectively (where <inline-formula><mml:math id="mm34" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:mi>n</mml:mi><mml:mo>&#x00394;</mml:mo><mml:mi mathvariant="normal">t</mml:mi><mml:mo>,</mml:mo><mml:mi>n</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="double-struck">Z</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>). Over a finite time interval of width <italic toggle="yes">d</italic>, the cross-correlation function at the <inline-formula><mml:math id="mm35" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>-th time interval of the input and output time series is calculated as:<disp-formula id="FD7-sensors-25-01256"><label>(7)</label><mml:math id="mm36" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mi>&#x003c4;</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:mfrac></mml:mstyle><mml:mrow><mml:munderover><mml:mo stretchy="false">&#x02211;</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mi>d</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:munderover><mml:mrow><mml:mi>u</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mi>y</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mi>&#x003c4;</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>
where <inline-formula><mml:math id="mm37" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>&#x003c4;</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mi mathvariant="double-struck">Z</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> represents the argument of the CCF. The CCF of the <inline-formula><mml:math id="mm38" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>-th time interval can be represented as a vector <inline-formula><mml:math id="mm39" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">R</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mfenced open="[" close="]" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mi>d</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mi>d</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi mathvariant="normal">T</mml:mi></mml:mrow></mml:msup><mml:mo>&#x02208;</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>d</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p>The set of CCF vectors describes the behavior of the dynamic system in response to the input signal over a specified time period. During normal system operation, the CCF vectors calculated at various time intervals form a point cloud within a specific spatial region. <xref rid="sensors-25-01256-f002" ref-type="fig">Figure 2</xref> shows an example of such a region in three-dimensional space, denoted as <inline-formula><mml:math id="mm40" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">R</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula>, where the superscript <inline-formula><mml:math id="mm41" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> means &#x0201c;normal&#x0201d;, reflecting typical operational conditions.</p><p>When the input deviates from the normal input within the <inline-formula><mml:math id="mm42" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">R</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> region, the values in the CCF vector will also change accordingly. Assume that the system&#x02019;s dynamic response at time <inline-formula><mml:math id="mm43" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> is represented by the point <inline-formula><mml:math id="mm44" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">R</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula>, which belongs to the normal region <inline-formula><mml:math id="mm45" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">R</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula>. Consequently, if the dynamic response changes at some later moment (<inline-formula><mml:math id="mm46" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>q</mml:mi><mml:mo>&#x0003e;</mml:mo><mml:mi>p</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>), the new CCF will be denoted by the point <inline-formula><mml:math id="mm47" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">R</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>q</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula>, as shown in <xref rid="sensors-25-01256-f002" ref-type="fig">Figure 2</xref>.</p><p>A drift <inline-formula><mml:math id="mm48" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">R</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>p</mml:mi></mml:mrow></mml:msubsup><mml:mo>&#x02192;</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">R</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>q</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> detected in the CCF vector space outside the region <inline-formula><mml:math id="mm49" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">R</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>N</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> representing the normal behavior of the system means that at time <inline-formula><mml:math id="mm50" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>q</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>, either a change in the input signal or a modification in the properties of the dynamic system has occurred. We call this phenomenon disorder.</p></sec><sec id="sec3dot2-sensors-25-01256"><title>3.2. Disorder Detection Using Neural Network Autoencoder</title><p>In order to use the cross-correlation function (CCF) as a characteristic representation for detecting disorders in a dynamic system, two problems need to be solved. One is how to effectively store and retain the CCF calculated during normal system operation as a reference pattern, and the other is how to quantify the discrepancies between the current calculated cross-correlation function and their corresponding reference patterns.</p><p>For this, we used a neural network autoencoder capable of encoding and reconstructing the CCF vectors. The autoencoder (AE) learns the representation of data in an unsupervised manner by utilizing vectors (<inline-formula><mml:math id="mm51" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">R</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="mm52" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mo>[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mi>M</mml:mi><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>) calculated from the input and output sequences during an interval of the system&#x02019;s normal operation. The autoencoder aims to map each sample within this dataset into a hidden space, with the objective that this hidden space encoding can accurately reconstruct the original CCF vector.</p><p>The autoencoder primarily comprises an encoder and a decoder, as shown in <xref rid="sensors-25-01256-f003" ref-type="fig">Figure 3</xref>. The encoder <inline-formula><mml:math id="mm53" overflow="scroll"><mml:mrow><mml:mrow><mml:mi mathvariant="bold">z</mml:mi><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">W</mml:mi></mml:mrow><mml:mrow><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msub><mml:mi>x</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mrow><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></inline-formula> compresses the set of CCF vectors into a compact, low-dimensional representation known as the code vector. The decoder <inline-formula><mml:math id="mm54" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">W</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msub><mml:mi mathvariant="bold">z</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> then aims to reconstruct the original CCF vectors from this compressed representation by applying the inverse transformation:<disp-formula id="FD8-sensors-25-01256"><label>(8)</label><mml:math id="mm55" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover><mml:mo>=</mml:mo><mml:mi>A</mml:mi><mml:mi>E</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">W</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msub><mml:mi mathvariant="bold">z</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>
where <inline-formula><mml:math id="mm56" overflow="scroll"><mml:mrow><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> is the vector CCF, <inline-formula><mml:math id="mm57" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">W</mml:mi></mml:mrow><mml:mrow><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="mm58" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">W</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> are weight matrices, and <inline-formula><mml:math id="mm59" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mrow><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="mm60" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mi>e</mml:mi><mml:mi>c</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> are bias terms for the encoder and decoder, respectively.</p><p>In our study, the learning objective of the autoencoder is to minimize the loss <italic toggle="yes">E</italic>. After training, the autoencoder acquires the ability to model the distribution patterns inherent in the CCF vectors computed during normal operation periods of a dynamic system.<disp-formula id="FD9-sensors-25-01256"><label>(9)</label><mml:math id="mm61" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>E</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:msubsup><mml:mo stretchy="false">&#x02211;</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>M</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:msup><mml:mrow><mml:mfenced open="&#x02016;" close="&#x02016;" separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>
where <inline-formula><mml:math id="mm62" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> is the vector of the k-th CCF vector and <inline-formula><mml:math id="mm63" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> is its reconstruction, and <inline-formula><mml:math id="mm64" overflow="scroll"><mml:mrow><mml:mrow><mml:mfenced open="&#x02016;" close="&#x02016;" separators="|"><mml:mrow><mml:mi>z</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:msubsup><mml:mo stretchy="false">&#x02211;</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>M</mml:mi></mml:mrow></mml:msubsup><mml:mrow><mml:msubsup><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:msqrt></mml:mrow></mml:mrow></mml:math></inline-formula> is usual Euclidean length.</p><p>When a new CCF vector is fed into the autoencoder, if the output of the decoder closely approximates to the input, this indicates that the system functions normally within the corresponding time interval as represented by the CCF vector. Conversely, if the reconstructed data from the autoencoder differs significantly from the input&#x02014;specifically when the reconstruction error <inline-formula><mml:math id="mm65" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>r</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> exceeds a predefined threshold <inline-formula><mml:math id="mm66" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>&#x02014;it suggests disorders in the system during that period.<disp-formula id="FD10-sensors-25-01256"><label>(10)</label><mml:math id="mm67" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mfenced open="&#x02016;" close="&#x02016;" separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></disp-formula></p></sec><sec id="sec3dot3-sensors-25-01256"><title>3.3. Development and Application of a Disorder Detector</title><p>In this section, we detail the development process and application methods of the disorder detector.</p><p><xref rid="sensors-25-01256-f004" ref-type="fig">Figure 4</xref> shows the scheme for synthesizing an autoencoder-based disorder detector, and its steps are as follows:</p><p><italic toggle="yes">Step 1</italic>: Data preparation. Let us collect a discrete time series of length <inline-formula><mml:math id="mm68" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> from both the input <inline-formula><mml:math id="mm69" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x02264;</mml:mo><mml:mi>l</mml:mi><mml:mo>&#x02264;</mml:mo><mml:mi>L</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> and the output <inline-formula><mml:math id="mm70" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></inline-formula> generated by a normally functioning dynamic system, and select <inline-formula><mml:math id="mm71" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> to be proportional to <inline-formula><mml:math id="mm72" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>, which represents the width of the cross-correlation function (CCF) calculation window. Also, let us split the entire time series <inline-formula><mml:math id="mm73" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="mm74" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>l</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></inline-formula> into segments of length <inline-formula><mml:math id="mm75" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>. Specifically, for each segment (or window) indexed by <italic toggle="yes">k</italic>:</p><list list-type="bullet"><list-item><p>Input vector: <inline-formula><mml:math id="mm76" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">u</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo>[</mml:mo><mml:mi>u</mml:mi><mml:mo>(</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mi>d</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>)</mml:mo><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:mi>u</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:mfenced><mml:mo>]</mml:mo></mml:mrow><mml:mrow><mml:mi mathvariant="normal">T</mml:mi></mml:mrow></mml:msup><mml:mo>&#x02208;</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x02264;</mml:mo><mml:mi>k</mml:mi><mml:mo>&#x02264;</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:mfrac></mml:mstyle></mml:mrow></mml:mrow></mml:math></inline-formula></p></list-item><list-item><p>Output vector: <inline-formula><mml:math id="mm77" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">y</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mfenced open="[" close="]" separators="|"><mml:mrow><mml:mi>u</mml:mi><mml:mo>(</mml:mo><mml:mfenced separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mi>d</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi mathvariant="normal">T</mml:mi></mml:mrow></mml:msup><mml:mo>&#x02208;</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x02264;</mml:mo><mml:mi>k</mml:mi><mml:mo>&#x02264;</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:mfrac></mml:mstyle></mml:mrow></mml:mrow></mml:math></inline-formula>.</p></list-item></list><p><italic toggle="yes">Step 2</italic>: Calculation of CCF. Let us calculate CCF using Equation (7) with the vectors <inline-formula><mml:math id="mm78" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">u</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="mm79" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">y</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> and obtain a sequence of CCF vectors <inline-formula><mml:math id="mm80" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">R</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> describing the reference (normal) behavior of the dynamic system.</p><p><italic toggle="yes">Step 3</italic>: Training of an autoencoder. The training dataset <inline-formula><mml:math id="mm81" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> of the autoencoder is a set of CCF vectors <inline-formula><mml:math id="mm82" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">R</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula>, which characterize the normal behavior of the dynamic system. Let us train the autoencoder on dataset <inline-formula><mml:math id="mm83" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> with the objective of minimizing the loss function <italic toggle="yes">E</italic> through error backpropagation or a similar optimization technique, aiming to obtain the optimal reconstructed <inline-formula><mml:math id="mm84" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:mi>A</mml:mi><mml:mi>E</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></inline-formula>. The trained autoencoder provides a smaller error for CCF vectors for those closer to the original and a larger error for those that deviate more significantly.</p><p><italic toggle="yes">Step 4</italic>: Determination of a threshold. To detect the deviations of CCF from its normal state, it is necessary to setup a threshold for the reconstruction error. Let us define the trigger threshold <inline-formula><mml:math id="mm85" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> as the maximum of the reconstruction error <inline-formula><mml:math id="mm86" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mrow><mml:munder><mml:mrow><mml:mi mathvariant="normal">max </mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:munder></mml:mrow><mml:mo>&#x02061;</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:math></inline-formula> obtained during training. If the reconstruction error exceeds <inline-formula><mml:math id="mm87" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, it indicates that the CCF deviates significantly from the expected pattern.</p><p>For convenience, we call the synthetized detector CCF-AE and apply it to detect whether the system <inline-formula><mml:math id="mm88" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mo>(</mml:mo><mml:mo>&#x022c5;</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> has dynamic disorder. The detection scheme is shown in <xref rid="sensors-25-01256-f005" ref-type="fig">Figure 5</xref> and consists of the following 4 steps:</p><p><italic toggle="yes">Step 1</italic>: Collect a time series of consecutive input values <inline-formula><mml:math id="mm89" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mi>d</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:mi>u</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></inline-formula> and output values <inline-formula><mml:math id="mm90" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mi>d</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></inline-formula> at the time sample <inline-formula><mml:math id="mm91" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="mm92" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> is the width of the window to calculate CCF and <inline-formula><mml:math id="mm93" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> is an index of the window. Let us arrange them into vectors <inline-formula><mml:math id="mm94" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">u</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo>[</mml:mo><mml:mi>u</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mi>d</mml:mi></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:mi>u</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:mfenced><mml:mo>]</mml:mo></mml:mrow><mml:mrow><mml:mi mathvariant="normal">T</mml:mi></mml:mrow></mml:msup><mml:mo>&#x02208;</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="mm95" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">y</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mfenced open="[" close="]" separators="|"><mml:mrow><mml:mi>y</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mfenced separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mi>d</mml:mi></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>k</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi mathvariant="normal">T</mml:mi></mml:mrow></mml:msup><mml:mo>&#x02208;</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p><italic toggle="yes">Step 2</italic>: Calculate the CCF using Equation (7) with vectors <inline-formula><mml:math id="mm96" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">u</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="mm97" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">y</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>, obtaining the vector <inline-formula><mml:math id="mm98" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">R</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p><italic toggle="yes">Step 3</italic>: Calculate the reconstructed CCF <inline-formula><mml:math id="mm99" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">x</mml:mi></mml:mrow><mml:mo>~</mml:mo></mml:mover><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> using Equation (8). Then, substitute the results of Equations (7) and (8) into Equation (10) to calculate the reconstruction error <inline-formula><mml:math id="mm100" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p><italic toggle="yes">Step 4</italic>: Compare the reconstruction error <inline-formula><mml:math id="mm101" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> with the threshold <inline-formula><mml:math id="mm102" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. If <inline-formula><mml:math id="mm103" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>r</mml:mi><mml:mo>(</mml:mo><mml:mi>k</mml:mi><mml:mo>)</mml:mo><mml:mo>&#x02264;</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, it indicates that the dynamic characteristics of the system are still within a controllable range, consistent with the behavior patterns previously learned and memorized by the autoencoder, Otherwise, it suggests that there is disorder in the system <inline-formula><mml:math id="mm104" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>g</mml:mi><mml:mo>(</mml:mo><mml:mo>&#x022c5;</mml:mo><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> in the <inline-formula><mml:math id="mm105" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>th time interval of duration <italic toggle="yes">d</italic>.</p><p>In summary, the dynamic characteristics represented by the CCF vector <inline-formula><mml:math id="mm106" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">R</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> are used as input data for the autoencoder to obtain the reconstruction error for assessing the behavior of the dynamic system, which allows identifying and localizing disturbances in the dynamic system.</p><p>Let us evaluate the proposed method for a real-world nonlinear dynamic plant&#x02014;a mathematical model of the pH neutralization reaction process.</p></sec></sec><sec id="sec4-sensors-25-01256"><title>4. Case Study: pH Neutralization Process</title><sec id="sec4dot1-sensors-25-01256"><title>4.1. Mathematical Model of a pH Neutralization Reactor</title><p>Consider a one-dimensional pH neutralization reactor in a control system, where complex mixing processes between acidic and alkaline liquids occur. These processes vary significantly over time and under different conditions, involving a series of nonlinear chemical reactions that lead to complex and potentially unpredictable system dynamics. The pH neutralization process described by Hall and Seborg (1989) was used as a simulation platform [<xref rid="B35-sensors-25-01256" ref-type="bibr">35</xref>], as illustrated in <xref rid="sensors-25-01256-f006" ref-type="fig">Figure 6</xref>. The inputs to the neutralization reactor include the base stream (<inline-formula><mml:math id="mm107" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>), acid stream (<inline-formula><mml:math id="mm108" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>), and buffer stream (<inline-formula><mml:math id="mm109" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>). The measured output (<italic toggle="yes">y</italic>) from the neutralization reactor is the pH of the effluent solution. The controller regulates the flow of alkali into the tank by adjusting the opening degree of the valve based on the specified target pH value, thereby controlling the reagent mixing rate via the control signal <inline-formula><mml:math id="mm110" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. The buffer stream (<inline-formula><mml:math id="mm111" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>), acid stream (<inline-formula><mml:math id="mm112" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>), and tank volume are assumed to remain constant during this process.</p><p>The dynamic model for the reaction invariants of the outgoing solution <inline-formula><mml:math id="mm113" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> in state-space form is given by the following expression:<disp-formula id="FD11-sensors-25-01256"><label>(11)</label><mml:math id="mm114" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mo>&#x002d9;</mml:mo></mml:mover><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mi>u</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mi>d</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:mrow></mml:math></disp-formula><disp-formula id="FD12-sensors-25-01256"><label>(12)</label><mml:math id="mm115" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>F</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mrow></mml:math></disp-formula><disp-formula id="FD13-sensors-25-01256"><label>(13)</label><mml:math id="mm116" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>x</mml:mi><mml:mo>&#x0225c;</mml:mo><mml:msup><mml:mrow><mml:mfenced open="[" close="]" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi mathvariant="normal">T</mml:mi></mml:mrow></mml:msup><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mfenced open="[" close="]" separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi mathvariant="normal">T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></disp-formula><disp-formula id="FD14-sensors-25-01256"><label>(14)</label><mml:math id="mm117" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mfenced open="[" close="]" separators="|"><mml:mrow><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfrac></mml:mstyle><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfrac></mml:mstyle><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi mathvariant="normal">T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></disp-formula><disp-formula id="FD15-sensors-25-01256"><label>(15)</label><mml:math id="mm118" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mfenced open="[" close="]" separators="|"><mml:mrow><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfrac></mml:mstyle><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfrac></mml:mstyle><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi mathvariant="normal">T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></disp-formula><disp-formula id="FD16-sensors-25-01256"><label>(16)</label><mml:math id="mm119" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mfenced open="[" close="]" separators="|"><mml:mrow><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfrac></mml:mstyle><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mfrac></mml:mstyle><mml:mfenced separators="|"><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi mathvariant="normal">T</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></disp-formula><disp-formula id="FD17-sensors-25-01256"><label>(17)</label><mml:math id="mm120" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>F</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced><mml:mo>&#x02212;</mml:mo><mml:mn>14</mml:mn></mml:mrow></mml:msup><mml:mo>&#x02212;</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mi>y</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:mn>2</mml:mn><mml:mo>&#x000d7;</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msup></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>&#x02212;</mml:mo><mml:mi>y</mml:mi><mml:mo>(</mml:mo><mml:mi>t</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>t</mml:mi></mml:mrow></mml:mfenced><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msup></mml:mrow></mml:mfrac></mml:mstyle></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>Equations (11) and (12) were solved using the Runge&#x02013;Kutta method 45. The state variables <inline-formula><mml:math id="mm121" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="mm122" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> are the response invariants. Model parameters are provided in <xref rid="sensors-25-01256-t001" ref-type="table">Table 1</xref>, while the nominal operating point is detailed in <xref rid="sensors-25-01256-t002" ref-type="table">Table 2</xref>.</p></sec><sec id="sec4dot2-sensors-25-01256"><title>4.2. Simulation Modeling of the pH Neutralization Reactor</title><p>To simulate the behavior of the pH neutralization, the model proposed by [<xref rid="B35-sensors-25-01256" ref-type="bibr">35</xref>] was implemented in the SimInTech (version 2.24.1.26) software [<xref rid="B36-sensors-25-01256" ref-type="bibr">36</xref>], which is an analog to MATLAB/Simulink 2024a. <xref rid="sensors-25-01256-f007" ref-type="fig">Figure 7</xref> shows the schema of the model simulation.</p><p>To obtain the process behavior in a given range of operating conditions, an amplitude-modulated pseudo-random signal (APRBS) was used as an input control signal. Real-world noise was simulated by adding Gaussian white noise to the output, with a signal-to-noise ratio of 60. The number of sampling steps was 26. The disturbance was simulated by the additional sinusoidal input signal with an amplitude of 2 and a frequency of <inline-formula><mml:math id="mm123" overflow="scroll"><mml:mrow><mml:mrow><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mn>0.2</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi></mml:mrow></mml:mfrac></mml:mstyle></mml:mrow></mml:mrow></mml:math></inline-formula> in a time interval from the 3001st to the 4154th sample. The process input was confined to the range <inline-formula><mml:math id="mm124" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mo>[</mml:mo><mml:mn>12.5</mml:mn><mml:mo>,</mml:mo><mml:mn>17</mml:mn><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, while the output pH value was restricted to the range <inline-formula><mml:math id="mm125" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mo>[</mml:mo><mml:mn>6,9</mml:mn><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p>An example of the input and output time series of the pH neutralization reactor produced by the model (<xref rid="sensors-25-01256-f007" ref-type="fig">Figure 7</xref>) is represented in <xref rid="sensors-25-01256-f008" ref-type="fig">Figure 8</xref>.</p></sec><sec sec-type="methods" id="sec4dot3-sensors-25-01256"><title>4.3. Methodology of Comparative Experiments</title><sec id="sec4dot3dot1-sensors-25-01256"><title>4.3.1. Competing Methods</title><p>To demonstrate the effectiveness of the proposed CCF-AE method in action and to compare its performance with existing approaches, several experiments were performed. For a competition with the proposed CCF-AE method, two well-known disorder detection methods were considered: the cumulative sum control chart (CUSUM) for the variance of the error and the exponentially weighted moving variance control chart (EWMV). Their algorithms are represented on <xref rid="sensors-25-01256-f009" ref-type="fig">Figure 9</xref>.</p></sec><sec id="sec4dot3dot2-sensors-25-01256"><title>4.3.2. Quality Indicators</title><p>The determination of the control limit (threshold) <inline-formula><mml:math id="mm126" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>H</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> often involves a trade-off between the false alarm rate <inline-formula><mml:math id="mm127" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">R</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">F</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and true detection rate <inline-formula><mml:math id="mm128" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">R</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">D</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. Let us consider them as metrics to evaluate the performance of a disorder detection method:<disp-formula id="FD18-sensors-25-01256"><label>(18)</label><mml:math id="mm129" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">R</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">F</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mi>F</mml:mi><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>F</mml:mi><mml:mi>P</mml:mi><mml:mo>+</mml:mo><mml:mi>T</mml:mi><mml:mi>N</mml:mi></mml:mrow></mml:mfrac></mml:mstyle></mml:mrow></mml:mrow></mml:math></disp-formula><disp-formula id="FD19-sensors-25-01256"><label>(19)</label><mml:math id="mm130" display="block" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">R</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">D</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mstyle scriptlevel="0" displaystyle="true"><mml:mfrac><mml:mrow><mml:mi>T</mml:mi><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>P</mml:mi><mml:mo>+</mml:mo><mml:mi>F</mml:mi><mml:mi>N</mml:mi></mml:mrow></mml:mfrac></mml:mstyle></mml:mrow></mml:mrow></mml:math></disp-formula>
where <inline-formula><mml:math id="mm131" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>&#x02014;data sample correctly labeled as a disordered point, <inline-formula><mml:math id="mm132" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>F</mml:mi><mml:mi>N</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>&#x02014;disordered points that are mistakenly labeled as normal, <inline-formula><mml:math id="mm133" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>F</mml:mi><mml:mi>P</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>&#x02014;normal data that are incorrectly labeled as disordered, <inline-formula><mml:math id="mm134" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>T</mml:mi><mml:mi>N</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>&#x02014;data correctly labeled as normal.</p><p><inline-formula><mml:math id="mm135" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">R</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">F</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> is the probability that the system issues an alarm but no disorder actually occurs. <inline-formula><mml:math id="mm136" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">R</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">D</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> is the probability that the system successfully triggers an alarm when a disorder occurs. A higher threshold will reduce <inline-formula><mml:math id="mm137" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">R</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">F</mml:mi><mml:mi mathvariant="normal">A</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, but may also reduce <inline-formula><mml:math id="mm138" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">R</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">D</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. A lower threshold will increase <inline-formula><mml:math id="mm139" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">R</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">D</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> but may cause higher false alarms.</p><p>In addition, the choice of threshold also affects the time of average alarm&#x02019;s delay <inline-formula><mml:math id="mm140" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> and the mean time between false alarms <inline-formula><mml:math id="mm141" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mi>f</mml:mi><mml:mi>a</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>.</p></sec><sec id="sec4dot3dot3-sensors-25-01256"><title>4.3.3. CUSUM Control Chart Implementation</title><p>To implement a CUSUM control chart for disorder detection, sufficient samples <italic toggle="yes">d</italic> must be collected to estimate <inline-formula><mml:math id="mm142" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="mm143" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula>. Additionally, an appropriate threshold <inline-formula><mml:math id="mm144" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>H</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula> should be determined to ensure that the quality indicators meet acceptable standards.</p><p>The steps to run the CUSUM control chart are as follows:</p><p><italic toggle="yes">Step 1</italic>: Collect data. Gather the output error <inline-formula><mml:math id="mm145" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> between the plant and its reference model.</p><p><italic toggle="yes">Step 2</italic>: Initialize cumulative sum. Initialize the cumulative sum statistics <inline-formula><mml:math id="mm146" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p><italic toggle="yes">Step 3</italic>: Calculate <inline-formula><mml:math id="mm147" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. Calculate the <inline-formula><mml:math id="mm148" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>z</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> at each moment and add it to the sum of all previous <inline-formula><mml:math id="mm149" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p><italic toggle="yes">Step 4</italic>: Determine whether the threshold has been crossed. When the cumulative sum exceeds the threshold <inline-formula><mml:math id="mm150" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>H</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>, it is considered a disorder.</p><p><italic toggle="yes">Step 5</italic>: Monitoring and alarming. Keep monitoring the changes in the cumulative sums. Once the <inline-formula><mml:math id="mm151" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> exceeds the threshold, an alarm is triggered and that point is recorded as the start time of the disorder. Then reset the cumulative sum back to zero and the entire process is restarted to continue monitoring the process.</p></sec><sec id="sec4dot3dot4-sensors-25-01256"><title>4.3.4. EWMV Control Chart Implementation</title><p>The steps to run the EWMV control chart are as follows:</p><p><italic toggle="yes">Step 1</italic>: Collect data. Gather the output error <inline-formula><mml:math id="mm152" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> between the plant and its reference model.</p><p><italic toggle="yes">Step 2</italic>: Initialize EWMV. Initialize the EWMV <inline-formula><mml:math id="mm153" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula>. Initialize coefficients <italic toggle="yes">r</italic> and <inline-formula><mml:math id="mm154" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>&#x003bb;</mml:mi></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p><italic toggle="yes">Step 3</italic>: Calculate <inline-formula><mml:math id="mm155" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. Calculate <inline-formula><mml:math id="mm156" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003bc;</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> at each moment and add it to the sum of all previous <inline-formula><mml:math id="mm157" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> after multiplying it by weight <italic toggle="yes">r</italic>.</p><p><italic toggle="yes">Step 4</italic>: Determine whether the threshold has been crossed. When <inline-formula><mml:math id="mm158" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> exceeds the threshold <italic toggle="yes">H</italic>, it is considered a disorder.</p><p><italic toggle="yes">Step 5</italic>: Monitoring and alarming. Keep monitoring the changes in the cumulative sums. Once <inline-formula><mml:math id="mm159" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> exceeds the threshold, an alarm is triggered and that point is recorded as the start time of the disorder. Then reset <inline-formula><mml:math id="mm160" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>Q</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula> back to zero and the entire process is restarted to continue monitoring the process.</p></sec></sec></sec><sec id="sec5-sensors-25-01256"><title>5. Case Study Experiments</title><sec id="sec5dot1-sensors-25-01256"><title>5.1. The Reference Model Synthesis and Evaluation</title><p>To apply the control chart approach for detecting disorder in a dynamic system, it is necessary to first create its reference model. Given the nonlinear characteristics of the pH neutralization reactor, we used the GRU neural network.</p><p>The GRU network has an input <inline-formula><mml:math id="mm161" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, a layer with nine GRU units, a fully connected layer with 15 neurons, and a regression layer to construct the output <inline-formula><mml:math id="mm162" overflow="scroll"><mml:mrow><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. The total length of the training dataset is 10,000. The training lasted 400 epochs. The result of using GRU to model the neutralization reaction is <inline-formula><mml:math id="mm163" overflow="scroll"><mml:mrow><mml:mrow><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">M</mml:mi><mml:mi mathvariant="normal">S</mml:mi><mml:mi mathvariant="normal">E</mml:mi><mml:mo>=</mml:mo><mml:mn>0.25</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p><xref rid="sensors-25-01256-f010" ref-type="fig">Figure 10</xref> shows both the actual plant output <inline-formula><mml:math id="mm164" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>y</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> and the output <inline-formula><mml:math id="mm165" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi mathvariant="normal">G</mml:mi><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">U</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> from the GRU network. <xref rid="sensors-25-01256-f011" ref-type="fig">Figure 11</xref> shows the error <inline-formula><mml:math id="mm166" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>d</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>=</mml:mo><mml:mi>y</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi mathvariant="normal">G</mml:mi><mml:mi mathvariant="normal">R</mml:mi><mml:mi mathvariant="normal">U</mml:mi></mml:mrow></mml:msub><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, which is useful for applying control charts.</p></sec><sec id="sec5dot2-sensors-25-01256"><title>5.2. Detection Using CCF-AE Algorithm</title><p>We calculate <inline-formula><mml:math id="mm167" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">R</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> with a step size of <italic toggle="yes">d</italic> = 5, and this vector represents the characteristics of the system within a time interval of length <italic toggle="yes">d</italic>.</p><p>It is appropriate to choose a time interval (window) length of 5. Increasing the window length will increase the detection time. A shorter time series corresponds to resolution loss at lower frequencies. If some important characteristics of the system are reflected in the low-frequency part, shortening the window may not enable fully obtaining the low-frequency features.</p><p><xref rid="sensors-25-01256-f012" ref-type="fig">Figure 12</xref> shows the CCF vectors <inline-formula><mml:math id="mm168" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">R</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> under both normal operating conditions and during periods of disorder. Different colors in the figure represent CCF values across various time windows. It can be seen that during disorder, the shape and amplitude of the CCF vector undergo significant changes that are enough to be detected by autoencoder.</p><p>To develop the CCF-AE detector, we collected a dataset <inline-formula><mml:math id="mm169" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>D</mml:mi><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mfenced open="{" close="}" separators="|"><mml:mrow><mml:mi>u</mml:mi><mml:mfenced separators="|"><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo>(</mml:mo><mml:mi>n</mml:mi><mml:mo>)</mml:mo></mml:mrow></mml:mfenced></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>5000</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> from the normal operation process to calculate <inline-formula><mml:math id="mm170" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">R</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="mm171" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mo>[</mml:mo><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mn>1000</mml:mn><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>. Each vector <inline-formula><mml:math id="mm172" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">R</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> was normalized and used as part of the training set for the autoencoder. The autoencoder employs a multilayer perceptron neural network architecture with 10 neurons in the hidden layer. For each time instance, the input vector <inline-formula><mml:math id="mm173" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">R</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msubsup><mml:mo>&#x02208;</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>d</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> is fed into the autoencoder, aiming to reconstruct itself at the output. Training proceeded over 300 epochs. The maximum reconstruction error observed during the training process was established as a threshold.</p><p>Next, we used the trained CCF-AE detector to detect disorder in the process. The disorder occurred at samples from 3001 to 4154. Similarly, we collected <inline-formula><mml:math id="mm174" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">u</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mo>&#x02208;</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="mm175" overflow="scroll"><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mi mathvariant="bold">y</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msup><mml:mo>&#x02208;</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>d</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula> at every <italic toggle="yes">d</italic>-time interval to calculate <inline-formula><mml:math id="mm176" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">R</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msubsup><mml:mo>&#x02208;</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>d</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup></mml:mrow></mml:mrow></mml:math></inline-formula>; the reconstruction error <italic toggle="yes">r</italic> between the reconstructed vector calculated by the autoencoder and the original <inline-formula><mml:math id="mm177" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi mathvariant="bold">R</mml:mi></mml:mrow><mml:mrow><mml:mi>u</mml:mi><mml:mi>y</mml:mi></mml:mrow><mml:mrow><mml:mi>k</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> exceeds the threshold in the 601st to 831st windows. The result converted to the time axis is shown in <xref rid="sensors-25-01256-f013" ref-type="fig">Figure 13</xref>.</p><p><xref rid="sensors-25-01256-f013" ref-type="fig">Figure 13</xref> shows that the reconstruction error <italic toggle="yes">r</italic> significantly exceeds the threshold (red dashed line) between the 3005th and 4155th samples, closely aligning with the start and end times of the disorder. Detection results yielded true positives (<italic toggle="yes">TPs</italic>) = 980, false positives (<italic toggle="yes">FPs</italic>) = 0, and false negatives (<italic toggle="yes">FNs</italic>) = 174. The calculated quality metrics are summarized in <xref rid="sensors-25-01256-t003" ref-type="table">Table 3</xref>, demonstrating that the CCF-AE detector has no false alarms and has a high <inline-formula><mml:math id="mm178" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">R</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="normal">T</mml:mi><mml:mi mathvariant="normal">D</mml:mi><mml:mi mathvariant="normal">R</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. The entire detection process required 0.4006 s. The experiments were conducted on a computer with the following specifications: CPU&#x02014;Intel Core i7-13620H; RAM&#x02014;16 Gb; SSD&#x02014;1024 Gb; graphics card&#x02014;NVIDIA GeForce RTX 4050 Laptop GPU; Operating System&#x02014;Windows 11. The device manufacturer, Lenovo, is located in Jinan, China.</p></sec><sec id="sec5dot3-sensors-25-01256"><title>5.3. Detection Using CUSUM Control Chart</title><p>For the initialization of the CUSUM control chart, the variance determined for the mode before disorder <inline-formula><mml:math id="mm179" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>0.0060</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula> should be taken, and the variance during disorder <inline-formula><mml:math id="mm180" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>3</mml:mn><mml:msubsup><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup></mml:mrow></mml:mrow></mml:math></inline-formula> should be adopted to represent the expected increase in variability. The threshold <italic toggle="yes">H</italic> = 100 was empirically determined through experimentation with historical data.</p><p><xref rid="sensors-25-01256-f014" ref-type="fig">Figure 14</xref> shows the disorder detection results using the CUSUM control chart. <italic toggle="yes">TP</italic> = 167, <italic toggle="yes">FP</italic> = 22, and <italic toggle="yes">FN</italic> = 987 were detected. The calculated quality indicators are represented in <xref rid="sensors-25-01256-t003" ref-type="table">Table 3</xref>. The entire detection process, including the calculation of the output of the reference model, took 0.2584 s.</p></sec><sec id="sec5dot4-sensors-25-01256"><title>5.4. Detection Using EWMV Control Chart</title><p>The reference model was established from prior experiments. For the exponentially weighted moving variance (EWMV) control chart, the initial parameters were derived based on pre-disorder data: variance <inline-formula><mml:math id="mm181" overflow="scroll"><mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mn>0.0048</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula> and mean <inline-formula><mml:math id="mm182" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003bc;</mml:mi></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>0.1649</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula>. The threshold <italic toggle="yes">H</italic> = 0.0008 and the coefficients <italic toggle="yes">r</italic> = 0.7, <inline-formula><mml:math id="mm183" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>&#x003bb;</mml:mi><mml:mo>=</mml:mo><mml:mn>0.8</mml:mn></mml:mrow></mml:mrow></mml:math></inline-formula> were determined through empirical analysis of historical data.</p><p><xref rid="sensors-25-01256-f015" ref-type="fig">Figure 15</xref> shows the disorder detection results using the EWMV control chart. A total of 658 true positives (TPs), 20 false positives (FPs), and 496 false negatives (FNs) were identified. The calculated quality metrics are summarized in <xref rid="sensors-25-01256-t003" ref-type="table">Table 3</xref>. The entire detection process, including the calculation of the output of the reference model, required 0.2623 s.</p></sec><sec id="sec5dot5-sensors-25-01256"><title>5.5. The Comparison of CCF-AE, CUSUM and EWMV</title><p><xref rid="sensors-25-01256-t003" ref-type="table">Table 3</xref> presents the quality metrics for the disorder detection results obtained using all three methods.</p><p>By comparing the results of all three competing methods, it can be concluded that the CCF-AE detector exhibits a higher true detection rate and a lower false alarm rate.</p></sec></sec><sec sec-type="discussion" id="sec6-sensors-25-01256"><title>6. Discussion</title><p>In this study, we propose using the input&#x02013;output cross-correlation function (CCF) as a dynamic characteristic indicator for system behavior, and combining it with the reconstruction error of the autoencoder to perform disorder detection in the process.</p><p>A significant advantage of the CCF-AE method in disorder detection is its reliance on a single input and output signal from the system, thereby eliminating the necessity to account for additional process variables.</p><p>Compared with traditional single-variable process monitoring techniques such as CUSUM and EWMV, CCF-AE has the following advantages:<list list-type="bullet"><list-item><p>Calculating the cross-correlation function and training the autoencoder are less complex compared to constructing a sufficiently accurate plant dynamic model and adjusting the parameters of the control chart.</p></list-item><list-item><p>CCF-AE is more adaptable to nonlinear systems due to directly estimating quasi-linear dynamics within the current time interval. In contrast, statistical process control methods require an accurate system model, which may demand significant computational resources.</p></list-item></list></p><p>The proposed method also has certain limitations:<list list-type="bullet"><list-item><p>A fixed detection delay of CCF-AE may increase the false alarm and missed alarm rates under highly stringent real-time requirements.</p></list-item><list-item><p>Compared with statistical process control methods, CCF-AE incurs higher computational costs, although it is well suited for modern digital microcontrollers equipped with hardware-implemented floating-point operations.</p></list-item></list></p><p>We emphasize the importance of optimizing key method parameters, specifically the cross-correlation function (CCF) window width, autoencoder neural network architecture, and error threshold. These parameters significantly influence system performance as follows:<list list-type="bullet"><list-item><p>CCF Window Width: A narrower CCF window width enhances detection sensitivity by capturing more short-term dynamic changes. Conversely, a larger window width helps smooth out signals, reducing noise interference, although at the cost of increased response latency. An appropriate window width strikes a balance between sensitivity and stability.</p></list-item><list-item><p>Autoencoder Neural Network Architecture: The number of layers, the number of nodes per layer, and the choice of activation functions in the autoencoder directly affect the model&#x02019;s learning capability and generalization ability. More complex architectures improve feature extraction but increase the risk of overfitting, diminishing the adaptability to unseen data. Striking a balance between simplicity and sufficient expressive power is essential to ensure robustness without unnecessary complexity.</p></list-item><list-item><p>Error Threshold: Setting the threshold too high leads to missed detections, while setting it too low causes frequent false alarms or misclassifications. Optimizing this threshold involves integrating insights from historical data analysis, expert domain knowledge, and specific user requirements.</p></list-item></list></p><p>In summary, the optimization of these parameters ensures that the system achieves optimal performance across various operating conditions.</p></sec><sec sec-type="conclusions" id="sec7-sensors-25-01256"><title>7. Conclusions</title><p>Considering the limitations of traditional disorder detection methods that require a reference model and some a priori knowledge about the statistical properties of signals in the system, a disorder detection method CCF-AE based on the cross-correlation function of the input&#x02013;output response of the plant and the neural network autoencoder is established.</p><p>Compared with CUSUM and EWMV control charts, the CCF-AE detector demonstrated a higher true detection rate in experimental evaluations. Additionally, CCF-AE did not generate any false alarms during the experiments, resulting in both a false alarm rate and mean time between false alarms of 0. In contrast, these quality metrics for the CUSUM and EWMV control charts were significantly greater than zero.</p><p>In addition, one key advantage of the CCF-AE method is its independence from a reference model. It solely relies on the input and output signals of the system, making it suitable for detecting disorders in nonlinear systems without involving the internal mechanisms of the plant.</p><p>While the computational complexity of the CCF-AE detector is higher than that of CUSUM and EWMV control charts, these control charts require an additional plant prediction model, which adds substantial computational overhead for training and application.</p><p>This study demonstrates the effectiveness of the CCF-AE detection technology through a representative case involving a pH neutralization reactor. This conclusion is based on a single application, which may not fully represent its performance in other scenarios. However, we have based this research on previously conducted works [<xref rid="B33-sensors-25-01256" ref-type="bibr">33</xref>,<xref rid="B34-sensors-25-01256" ref-type="bibr">34</xref>,<xref rid="B35-sensors-25-01256" ref-type="bibr">35</xref>], where we solved other similar tasks using the same approach with CCF and AE. Notably, the design of the CCF-AE detector does not depend on specific nonlinear plant dynamics models, indicating its potential generality and adaptability across various settings. Nevertheless, we acknowledge the necessity of validating its performance using more diverse datasets to comprehensively evaluate both strengths and limitations.</p><p>To further improve the quality and scope of application of the research results, two primary improvements are planned to be taken: one is to expand the scale of real-world datasets for testing; the other is to introduce more diverse data-driven technologies.</p></sec></body><back><fn-group><fn><p><bold>Disclaimer/Publisher&#x02019;s Note:</bold> The statements, opinions and data contained in all publications are solely those of the individual author(s) and contributor(s) and not of MDPI and/or the editor(s). MDPI and/or the editor(s) disclaim responsibility for any injury to people or property resulting from any ideas, methods, instructions or products referred to in the content.</p></fn></fn-group><notes><title>Author Contributions</title><p>Conceptualization, V.E.; review and editing, methodology V.E. and X.W.; software, validation, formal analysis, investigation, resources, visualization, writing&#x02014;original draft preparation X.W. All authors have read and agreed to the published version of the manuscript.</p></notes><notes><title>Institutional Review Board Statement</title><p>Not applicable.</p></notes><notes><title>Informed Consent Statement</title><p>Not applicable.</p></notes><notes notes-type="data-availability"><title>Data Availability Statement</title><p>Data will be available on request.</p></notes><notes notes-type="COI-statement"><title>Conflicts of Interest</title><p>Author Vladimir Eliseev was employed by the company InfoTeCS JSC. The remaining author declare that the research was conducted in the absence of any commercial or financial relationships that could be construed as a potential conflict of interest.</p></notes><ref-list><title>References</title><ref id="B1-sensors-25-01256"><label>1.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Bezerra</surname><given-names>C.G.</given-names></name>
<name><surname>Costa</surname><given-names>B.S.J.</given-names></name>
<name><surname>Guedes</surname><given-names>L.A.</given-names></name>
<name><surname>Angelov</surname><given-names>P.P.</given-names></name>
</person-group><article-title>An evolving approach to unsupervised and real-time fault detection in industrial processes</article-title><source>Expert Syst. Appl.</source><year>2016</year><volume>63</volume><fpage>134</fpage><lpage>144</lpage><pub-id pub-id-type="doi">10.1016/j.eswa.2016.06.035</pub-id></element-citation></ref><ref id="B2-sensors-25-01256"><label>2.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>V&#x000e1;vra</surname><given-names>J.</given-names></name>
<name><surname>Hromada</surname><given-names>M.</given-names></name>
<name><surname>Luk&#x000e1;&#x00161;</surname><given-names>L.</given-names></name>
<name><surname>Dworzecki</surname><given-names>J.</given-names></name>
</person-group><article-title>Adaptive anomaly detection system based on machine learning algorithms in an industrial control environment</article-title><source>Int. J. Crit. Infrastruct. Prot.</source><year>2021</year><volume>34</volume><fpage>100446</fpage><pub-id pub-id-type="doi">10.1016/j.ijcip.2021.100446</pub-id></element-citation></ref><ref id="B3-sensors-25-01256"><label>3.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Gao</surname><given-names>Z.</given-names></name>
<name><surname>Cecati</surname><given-names>C.</given-names></name>
<name><surname>Ding</surname><given-names>S.X.</given-names></name>
</person-group><article-title>A survey of fault diagnosis and fault-tolerant techniques&#x02014;Part I: Fault diagnosis with model-based and signal-based approaches</article-title><source>IEEE Trans. Ind. Electron.</source><year>2015</year><volume>62</volume><fpage>3757</fpage><lpage>3767</lpage><pub-id pub-id-type="doi">10.1109/TIE.2015.2417501</pub-id></element-citation></ref><ref id="B4-sensors-25-01256"><label>4.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Gao</surname><given-names>Z.</given-names></name>
<name><surname>Cecati</surname><given-names>C.</given-names></name>
<name><surname>Ding</surname><given-names>S.X.</given-names></name>
</person-group><article-title>A Survey of Fault Diagnosis and Fault-Tolerant Techniques&#x02014;Part II: Fault Diagnosis With Knowledge-Based and Hybrid/Active Approaches</article-title><source>IEEE Trans. Ind. Electron.</source><year>2015</year><volume>62</volume><fpage>3768</fpage><lpage>3774</lpage><pub-id pub-id-type="doi">10.1109/TIE.2015.2417501</pub-id></element-citation></ref><ref id="B5-sensors-25-01256"><label>5.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Tartakovsky</surname><given-names>A.G.</given-names></name>
<name><surname>Polunchenko</surname><given-names>A.S.</given-names></name>
<name><surname>Sokolov</surname><given-names>G.</given-names></name>
</person-group><article-title>Efficient Computer Network Anomaly Detection by Changepoint Detection Methods</article-title><source>IEEE J. Sel. Top. Signal Process.</source><year>2012</year><volume>7</volume><fpage>4</fpage><lpage>11</lpage><pub-id pub-id-type="doi">10.1109/JSTSP.2012.2233713</pub-id></element-citation></ref><ref id="B6-sensors-25-01256"><label>6.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Pota</surname><given-names>M.</given-names></name>
<name><surname>De Pietro</surname><given-names>G.</given-names></name>
<name><surname>Esposito</surname><given-names>M.</given-names></name>
</person-group><article-title>Real-time anomaly detection on time series of industrial furnaces: A comparison of autoencoder architectures</article-title><source>Eng. Appl. Artif. Intell.</source><year>2023</year><volume>124</volume><fpage>106597</fpage><pub-id pub-id-type="doi">10.1016/j.engappai.2023.106597</pub-id></element-citation></ref><ref id="B7-sensors-25-01256"><label>7.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Qian</surname><given-names>J.</given-names></name>
<name><surname>Song</surname><given-names>Z.</given-names></name>
<name><surname>Yao</surname><given-names>Y.</given-names></name>
<name><surname>Zhu</surname><given-names>Z.</given-names></name>
<name><surname>Zhang</surname><given-names>X.</given-names></name>
</person-group><article-title>A review on autoencoder based representation learning for fault detection and diagnosis in industrial processes</article-title><source>Chemom. Intell. Lab. Syst.</source><year>2022</year><volume>231</volume><fpage>104711</fpage><pub-id pub-id-type="doi">10.1016/j.chemolab.2022.104711</pub-id></element-citation></ref><ref id="B8-sensors-25-01256"><label>8.</label><element-citation publication-type="book"><person-group person-group-type="author">
<name><surname>Isermann</surname><given-names>R.</given-names></name>
</person-group><source>Fault-Diagnosis Applications: Model-Based Condition Monitoring: Actuators, Drives, Machinery, Plants, Sensors, and Fault-Tolerant Systems</source><publisher-name>Springer Science &#x00026; Business Media</publisher-name><publisher-loc>Berlin/Heidelberg, Germany</publisher-loc><year>2011</year></element-citation></ref><ref id="B9-sensors-25-01256"><label>9.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Xu</surname><given-names>L.</given-names></name>
<name><surname>Tseng</surname><given-names>H.E.</given-names></name>
</person-group><article-title>Robust model-based fault detection for a roll stability control system</article-title><source>IEEE Trans. Control Syst. Technol.</source><year>2007</year><volume>15</volume><fpage>519</fpage><lpage>528</lpage><pub-id pub-id-type="doi">10.1109/TCST.2006.890287</pub-id></element-citation></ref><ref id="B10-sensors-25-01256"><label>10.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Chen</surname><given-names>J.</given-names></name>
<name><surname>Liao</surname><given-names>C.M.</given-names></name>
</person-group><article-title>Dynamic process fault monitoring based on neural network and PCA</article-title><source>J. Process Control</source><year>2002</year><volume>12</volume><fpage>277</fpage><lpage>289</lpage><pub-id pub-id-type="doi">10.1016/S0959-1524(01)00027-0</pub-id></element-citation></ref><ref id="B11-sensors-25-01256"><label>11.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Samanta</surname><given-names>I.S.</given-names></name>
<name><surname>Panda</surname><given-names>S.</given-names></name>
<name><surname>Rout</surname><given-names>P.K.</given-names></name>
<name><surname>Bajaj</surname><given-names>M.</given-names></name>
<name><surname>Piecha</surname><given-names>M.</given-names></name>
<name><surname>Blazek</surname><given-names>V.</given-names></name>
<name><surname>Prokop</surname><given-names>L.</given-names></name>
</person-group><article-title>A comprehensive review of deep-learning applications to power quality analysis</article-title><source>Energies</source><year>2023</year><volume>16</volume><elocation-id>4406</elocation-id><pub-id pub-id-type="doi">10.3390/en16114406</pub-id></element-citation></ref><ref id="B12-sensors-25-01256"><label>12.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Qin</surname><given-names>S.J.</given-names></name>
</person-group><article-title>Survey on data-driven industrial process monitoring and diagnosis</article-title><source>Annu. Rev. Control</source><year>2012</year><volume>36</volume><fpage>220</fpage><lpage>234</lpage><pub-id pub-id-type="doi">10.1016/j.arcontrol.2012.09.004</pub-id></element-citation></ref><ref id="B13-sensors-25-01256"><label>13.</label><element-citation publication-type="book"><person-group person-group-type="author">
<name><surname>Harrou</surname><given-names>F.</given-names></name>
<name><surname>Sun</surname><given-names>Y.</given-names></name>
<name><surname>Hering</surname><given-names>A.S.</given-names></name>
<name><surname>Madakyaruet</surname><given-names>M.</given-names></name>
</person-group><source>Statistical Process Monitoring Using Advanced Data-Driven and Deep Learning Approaches: Theory and Practical Applications</source><publisher-name>Elsevier</publisher-name><publisher-loc>Amsterdam, The Netherlands</publisher-loc><year>2020</year></element-citation></ref><ref id="B14-sensors-25-01256"><label>14.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>MacGregor</surname><given-names>J.F.</given-names></name>
<name><surname>Kourti</surname><given-names>T.</given-names></name>
</person-group><article-title>Statistical process control of multivariate processes</article-title><source>Control Eng. Pract.</source><year>1995</year><volume>3</volume><fpage>403</fpage><lpage>414</lpage><pub-id pub-id-type="doi">10.1016/0967-0661(95)00014-L</pub-id></element-citation></ref><ref id="B15-sensors-25-01256"><label>15.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Shewhart</surname><given-names>W.A.</given-names></name>
</person-group><article-title>Quality control charts</article-title><source>Bell Syst. Tech. J.</source><year>1926</year><volume>5</volume><fpage>593</fpage><lpage>603</lpage><pub-id pub-id-type="doi">10.1002/j.1538-7305.1926.tb00125.x</pub-id></element-citation></ref><ref id="B16-sensors-25-01256"><label>16.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Bissell</surname><given-names>A.F.</given-names></name>
</person-group><article-title>Cusum techniques for quality control</article-title><source>J. R. Stat. Soc. Ser. C</source><year>1969</year><volume>18</volume><fpage>1</fpage><lpage>25</lpage><pub-id pub-id-type="doi">10.2307/2346436</pub-id></element-citation></ref><ref id="B17-sensors-25-01256"><label>17.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Crowder</surname><given-names>S.V.</given-names></name>
<name><surname>Hamilton</surname><given-names>M.D.</given-names></name>
</person-group><article-title>An EWMA for monitoring a process standard deviation</article-title><source>J. Qual. Technol.</source><year>1992</year><volume>24</volume><fpage>12</fpage><lpage>21</lpage><pub-id pub-id-type="doi">10.1080/00224065.1992.11979369</pub-id></element-citation></ref><ref id="B18-sensors-25-01256"><label>18.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Shamsuzzaman</surname><given-names>M.</given-names></name>
<name><surname>Khoo</surname><given-names>M.B.C.</given-names></name>
<name><surname>Haridy</surname><given-names>S.</given-names></name>
<name><surname>Alsyouf</surname><given-names>I.</given-names></name>
</person-group><article-title>An optimization design of the combined Shewhart-EWMA control chart</article-title><source>Int. J. Adv. Manuf. Technol.</source><year>2016</year><volume>86</volume><fpage>1627</fpage><lpage>1637</lpage><pub-id pub-id-type="doi">10.1007/s00170-015-8307-4</pub-id></element-citation></ref><ref id="B19-sensors-25-01256"><label>19.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Kresta</surname><given-names>J.V.</given-names></name>
<name><surname>Macgregor</surname><given-names>J.F.</given-names></name>
<name><surname>Marlin</surname><given-names>T.E.</given-names></name>
</person-group><article-title>Multivariate statistical monitoring of process operating performance</article-title><source>Can. J. Chem. Eng.</source><year>1991</year><volume>69</volume><fpage>35</fpage><lpage>47</lpage><pub-id pub-id-type="doi">10.1002/cjce.5450690105</pub-id></element-citation></ref><ref id="B20-sensors-25-01256"><label>20.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Harkat</surname><given-names>M.F.</given-names></name>
<name><surname>Djelel</surname><given-names>S.</given-names></name>
<name><surname>Doghmane</surname><given-names>N.</given-names></name>
<name><surname>Benouaret</surname><given-names>M.</given-names></name>
</person-group><article-title>Sensor fault detection, isolation and reconstruction using nonlinear principal component analysis</article-title><source>Int. J. Autom. Comput.</source><year>2007</year><volume>4</volume><fpage>149</fpage><lpage>155</lpage><pub-id pub-id-type="doi">10.1007/s11633-007-0149-6</pub-id></element-citation></ref><ref id="B21-sensors-25-01256"><label>21.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Kourti</surname><given-names>T.</given-names></name>
<name><surname>Nomikos</surname><given-names>P.</given-names></name>
<name><surname>MacGregor</surname><given-names>J.F.</given-names></name>
</person-group><article-title>Analysis, monitoring and fault diagnosis of batch processes using multiblock and multiway PLS</article-title><source>J. Process Control</source><year>1995</year><volume>5</volume><fpage>277</fpage><lpage>284</lpage><pub-id pub-id-type="doi">10.1016/0959-1524(95)00019-M</pub-id></element-citation></ref><ref id="B22-sensors-25-01256"><label>22.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Lee</surname><given-names>J.M.</given-names></name>
<name><surname>Yoo</surname><given-names>C.K.</given-names></name>
<name><surname>Lee</surname><given-names>I.B.</given-names></name>
</person-group><article-title>Statistical process monitoring with independent component analysis</article-title><source>J. Process Control</source><year>2004</year><volume>14</volume><fpage>467</fpage><lpage>485</lpage><pub-id pub-id-type="doi">10.1016/j.jprocont.2003.09.004</pub-id></element-citation></ref><ref id="B23-sensors-25-01256"><label>23.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Jiang</surname><given-names>Q.</given-names></name>
<name><surname>Huang</surname><given-names>B.</given-names></name>
<name><surname>Yan</surname><given-names>X.</given-names></name>
</person-group><article-title>GMM and optimal principal components-based Bayesian method for multimode fault diagnosis</article-title><source>Comput. Chem. Eng.</source><year>2016</year><volume>84</volume><fpage>338</fpage><lpage>349</lpage><pub-id pub-id-type="doi">10.1016/j.compchemeng.2015.09.013</pub-id></element-citation></ref><ref id="B24-sensors-25-01256"><label>24.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Yu</surname><given-names>J.</given-names></name>
</person-group><article-title>A nonlinear kernel Gaussian mixture model based inferential monitoring approach for fault detection and diagnosis of chemical processes</article-title><source>Chem. Eng. Sci.</source><year>2012</year><volume>68</volume><fpage>506</fpage><lpage>519</lpage><pub-id pub-id-type="doi">10.1016/j.ces.2011.10.011</pub-id></element-citation></ref><ref id="B25-sensors-25-01256"><label>25.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Pirdashti</surname><given-names>M.</given-names></name>
<name><surname>Curteanu</surname><given-names>S.</given-names></name>
<name><surname>Kamangar</surname><given-names>M.H.</given-names></name>
<name><surname>Hassim</surname><given-names>M.H.</given-names></name>
<name><surname>Khatami</surname><given-names>M.A.</given-names></name>
</person-group><article-title>Artificial neural networks: Applications in chemical engineering</article-title><source>Rev. Chem. Eng.</source><year>2013</year><volume>29</volume><fpage>205</fpage><lpage>239</lpage><pub-id pub-id-type="doi">10.1515/revce-2013-0013</pub-id></element-citation></ref><ref id="B26-sensors-25-01256"><label>26.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Wang</surname><given-names>C.</given-names></name>
<name><surname>Wang</surname><given-names>B.</given-names></name>
<name><surname>Liu</surname><given-names>H.</given-names></name>
<name><surname>Qu</surname><given-names>H.</given-names></name>
</person-group><article-title>Anomaly detection for industrial control system based on autoencoder neural network</article-title><source>Wirel. Commun. Mob. Comput.</source><year>2020</year><volume>2020</volume><fpage>8897926</fpage><pub-id pub-id-type="doi">10.1155/2020/8897926</pub-id></element-citation></ref><ref id="B27-sensors-25-01256"><label>27.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Mohd Amiruddin</surname><given-names>A.A.A.</given-names></name>
<name><surname>Zabiri</surname><given-names>H.</given-names></name>
<name><surname>Taqvi</surname><given-names>S.A.A.</given-names></name>
<name><surname>Tufa</surname><given-names>L.D.</given-names></name>
</person-group><article-title>Neural network applications in fault diagnosis and detection: An overview of implementations in engineering-related systems</article-title><source>Neural Comput. Appl.</source><year>2020</year><volume>32</volume><fpage>447</fpage><lpage>472</lpage><pub-id pub-id-type="doi">10.1007/s00521-018-3911-5</pub-id></element-citation></ref><ref id="B28-sensors-25-01256"><label>28.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Patan</surname><given-names>K.</given-names></name>
<name><surname>Parisini</surname><given-names>T.</given-names></name>
</person-group><article-title>Identification of neural dynamic models for fault detection and isolation: The case of a real sugar evaporation process</article-title><source>J. Process Control</source><year>2005</year><volume>15</volume><fpage>67</fpage><lpage>79</lpage><pub-id pub-id-type="doi">10.1016/j.jprocont.2004.04.001</pub-id></element-citation></ref><ref id="B29-sensors-25-01256"><label>29.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Xue</surname><given-names>P.</given-names></name>
<name><surname>Shi</surname><given-names>L.</given-names></name>
<name><surname>Zhou</surname><given-names>Z.</given-names></name>
<name><surname>Liu</surname><given-names>J.</given-names></name>
<name><surname>Chen</surname><given-names>X.</given-names></name>
</person-group><article-title>An online fault detection and diagnosis method of sensors in district heating substations based on long short-term memory network and adaptive threshold selection algorithm</article-title><source>Energy Build.</source><year>2024</year><volume>308</volume><fpage>114009</fpage><pub-id pub-id-type="doi">10.1016/j.enbuild.2024.114009</pub-id></element-citation></ref><ref id="B30-sensors-25-01256"><label>30.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Cai</surname><given-names>L.</given-names></name>
<name><surname>Tian</surname><given-names>X.</given-names></name>
<name><surname>Chen</surname><given-names>S.</given-names></name>
</person-group><article-title>Monitoring nonlinear and non-Gaussian processes using Gaussian mixture model-based weighted kernel independent component analysis</article-title><source>IEEE Trans. Neural Netw. Learn. Syst.</source><year>2015</year><volume>28</volume><fpage>122</fpage><lpage>135</lpage><pub-id pub-id-type="doi">10.1109/TNNLS.2015.2505086</pub-id><pub-id pub-id-type="pmid">26685274</pub-id>
</element-citation></ref><ref id="B31-sensors-25-01256"><label>31.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Zhang</surname><given-names>Z.</given-names></name>
<name><surname>Jiang</surname><given-names>T.</given-names></name>
<name><surname>Li</surname><given-names>S.</given-names></name>
<name><surname>Yang</surname><given-names>Y.</given-names></name>
</person-group><article-title>Automated feature learning for nonlinear process monitoring&#x02013;An approach using stacked denoising autoencoder and k-nearest neighbor rule</article-title><source>J. Process Control</source><year>2018</year><volume>64</volume><fpage>49</fpage><lpage>61</lpage><pub-id pub-id-type="doi">10.1016/j.jprocont.2018.02.004</pub-id></element-citation></ref><ref id="B32-sensors-25-01256"><label>32.</label><element-citation publication-type="confproc"><person-group person-group-type="author">
<name><surname>Wang</surname><given-names>X.</given-names></name>
<name><surname>Eliseev</surname><given-names>V.</given-names></name>
</person-group><article-title>Method for Quality Control of an Autonomous Neural Network Model of a Non-Linear Dynamic System</article-title><source>Proceedings of the 2024 IEEE 9th International Conference on Computational Intelligence and Applications (ICCIA)</source><conf-loc>Haikou, China</conf-loc><conf-date>9&#x02013;11 August 2024</conf-date><fpage>201</fpage><lpage>208</lpage></element-citation></ref><ref id="B33-sensors-25-01256"><label>33.</label><element-citation publication-type="journal"><person-group person-group-type="author">
<name><surname>Wang</surname><given-names>X.</given-names></name>
<name><surname>Eliseev</surname><given-names>V.L.</given-names></name>
</person-group><article-title>Nejrosetevoj metod obnaruzheniya smeny rezhima raboty nelinejnogo dinamicheskogo ob&#x02019;ekta [Neural network method for detecting changes in the operating mode of a nonlinear dynamic object], Izvestiya Tul&#x02019;skogo gosudarstvennogo universiteta</article-title><source>Texnicheskie Nauk.</source><year>2024</year><volume>3</volume><fpage>48</fpage><lpage>56</lpage></element-citation></ref><ref id="B34-sensors-25-01256"><label>34.</label><element-citation publication-type="confproc"><person-group person-group-type="author">
<name><surname>Wang</surname><given-names>X.</given-names></name>
<name><surname>Eliseev</surname><given-names>V.L.</given-names></name>
</person-group><article-title>Obnaruzhenie razladki modeli dinamicheskogo ob&#x02019;ekta s pomoshh&#x02019;yu funkcii korrelyacii [Detecting Dynamic Object Model Disorders Using Correlation Function]</article-title><source>Proceedings of the XXX Mezhdunarodnaya Nauchno-Texnicheskaya Konferenciya Studentov I Aspirantov &#x0201c;Radioelektronika, Elektrotexnika I Energetika&#x0201d;</source><conf-loc>Moscow, Russia</conf-loc><conf-date>29 February&#x02013;2 March 2024</conf-date><fpage>301</fpage></element-citation></ref><ref id="B35-sensors-25-01256"><label>35.</label><element-citation publication-type="confproc"><person-group person-group-type="author">
<name><surname>Hall</surname><given-names>R.C.</given-names></name>
<name><surname>Seborg</surname><given-names>D.E.</given-names></name>
</person-group><article-title>Modelling and self-tuning control of a multivariable ph neutralization process part i: Modelling and multiloop control</article-title><source>Proceedings of the 1989 American Control Conference</source><conf-loc>Pittsburgh, PA, USA</conf-loc><conf-date>21&#x02013;23 June 1989</conf-date><fpage>1822</fpage><lpage>1827</lpage></element-citation></ref><ref id="B36-sensors-25-01256"><label>36.</label><element-citation publication-type="webpage"><person-group person-group-type="author">
<collab>SimInTech</collab>
</person-group><comment>Available online: <ext-link xlink:href="https://en.simintech.ru/" ext-link-type="uri">https://en.simintech.ru/</ext-link></comment><date-in-citation content-type="access-date" iso-8601-date="2024-12-30">(accessed on 30 December 2024)</date-in-citation></element-citation></ref></ref-list></back><floats-group><fig position="float" id="sensors-25-01256-f001"><label>Figure 1</label><caption><p>Scheme for the reference model-based disorder detection.</p></caption><graphic xlink:href="sensors-25-01256-g001" position="float"/></fig><fig position="float" id="sensors-25-01256-f002"><label>Figure 2</label><caption><p>Vector space of cross-correlation functions.</p></caption><graphic xlink:href="sensors-25-01256-g002" position="float"/></fig><fig position="float" id="sensors-25-01256-f003"><label>Figure 3</label><caption><p>Architecture of the neural network autoencoder.</p></caption><graphic xlink:href="sensors-25-01256-g003" position="float"/></fig><fig position="float" id="sensors-25-01256-f004"><label>Figure 4</label><caption><p>Scheme for the synthesis of disorder detector.</p></caption><graphic xlink:href="sensors-25-01256-g004" position="float"/></fig><fig position="float" id="sensors-25-01256-f005"><label>Figure 5</label><caption><p>Scheme for the application of disorder detector.</p></caption><graphic xlink:href="sensors-25-01256-g005" position="float"/></fig><fig position="float" id="sensors-25-01256-f006"><label>Figure 6</label><caption><p>The process of the pH neutralization reaction.</p></caption><graphic xlink:href="sensors-25-01256-g006" position="float"/></fig><fig position="float" id="sensors-25-01256-f007"><label>Figure 7</label><caption><p>Screenshot of the SimInTech program window with a simulation model of the pH neutralization reaction.</p></caption><graphic xlink:href="sensors-25-01256-g007" position="float"/></fig><fig position="float" id="sensors-25-01256-f008"><label>Figure 8</label><caption><p>Results of the neutralization reactor simulation.</p></caption><graphic xlink:href="sensors-25-01256-g008" position="float"/></fig><fig position="float" id="sensors-25-01256-f009"><label>Figure 9</label><caption><p>Algorithms for detecting disorders: CCF&#x02212;AE (<bold>a</bold>), CUSUM (<bold>b</bold>), EWMV (<bold>c</bold>).</p></caption><graphic xlink:href="sensors-25-01256-g009" position="float"/></fig><fig position="float" id="sensors-25-01256-f010"><label>Figure 10</label><caption><p>Simulation of neutralization reaction using GRU neural network.</p></caption><graphic xlink:href="sensors-25-01256-g010" position="float"/></fig><fig position="float" id="sensors-25-01256-f011"><label>Figure 11</label><caption><p>Identification error of GRU neural network.</p></caption><graphic xlink:href="sensors-25-01256-g011" position="float"/></fig><fig position="float" id="sensors-25-01256-f012"><label>Figure 12</label><caption><p>CCF vectors in different windows.</p></caption><graphic xlink:href="sensors-25-01256-g012" position="float"/></fig><fig position="float" id="sensors-25-01256-f013"><label>Figure 13</label><caption><p>Detection trajectory of CCF-AE.</p></caption><graphic xlink:href="sensors-25-01256-g013" position="float"/></fig><fig position="float" id="sensors-25-01256-f014"><label>Figure 14</label><caption><p>CUSUM control chart.</p></caption><graphic xlink:href="sensors-25-01256-g014" position="float"/></fig><fig position="float" id="sensors-25-01256-f015"><label>Figure 15</label><caption><p>EWMV control chart.</p></caption><graphic xlink:href="sensors-25-01256-g015" position="float"/></fig><table-wrap position="float" id="sensors-25-01256-t001"><object-id pub-id-type="pii">sensors-25-01256-t001_Table 1</object-id><label>Table 1</label><caption><p>Parameters for the baseline model of the neutralization reactor.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Parameter</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Value</th></tr></thead><tbody><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm184" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td><td align="center" valign="middle" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm185" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>3.05</mml:mn><mml:mo>&#x000d7;</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msup><mml:mo>&#x000a0;</mml:mo><mml:mi mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">l</mml:mi></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm186" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td><td align="center" valign="middle" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm187" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>3</mml:mn><mml:mo>&#x000d7;</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mo>&#x000a0;</mml:mo><mml:mi mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">l</mml:mi></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm188" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td><td align="center" valign="middle" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm189" overflow="scroll"><mml:mrow><mml:mrow><mml:mn>3</mml:mn><mml:mo>&#x000d7;</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>3</mml:mn></mml:mrow></mml:msup><mml:mo>&#x000a0;</mml:mo><mml:mi mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">l</mml:mi></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm190" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td><td align="center" valign="middle" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm191" overflow="scroll"><mml:mrow><mml:mrow><mml:mn>5</mml:mn><mml:mo>&#x000d7;</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:msup><mml:mo>&#x000a0;</mml:mo><mml:mi mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">l</mml:mi></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm192" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td><td align="center" valign="middle" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm193" overflow="scroll"><mml:mrow><mml:mrow><mml:mn>3</mml:mn><mml:mo>&#x000d7;</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:msup><mml:mi mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">l</mml:mi></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm194" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td><td align="center" valign="middle" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm195" overflow="scroll"><mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm196" overflow="scroll"><mml:mrow><mml:mrow><mml:mi>V</mml:mi></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td><td align="center" valign="middle" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm197" overflow="scroll"><mml:mrow><mml:mrow><mml:mn>2900</mml:mn><mml:mo>&#x000a0;</mml:mo><mml:mi mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">L</mml:mi></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm198" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td><td align="center" valign="middle" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm199" overflow="scroll"><mml:mrow><mml:mrow><mml:mn>6.35</mml:mn></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm200" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>K</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm201" overflow="scroll"><mml:mrow><mml:mrow><mml:mn>10.25</mml:mn></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td></tr></tbody></table></table-wrap><table-wrap position="float" id="sensors-25-01256-t002"><object-id pub-id-type="pii">sensors-25-01256-t002_Table 2</object-id><label>Table 2</label><caption><p>Nominal operating points for the neutralization reactor.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Parameter</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Value</th></tr></thead><tbody><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm202" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td><td align="center" valign="middle" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm203" overflow="scroll"><mml:mrow><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>4.32</mml:mn><mml:mo>&#x000d7;</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:msup><mml:mo>&#x000a0;</mml:mo><mml:mi mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">l</mml:mi></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm204" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td><td align="center" valign="middle" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm205" overflow="scroll"><mml:mrow><mml:mrow><mml:mn>5.28</mml:mn><mml:mo>&#x000d7;</mml:mo><mml:msup><mml:mrow><mml:mn>10</mml:mn></mml:mrow><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:msup><mml:mi mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">o</mml:mi><mml:mi mathvariant="normal">l</mml:mi></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm206" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td><td align="center" valign="middle" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm207" overflow="scroll"><mml:mrow><mml:mrow><mml:mn>15.55</mml:mn><mml:mo>&#x000a0;</mml:mo><mml:mi mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mo>/</mml:mo><mml:mi mathvariant="normal">s</mml:mi></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm208" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td><td align="center" valign="middle" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm209" overflow="scroll"><mml:mrow><mml:mrow><mml:mn>0.55</mml:mn><mml:mo>&#x000a0;</mml:mo><mml:mi mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mo>/</mml:mo><mml:mi mathvariant="normal">s</mml:mi></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm210" overflow="scroll"><mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>q</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm211" overflow="scroll"><mml:mrow><mml:mrow><mml:mn>16.60</mml:mn><mml:mo>&#x000a0;</mml:mo><mml:mi mathvariant="normal">m</mml:mi><mml:mi mathvariant="normal">L</mml:mi><mml:mo>/</mml:mo><mml:mi mathvariant="normal">s</mml:mi></mml:mrow></mml:mrow></mml:math>
</inline-formula>
</td></tr></tbody></table></table-wrap><table-wrap position="float" id="sensors-25-01256-t003"><object-id pub-id-type="pii">sensors-25-01256-t003_Table 3</object-id><label>Table 3</label><caption><p>Quality and computational cost indicators for disorder detection.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Algorithm</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm212" overflow="scroll"><mml:mrow><mml:mstyle mathvariant="bold"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">R</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">F</mml:mi><mml:mi mathvariant="bold">A</mml:mi><mml:mi mathvariant="bold">R</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:math>
</inline-formula>
</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm213" overflow="scroll"><mml:mrow><mml:mstyle mathvariant="bold"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold">R</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold">T</mml:mi><mml:mi mathvariant="bold">D</mml:mi><mml:mi mathvariant="bold">R</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:math>
</inline-formula>
</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm214" overflow="scroll"><mml:mrow><mml:mstyle mathvariant="bold"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">T</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold-italic">a</mml:mi><mml:mi mathvariant="bold-italic">d</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:math>
</inline-formula>
</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">
<inline-formula>
<mml:math id="mm215" overflow="scroll"><mml:mrow><mml:mstyle mathvariant="bold"><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="bold-italic">T</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="bold-italic">f</mml:mi><mml:mi mathvariant="bold-italic">a</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mstyle></mml:mrow></mml:math>
</inline-formula>
</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Calculation Time (s)</th></tr></thead><tbody><tr><td align="center" valign="middle" rowspan="1" colspan="1">CCF-AE</td><td align="center" valign="middle" rowspan="1" colspan="1">0</td><td align="center" valign="middle" rowspan="1" colspan="1">0.8492</td><td align="center" valign="middle" rowspan="1" colspan="1">5.8673</td><td align="center" valign="middle" rowspan="1" colspan="1">0</td><td align="center" valign="middle" rowspan="1" colspan="1">0.4006</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">CUSUM</td><td align="center" valign="middle" rowspan="1" colspan="1">0.0038</td><td align="center" valign="middle" rowspan="1" colspan="1">0.1447</td><td align="center" valign="middle" rowspan="1" colspan="1">6.6467</td><td align="center" valign="middle" rowspan="1" colspan="1">83.1364</td><td align="center" valign="middle" rowspan="1" colspan="1">0.2584</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">EWMV</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">0.0034</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">0.5702</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">1.7492</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">228.5500</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">0.2623</td></tr></tbody></table></table-wrap></floats-group></article>