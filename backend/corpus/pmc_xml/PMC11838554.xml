<!DOCTYPE article
PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD with MathML3 v1.3 20210610//EN" "JATS-archivearticle1-3-mathml3.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.3" xml:lang="en" article-type="research-article"><?properties open_access?><processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats"><restricted-by>pmc</restricted-by></processing-meta><front><journal-meta><journal-id journal-id-type="nlm-ta">bioRxiv</journal-id><journal-id journal-id-type="publisher-id">BIORXIV</journal-id><journal-title-group><journal-title>bioRxiv</journal-title></journal-title-group><issn pub-type="epub">2692-8205</issn><publisher><publisher-name>Cold Spring Harbor Laboratory</publisher-name></publisher></journal-meta>
<article-meta><article-id pub-id-type="pmid">39974956</article-id><article-id pub-id-type="pmc">PMC11838554</article-id>
<article-id pub-id-type="doi">10.1101/2025.02.05.636549</article-id><article-version-alternatives><article-version article-version-type="status">preprint</article-version><article-version article-version-type="number">1</article-version></article-version-alternatives><article-categories><subj-group subj-group-type="heading"><subject>Article</subject></subj-group></article-categories><title-group><article-title>IGD: A simple, efficient genotype data format</article-title></title-group><contrib-group><contrib contrib-type="author"><contrib-id contrib-id-type="orcid" authenticated="false">http://orcid.org/0009-0005-9087-1831</contrib-id><name><surname>DeHaas</surname><given-names>Drew</given-names></name><xref rid="A1" ref-type="aff">1</xref></contrib><contrib contrib-type="author"><contrib-id contrib-id-type="orcid" authenticated="false">http://orcid.org/0000-0001-8184-7016</contrib-id><name><surname>Wei</surname><given-names>Xinzhu</given-names></name><xref rid="A1" ref-type="aff">1</xref><xref rid="CR1" ref-type="corresp">*</xref></contrib></contrib-group><aff id="A1"><label>1</label>Department of Computational Biology, Cornell University, Ithaca, NY</aff><author-notes><corresp id="CR1"><label>*</label>Correspondence: <email>aprilwei@cornell.edu</email>.</corresp></author-notes><pub-date pub-type="epub"><day>08</day><month>2</month><year>2025</year></pub-date><elocation-id>2025.02.05.636549</elocation-id><permissions><license><ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref><license-p>This work is licensed under a <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</ext-link>, which allows reusers to distribute, remix, adapt, and build upon the material in any medium or format, so long as attribution is given to the creator. The license allows for commercial use.</license-p></license></permissions><self-uri content-type="pdf">nihpp-2025.02.05.636549.pdf</self-uri><abstract id="ABS1"><sec id="S1"><title>Motivation:</title><p id="P1">While there are a variety of file formats for storing reference-sequence-aligned genotype data, many are complex or inefficient. Programming language support for such formats is often limited. A file format that is simple to understand and implement &#x02013; yet fast and small &#x02013; is helpful for research on highly scalable bioinformatics.</p></sec><sec id="S2"><title>Results:</title><p id="P2">We present the Indexable Genotype Data (IGD) file format, a simple uncompressed binary format that can be more than 100 times faster and 3.5 times smaller than <italic toggle="yes">vcf.gz</italic> on Biobank-scale whole-genome sequence data. The implementation for reading and writing IGD in Python is under 350 lines of code, which reflects the simplicity of the format.</p></sec><sec id="S3"><title>Availability:</title><p id="P3">A C++ library reading and writing IGD, and tooling to convert <italic toggle="yes">.vcf.gz</italic> files, can be found at <ext-link xlink:href="https://github.com/aprilweilab/picovcf" ext-link-type="uri">https://github.com/aprilweilab/picovcf</ext-link>. A Python library is at <ext-link xlink:href="https://github.com/aprilweilab/pyigd" ext-link-type="uri">https://github.com/aprilweilab/pyigd</ext-link></p></sec></abstract><funding-group><funding-statement>This work has been partly supported by NIH R35GM150579 to X.W.</funding-statement></funding-group></article-meta></front><body><sec id="S4"><title>Introduction</title><p id="P4">Genetic polymorphism data is typically stored in a tabular format that can be thought of as an <inline-formula><mml:math id="M7" display="inline"><mml:mrow><mml:mi>S</mml:mi><mml:mspace width="0.5em"/><mml:mo>&#x000d7;</mml:mo><mml:mspace width="0.5em"/><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula> matrix. The rows represent <italic toggle="yes">S</italic> sites and the columns represent <inline-formula><mml:math id="M8" display="inline"><mml:mi>N</mml:mi></mml:math></inline-formula> individuals, where each site has at least one alternate allele that differs from the reference sequence, but may have many (a multi-allelic site). Variant Call Format (VCF) (<xref rid="R5" ref-type="bibr">Danecek et al., 2011</xref>) and its compressed form (<italic toggle="yes">.vcf.gz</italic>) are mainstays of tooling that process such tabular genotype data. The VCF format is very flexible, and its plaintext nature makes it easy to understand, construct, and parse. However, it is inefficient to store and process for large-scale datasets, as evidenced by the proliferation of faster and more compact formats. Among alternate formats, BCF (<xref rid="R13" ref-type="bibr">Li, 2011</xref>), BGEN (<xref rid="R2" ref-type="bibr">Band and Marchini, 2018</xref>), and BED (<xref rid="R15" ref-type="bibr">Purcell et al., 2007</xref>) have popular tooling support. Newer, more efficient formats such as PGEN (<xref rid="R16" ref-type="bibr">Rivas and Chang, 2024</xref>), XSI (<xref rid="R17" ref-type="bibr">Wertenbroek et al., 2022</xref>), Savvy (<xref rid="R12" ref-type="bibr">LeFaive et al., 2021</xref>), GTshark (<xref rid="R7" ref-type="bibr">Deorowicz and Danek, 2019</xref>), GRG (<xref rid="R6" ref-type="bibr">DeHaas et al., 2024</xref>), and others (<xref rid="R11" ref-type="bibr">Lan et al., 2021</xref>; <xref rid="R3" ref-type="bibr">Browning et al., 2018</xref>) leverage the similarity between samples at nearby genetic positions (due to linkage-disequilibrium (LD)) to compress genotype data to an impressive extent.</p><p id="P5">Here we present the Indexable Genotype Data (IGD) format, which is designed by the (sometimes at odds) principles of simplicity and efficiency. IGD encodes tabular genotype data as hard calls, similar to pVCF and BED. The only meta-data it stores (optionally) are identifiers for variants and individuals; the expectation is that most meta-data can be stored separately in general purpose file formats like CSV or JSON (<xref rid="R14" ref-type="bibr">Pezoa et al., 2016</xref>). IGD is uncompressed, which makes reading and writing the format easy to implement and avoids the need for external compression libraries which may not be easily usable across platforms or programming languages. IGD is a binary format, and supports multi-allelic variants, any ploidy up to 255, is contained in a single file, and can be constructed in one pass over the input data. IGD can represent both phased and unphased data, but all data in the file must have the same phasedness.</p></sec><sec id="S5"><title>Methods</title><p id="P6">Given that we have <italic toggle="yes">N</italic> individuals in a dataset, we number them <inline-formula><mml:math id="M9" display="inline"><mml:mrow><mml:mn>0</mml:mn><mml:mo>&#x02026;</mml:mo><mml:mfenced><mml:mrow><mml:mi>N</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>. There are <inline-formula><mml:math id="M10" display="inline"><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>H</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>N</mml:mi><mml:mo>&#x000d7;</mml:mo><mml:mi>p</mml:mi><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>i</mml:mi><mml:mi>d</mml:mi><mml:mi>y</mml:mi></mml:mrow></mml:math></inline-formula> haploid samples of these individuals, which are similarly numbered <inline-formula><mml:math id="M11" display="inline"><mml:mrow><mml:mn>0</mml:mn><mml:mo>&#x02026;</mml:mo><mml:mfenced><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>H</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>. Throughout when we refer to a &#x0201c;sample&#x0201d; we mean a <italic toggle="yes">haploid</italic> sample. There are <inline-formula><mml:math id="M12" display="inline"><mml:mi>M</mml:mi></mml:math></inline-formula> variants in a dataset, each of which can be uniquely identified by the pair (<italic toggle="yes">base-pair position</italic>, <italic toggle="yes">alternate allele</italic>), and <inline-formula><mml:math id="M13" display="inline"><mml:mi>Q</mml:mi></mml:math></inline-formula> variants that contain at least one sample with missing data.</p><p id="P7">There are a few significant aspects of the IGD format worth highlighting.</p><sec id="S6"><title>All polymorphic sites are stored using bi-allelic format.</title><p id="P8">Instead of storing a row per site (<inline-formula><mml:math id="M14" display="inline"><mml:mrow><mml:mi>S</mml:mi><mml:mo>&#x000d7;</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>H</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> matrix), IGD stores a row per variant (<inline-formula><mml:math id="M15" display="inline"><mml:mrow><mml:mi>M</mml:mi><mml:mo>&#x000d7;</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>H</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> matrix). Multi-allelic sites are supported by <italic toggle="yes">expanding them</italic> into a row per variant. For example, a <inline-formula><mml:math id="M16" display="inline"><mml:mrow><mml:mfenced><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>-allelic site with <inline-formula><mml:math id="M17" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> alternate alleles (without missing data) is expanded into <italic toggle="yes">k</italic> variants that all have the same position and reference allele, but different alternate alleles. The original multi-allelic sites can be recovered by aggregating the IGD variants by position, however, keeping the data as an <inline-formula><mml:math id="M18" display="inline"><mml:mrow><mml:mi>M</mml:mi><mml:mspace width="0.5em"/><mml:mo>&#x000d7;</mml:mo><mml:mspace width="0.5em"/><mml:msub><mml:mi>N</mml:mi><mml:mi>H</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> matrix is often convenient for statistical genetics or population genetics applications.</p><p id="P9">In practice, IGD is an <inline-formula><mml:math id="M19" display="inline"><mml:mrow><mml:mfenced><mml:mrow><mml:mi>M</mml:mi><mml:mo>&#x000d7;</mml:mo><mml:mi>Q</mml:mi></mml:mrow></mml:mfenced><mml:mo>&#x000d7;</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>H</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> matrix, since missing data is encoded as a row of samples representing the ones with missing data, instead of representing those with the alternate allele.</p></sec><sec id="S7"><title>IGD contains an internal index.</title><p id="P10">The index contains the genomic position (in base-pairs) of each variant, and can be cross-referenced to the genotype data, the allele strings, or variant IDs. By keeping the contents of the index small (16 bytes per variant) we keep the cost of reading it from disk very small. All variant-related data in IGD can be randomly accessed by <inline-formula><mml:math id="M20" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula>, the row number of that variant in the IGD index.</p></sec><sec id="S8"><title>IGD uses one of two compact genotype formats per variant.</title><p id="P11">Each row of genotype data is represented as the set of samples that have the variant/alternate allele. The two simple, compact ways to store this data are either (a) sparsely as a list of sample numbers or (b) densely as a bit-vector where each bit at position <inline-formula><mml:math id="M21" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> reflects whether the <inline-formula><mml:math id="M22" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula>-th sample has the alternate allele (1) or not (0). We can choose between representation (a) and (b) by examining the allele frequency <inline-formula><mml:math id="M23" display="inline"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> of the variant in question. Sample numbers are represented by 32-bit unsigned integers, which means that if <inline-formula><mml:math id="M24" display="inline"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>&#x0003c;</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>H</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mn>32</mml:mn></mml:mrow></mml:mfrac></mml:mrow></mml:math></inline-formula> the sparse representation is more compact (a), otherwise the bit-vector representation (b) is smaller. It is important to note that a valid IGD file can be constructed using <italic toggle="yes">only</italic> row representation (a) or <italic toggle="yes">only</italic> bit vector representation (b), or any mixture of the two, but the optimally sized IGD will determine which to use on a per-variant basis.</p><p id="P12">Converting between these two representations is trivial, and thus the representation on disk does not have to be the representation used for computation.</p></sec><sec id="S9"><label>2.1</label><title>File Format Details</title><p id="P13">The layout of an IGD file is shown in <xref rid="F1" ref-type="fig">Fig. 1</xref>. The header contains file offsets for each of the sections after the genotype data, as their positions are unpredictable otherwise, and random access to them is useful. We use the following storage type definitions.</p><p id="P14"><bold><italic toggle="yes">uint32</italic>:</bold> A 32-bit unsigned integer.</p><p id="P15"><bold><italic toggle="yes">uint64</italic>:</bold> A 64-bit unsigned integer.</p><p id="P16"><bold><italic toggle="yes">string</italic>:</bold> A uint32 for the length <inline-formula><mml:math id="M25" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula>, followed by <inline-formula><mml:math id="M26" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> bytes for the contents.</p><p id="P17"><bold><italic toggle="yes">list32</italic>:</bold> A uint32 for the length <inline-formula><mml:math id="M27" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula>, followed by <inline-formula><mml:math id="M28" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> uint32 values for the contents.</p><p id="P18"><bold><italic toggle="yes">bv(w)</italic>:</bold> A bit-vector of <italic toggle="yes">w</italic> bits stored at the byte granularity. The number of bytes used is &#x1d450;&#x1d452;<italic toggle="yes">il</italic>(&#x1d464;/8). Given a sample index <italic toggle="yes">b</italic> that we want to store as a 1, the byte offset is determined by &#x1d453;&#x1d459;&#x1d45c;or(&#x1d44f;/8). Within that byte we set the (<italic toggle="yes">7 -</italic> (<italic toggle="yes">b mod 8</italic>))<sup>th</sup> least significant bit; that is, if (<italic toggle="yes">b mod 8</italic>) <italic toggle="yes">= 0</italic> we will set the most significant bit.</p><sec id="S10"><label>2.1.1</label><title>Header</title><p id="P19">The header is a fixed-size (128 byte) table as described in <xref rid="T1" ref-type="table">Table 1</xref>.</p></sec><sec id="S11"><label>2.1.2</label><title>Flags</title><p id="P20">The least-significant bit of the flags (in the header) signifies phasedness, where a value of 1 indicates phased data.</p></sec><sec id="S12"><label>2.1.2</label><title>Description strings</title><p id="P21">Immediately following the header are two <italic toggle="yes">string</italic> values. The first is a <italic toggle="yes">string</italic> describing how the file was created (e.g., &#x0201c;converted from foo.vcf.gz&#x0201d;) and the second is a generic description field.</p></sec><sec id="S13"><label>2.1.3</label><title>Genotype data</title><p id="P22">Immediately following the description strings is <inline-formula><mml:math id="M29" display="inline"><mml:mrow><mml:mi>M</mml:mi><mml:mo>+</mml:mo><mml:mi>Q</mml:mi></mml:mrow></mml:math></inline-formula> rows of genotype data, where each row is either a <bold><italic toggle="yes">list32</italic></bold> or a <inline-formula><mml:math id="M30" display="inline"><mml:mrow><mml:mstyle mathvariant="bold-italic" mathsize="normal"><mml:mi>b</mml:mi><mml:mi>v</mml:mi></mml:mstyle><mml:mfenced><mml:mrow><mml:msub><mml:mstyle mathvariant="bold-italic" mathsize="normal"><mml:mi>N</mml:mi></mml:mstyle><mml:mstyle mathvariant="bold-italic" mathsize="normal"><mml:mi>H</mml:mi></mml:mstyle></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>. The Index (described next) has a flag that indicates the type of each row.</p></sec><sec id="S14"><label>2.1.4</label><title>Index</title><p id="P23">The Index is <inline-formula><mml:math id="M31" display="inline"><mml:mrow><mml:mi>M</mml:mi><mml:mo>+</mml:mo><mml:mi>Q</mml:mi></mml:mrow></mml:math></inline-formula> rows of 16 bytes each, and can be viewed as two <italic toggle="yes">uint64</italic> values. The first <bold><italic toggle="yes">uint64</italic></bold> value contains the base-pair position associated with the variant in the least-significant 48 bits, followed by an 8-bit unsigned integer <italic toggle="yes">numCopies</italic>, and finally bitwise flags in the most-significant 8 bits. The currently defined flags are:</p><list list-type="bullet" id="L2"><list-item><p id="P24"><bold>SPARSE=0&#x000d7;01</bold>: If this flag is set the corresponding genotype row is a <italic toggle="yes">list32</italic>, otherwise it is a <inline-formula><mml:math id="M32" display="inline"><mml:mrow><mml:mstyle mathvariant="bold-italic" mathsize="normal"><mml:mi>b</mml:mi><mml:mi>v</mml:mi></mml:mstyle><mml:mfenced><mml:mrow><mml:msub><mml:mstyle mathvariant="bold-italic" mathsize="normal"><mml:mi>N</mml:mi></mml:mstyle><mml:mstyle mathvariant="bold-italic" mathsize="normal"><mml:mi>H</mml:mi></mml:mstyle></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>.</p></list-item><list-item><p id="P25"><bold>IS_MISSING=0&#x000d7;02</bold>: If this flag is set the corresponding genotype row&#x02019;s sample list represents missing data. The list of samples in the row do not have a variant call for that polymorphic site.</p></list-item></list><p id="P26">The <italic toggle="yes">numCopies</italic> value is 0 for phased data, but is 1 &#x02264; &#x1d45b;&#x1d462;&#x1d45a;&#x1d436;&#x1d45c;&#x1d45d;&#x1d456;&#x1d452;&#x1d460; &#x02264; &#x1d45d;&#x1d459;&#x1d45c;&#x1d456;&#x1d451;&#x1d466; for unphased data. The second <bold><italic toggle="yes">uint64</italic></bold> value in the Index row contains the file offset of the genotype row for the current variant. The <italic toggle="yes">i</italic><sup>th</sup> variant can be randomly accessed directly at &#x1d43c;&#x1d45b;&#x1d451;&#x1d452;&#x1d465;&#x1d446;&#x1d461;&#x1d44e;&#x1d45f;&#x1d461; + (16 &#x000d7; &#x1d456;).</p></sec><sec id="S15"><label>2.1.5</label><title>Allele strings</title><p id="P27">This section is <inline-formula><mml:math id="M33" display="inline"><mml:mrow><mml:mi>M</mml:mi><mml:mo>+</mml:mo><mml:mi>Q</mml:mi></mml:mrow></mml:math></inline-formula> rows, each row contains first the <bold><italic toggle="yes">string</italic></bold> for the reference allele and then the <bold><italic toggle="yes">string</italic></bold> for the alternate allele.</p></sec><sec id="S16"><label>2.1.6</label><title>Individual IDs</title><p id="P28">This section is a <bold><italic toggle="yes">uint64</italic></bold> for the number of strings, followed by that many <bold><italic toggle="yes">strings</italic></bold>, where the <italic toggle="yes">k</italic><sup>th</sup> is the identifier for individual <italic toggle="yes">k</italic>. This section is only present in the file if the corresponding header file offset entry is non-zero.</p></sec><sec id="S17"><label>2.1.7</label><title>Variant IDs</title><p id="P29">This section is a <bold><italic toggle="yes">uint64</italic></bold> for the number of strings, followed by that many <bold><italic toggle="yes">strings</italic></bold>, where the <inline-formula><mml:math id="M34" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula><sup>th</sup> one is the variant identifier for the <inline-formula><mml:math id="M35" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula><sup>th</sup> variant. This section is only present in the file if the corresponding header file offset entry is non-zero.</p></sec></sec><sec id="S18"><label>2.2</label><title>Phasedness</title><p id="P30">Unphased data is stored by clearing the phased flag in the header, and storing separate variants for each number of copies of each alternate allele. The <italic toggle="yes">numCopies</italic> value in the index (see above) indicates the zygosity of the currently stored sample list. Additionally, instead of storing haploid sample lists, IGD stores individual-based sample lists for unphased data. That is, it represents an <inline-formula><mml:math id="M36" display="inline"><mml:mrow><mml:mfenced><mml:mrow><mml:mi>M</mml:mi><mml:mspace width="0.5em"/><mml:mo>+</mml:mo><mml:mspace width="0.5em"/><mml:mi>Q</mml:mi></mml:mrow></mml:mfenced><mml:mo>&#x000d7;</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula> matrix (instead of <inline-formula><mml:math id="M37" display="inline"><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>H</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>).</p></sec><sec id="S19"><label>2.3</label><title>Access Patterns</title><p id="P31">There are two typical access patterns for an IGD file. If the variant index <inline-formula><mml:math id="M38" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> is known, we can seek directly to it in the Index and then seek directly to the genotype data for that variant. If any of the string data is needed (alleles, individual IDs, variant IDs) those tables will need to be loaded into memory so they are indexable by <inline-formula><mml:math id="M39" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula>, or just scanned on disk to find the <inline-formula><mml:math id="M40" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula><sup>th</sup> entry.</p><p id="P32">Alternatively, traversing an IGD file is done by seeking to the start of the Index. Starting at variant <inline-formula><mml:math id="M41" display="inline"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mspace width="0.5em"/><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>, each row of the Index is read and if the base-pair position is of interest then the genotype data is accessed using the file offset found in the current (<inline-formula><mml:math id="M42" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula><sup>th</sup>) row of the Index. String data can be read into RAM one time, or a file pointer can be maintained to the current entry for each string table and incremented whenever <inline-formula><mml:math id="M43" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> is incremented.</p></sec></sec><sec id="S20"><title>Results</title><p id="P33">We compared file size and data traversal time between IGD, <italic toggle="yes">.vcf.gz</italic>, BCF, and PGEN (<xref rid="F2" ref-type="fig">Fig. 2</xref>). These formats were chosen for their apparent popularity as well as for capturing a spectrum from simple and inefficient (<italic toggle="yes">.vcf.gz</italic>) to more complex, yet very efficient (PGEN). PGEN is on the more complex side because it uses LD-based compression, and also supports 8 different storage modes, some of which are for backwards compatibility (<xref rid="R4" ref-type="bibr">Chang, 2024</xref>).</p><p id="P34">Allele frequency calculation was used for traversal time, as it is a trivial calculation over all the data in the file. For formats that encode an allele count, such as BCF, PGEN, and IGD (for sparse variants), we do not use that count but read the full sample data for each variant in order to measure the data traversal overhead. plink2 (Purcell and Chang, 2024)) was used for conversion to BCF and PGEN formats, as well as for allele frequency calculation for <italic toggle="yes">.vcf.gz</italic> and BCF. The API <italic toggle="yes">PgrGetDifflistOrGenovec()</italic> was used for calculating PGEN allele frequency. The BCF files were stripped of additional meta-data, and only contained variants and genotypes.</p><p id="P35">The simulated data was generated via stdpopsim (<xref rid="R1" ref-type="bibr">Adrion et al., 2020</xref>) and msprime <xref rid="R10" ref-type="bibr">(Kelleher et al., 2016</xref>), using an out-of-Africa demographic model (<xref rid="R9" ref-type="bibr">Jouganous et al., 2017</xref>) and sampling 500,000 European individuals, in an attempt to generate data similar to the UK Biobank whole-genome sequence (WGS) data (<xref rid="R8" ref-type="bibr">Hofmeister et al., 2023</xref>).</p><p id="P36">File sizes are all fairly similar on the simulated dataset, ranging from 54GB (PGEN) to 84GB (.vcf.gz), with IGD and BCF being similarly sized at 73&#x02013;74GB. PGEN and IGD are the two smallest formats on the UKB dataset, which is much richer in low-frequency variants (~96% variants are MAF&#x0003c;0.1% <xref rid="R8" ref-type="bibr">(Hofmeister et al., 2023</xref>)) than our simulated dataset (~73% of variants are MAF&#x0003c;0.1%), and thus more compactly stored with a sparse representation.</p><p id="P37">BCF and <italic toggle="yes">.vcf.gz</italic> rely heavily on standard compression algorithms, which is illustrated by the traversal times for IGD and PGEN being many times faster, especially on the UKB data. PGEN is the smallest and fastest file format, about 30% smaller and 5x faster than IGD.</p><p id="P38">File format conversion times are summarized in <xref rid="T2" ref-type="table">Table 2</xref>. PGEN is again fastest, likely partially due to plink&#x02019;s highly optimized <italic toggle="yes">.vcf.gz</italic> read functionality.</p><p id="P39">The compactness and simplicity of IGD format make it easily usable in bioinformatic tool development. IGD has been successfully used as the input to Genotype Representation Graph (GRG) construction (<xref rid="R6" ref-type="bibr">DeHaas et al., 2024</xref>) construction, and is essential for the efficiency of that process on biobank-scale data. GRG construction requires fast indexing of genomic regions as well as fast genotype data access. Indexing compressed formats (such as .vcf.gz and BCF) can be complex, and creates a separate file for the index. For IGD the index is a fundamental part of the file format. <xref rid="F3" ref-type="fig">Fig. 3</xref> shows the time to construct a GRG tree, the first part of GRG construction, is 13&#x02013;15x faster for IGD than for <italic toggle="yes">.vcf.gz</italic>. We extracted the same region (for varying lengths, on the x-axis) from a simulated dataset with 1 million haploid samples, and then timed the GRG tree construction for that region.</p><p id="P40">IGD provides an extremely simple, yet efficient, alternative to existing file formats. It focuses on genotype data storage, and ease-of-use for developers of scalable prototypes and tools.</p></sec></body><back><ack id="S21"><title>Acknowledgements</title><p id="P41">This research has been conducted using the UK Biobank Resource under Application Number 97908.</p><sec id="S22"><title>Funding</title><p id="P42">This work has been partly supported by NIH R35GM150579 to X.W.</p></sec></ack><fn-group><fn fn-type="COI-statement" id="FN1"><p id="P43"><italic toggle="yes">Conflict of Interest:</italic> none declared.</p></fn></fn-group><ref-list><title>References</title><ref id="R1"><mixed-citation publication-type="journal"><name><surname>Adrion</surname><given-names>J.R.</given-names></name>
<etal/> (<year>2020</year>) <article-title>A community-maintaiwned standard library of population genetic models</article-title>. <source>elife</source>, <volume>9</volume>, <fpage>e54967</fpage>.<pub-id pub-id-type="pmid">32573438</pub-id>
</mixed-citation></ref><ref id="R2"><mixed-citation publication-type="journal"><name><surname>Band</surname><given-names>G.</given-names></name> and <name><surname>Marchini</surname><given-names>J.</given-names></name> (<year>2018</year>) <article-title>Bgen: a binary file format for imputed genotype and haplotype data</article-title>. <source>bioRxiv</source>, <fpage>308296</fpage>.</mixed-citation></ref><ref id="R3"><mixed-citation publication-type="journal"><name><surname>Browning</surname><given-names>B.L.</given-names></name>
<etal/> (<year>2018</year>) <article-title>A one-penny imputed genome from next-generation reference panels</article-title>. <source>Am. J. Hum. Genet.</source>, <volume>103</volume>, <fpage>338</fpage>&#x02013;<lpage>348</lpage>.<pub-id pub-id-type="pmid">30100085</pub-id>
</mixed-citation></ref><ref id="R4"><mixed-citation publication-type="journal"><name><surname>Chang</surname><given-names>C.</given-names></name> (<year>2024</year>) <source>PLINK 2 File Format Specification Draft</source>.</mixed-citation></ref><ref id="R5"><mixed-citation publication-type="journal"><name><surname>Danecek</surname><given-names>P.</given-names></name>
<etal/> (<year>2011</year>) <article-title>The variant call format and VCFtools</article-title>. <source>Bioinformatics</source>, <volume>27</volume>, <fpage>2156</fpage>&#x02013;<lpage>2158</lpage>.<pub-id pub-id-type="pmid">21653522</pub-id>
</mixed-citation></ref><ref id="R6"><mixed-citation publication-type="journal"><name><surname>DeHaas</surname><given-names>D.</given-names></name>
<etal/> (<year>2024</year>) <article-title>Enabling efficient analysis of biobank-scale data with genotype representation graphs</article-title>. <source>Nat. Comput. Sci.</source>, <fpage>1</fpage>&#x02013;<lpage>13</lpage>.<pub-id pub-id-type="pmid">38287197</pub-id>
</mixed-citation></ref><ref id="R7"><mixed-citation publication-type="journal"><name><surname>Deorowicz</surname><given-names>S.</given-names></name> and <name><surname>Danek</surname><given-names>A.</given-names></name> (<year>2019</year>) <article-title>GTShark: genotype compression in large projects</article-title>. <source>Bioinformatics</source>, <volume>35</volume>, <fpage>4791</fpage>&#x02013;<lpage>4793</lpage>.<pub-id pub-id-type="pmid">31225861</pub-id>
</mixed-citation></ref><ref id="R8"><mixed-citation publication-type="journal"><name><surname>Hofmeister</surname><given-names>R.J.</given-names></name>
<etal/> (<year>2023</year>) <article-title>Accurate rare variant phasing of whole-genome and whole-exome sequencing data in the UK Biobank</article-title>. <source>Nat. Genet.</source>, <volume>55</volume>, <fpage>1243</fpage>&#x02013;<lpage>1249</lpage>.<pub-id pub-id-type="pmid">37386248</pub-id>
</mixed-citation></ref><ref id="R9"><mixed-citation publication-type="journal"><name><surname>Jouganous</surname><given-names>J.</given-names></name>
<etal/> (<year>2017</year>) <article-title>Inferring the joint demographic history of multiple populations: beyond the diffusion approximation</article-title>. <source>Genetics</source>, <volume>206</volume>, <fpage>1549</fpage>&#x02013;<lpage>1567</lpage>.<pub-id pub-id-type="pmid">28495960</pub-id>
</mixed-citation></ref><ref id="R10"><mixed-citation publication-type="journal"><name><surname>Kelleher</surname><given-names>J.</given-names></name>
<etal/> (<year>2016</year>) <article-title>Efficient coalescent simulation and genealogical analysis for large sample sizes</article-title>. <source>PLoS Comput. Biol.</source>, <volume>12</volume>, <fpage>e1004842</fpage>.<pub-id pub-id-type="pmid">27145223</pub-id>
</mixed-citation></ref><ref id="R11"><mixed-citation publication-type="journal"><name><surname>Lan</surname><given-names>D.</given-names></name>
<etal/> (<year>2021</year>) <article-title>Genozip: a universal extensible genomic data compressor</article-title>. <source>Bioinformatics</source>, <volume>37</volume>, <fpage>2225</fpage>&#x02013;<lpage>2230</lpage>.<pub-id pub-id-type="pmid">33585897</pub-id>
</mixed-citation></ref><ref id="R12"><mixed-citation publication-type="journal"><name><surname>LeFaive</surname><given-names>J.</given-names></name>
<etal/> (<year>2021</year>) <article-title>Sparse allele vectors and the savvy software suite</article-title>. <source>Bioinformatics</source>, <volume>37</volume>, <fpage>4248</fpage>&#x02013;<lpage>4250</lpage>.<pub-id pub-id-type="pmid">33989384</pub-id>
</mixed-citation></ref><ref id="R13"><mixed-citation publication-type="journal"><name><surname>Li</surname><given-names>H.</given-names></name> (<year>2011</year>) <article-title>A statistical framework for SNP calling, mutation discovery, association mapping and population genetical parameter estimation from sequencing data</article-title>. <source>Bioinformatics</source>, <volume>27</volume>, <fpage>2987</fpage>&#x02013;<lpage>2993</lpage>.<pub-id pub-id-type="pmid">21903627</pub-id>
</mixed-citation></ref><ref id="R14"><mixed-citation publication-type="confproc"><name><surname>Pezoa</surname><given-names>F.</given-names></name>
<etal/> (<year>2016</year>) <source>Foundations of JSON schema</source>. In, <conf-name>Proceedings of the 25th International Conference on World Wide Web. International World Wide Web Conferences Steering Committee</conf-name>, pp. <fpage>263</fpage>&#x02013;<lpage>273</lpage>.</mixed-citation></ref><ref id="R15"><mixed-citation publication-type="journal"><name><surname>Purcell</surname><given-names>S.</given-names></name>
<etal/> (<year>2007</year>) <article-title>PLINK: a tool set for whole-genome association and population-based linkage analyses</article-title>. <source>Am. J. Hum. Genet.</source>, <volume>81</volume>, <fpage>559</fpage>&#x02013;<lpage>575</lpage>.<pub-id pub-id-type="pmid">17701901</pub-id>
</mixed-citation></ref><ref id="R16"><mixed-citation publication-type="journal"><name><surname>Rivas</surname><given-names>M.A.</given-names></name> and <name><surname>Chang</surname><given-names>C.</given-names></name> (<year>2024</year>) <article-title>Efficient storage and regression computation for population-scale genome sequencing studies</article-title>. <source>bioRxiv.</source></mixed-citation></ref><ref id="R17"><mixed-citation publication-type="journal"><name><surname>Wertenbroek</surname><given-names>R.</given-names></name>
<etal/> (<year>2022</year>) <article-title>XSI&#x02014;a genotype compression tool for compressive genomics in large biobanks</article-title>. <source>Bioinformatics</source>, <volume>38</volume>, <fpage>3778</fpage>&#x02013;<lpage>3784</lpage>.<pub-id pub-id-type="pmid">35748697</pub-id>
</mixed-citation></ref></ref-list></back><floats-group><fig position="float" id="F1"><label>Fig. 1.</label><caption><title>IGD file layout.</title><p id="P44">The layout of an IGD file on disk. <inline-formula><mml:math id="M1" display="inline"><mml:mi>M</mml:mi></mml:math></inline-formula> is the number of variants, <inline-formula><mml:math id="M2" display="inline"><mml:mi>N</mml:mi></mml:math></inline-formula> is the number of individuals, and <inline-formula><mml:math id="M3" display="inline"><mml:mrow><mml:msub><mml:mi>N</mml:mi><mml:mi>H</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is the number of haploid samples. Genotype data rows may be either sparse (a list of haploid sample indexes containing the alternate allele) or dense (a bit-vector with a 1 at an index <inline-formula><mml:math id="M4" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> iff the <inline-formula><mml:math id="M5" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula><sup>th</sup> haploid sample contains the alternate allele).</p></caption><graphic xlink:href="nihpp-2025.02.05.636549v1-f0001" position="float"/></fig><fig position="float" id="F2"><label>Fig. 2.</label><caption><title>Comparison of file formats.</title><p id="P45">The upper panels show time to traverse the file for UK Biobank WGS data (left) and simulated data (right). The lower panels show the file sizes for UK Biobank WGS data (left) and simulated data (right).</p></caption><graphic xlink:href="nihpp-2025.02.05.636549v1-f0002" position="float"/></fig><fig position="float" id="F3"><label>Fig. 3.</label><caption><title>File format impact on GRG tree construction.</title><p id="P46">Genotype Representation Graph (GRG) tree construction time for .vcf.gz vs. IGD file formats, for small regions of the genome (x-axis) from a simulated dataset with 1 million haploid samples.</p></caption><graphic xlink:href="nihpp-2025.02.05.636549v1-f0003" position="float"/></fig><table-wrap position="float" id="T1"><label>Table 1.</label><caption><p id="P47">IGD header details</p></caption><table frame="hsides" rules="groups"><colgroup span="1"><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/></colgroup><thead><tr><th align="left" valign="top" rowspan="1" colspan="1">Byte offset</th><th align="left" valign="top" rowspan="1" colspan="1">Datatype</th><th align="left" valign="top" rowspan="1" colspan="1">Description</th></tr></thead><tbody><tr><td align="left" valign="top" rowspan="1" colspan="1">0</td><td align="left" valign="top" rowspan="1" colspan="1">uint64</td><td align="left" valign="top" rowspan="1" colspan="1">Magic number 0&#x000d7;3a0c6fd7945a3481</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">8</td><td align="left" valign="top" rowspan="1" colspan="1">uint64</td><td align="left" valign="top" rowspan="1" colspan="1">File format version</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">16</td><td align="left" valign="top" rowspan="1" colspan="1">uint32</td><td align="left" valign="top" rowspan="1" colspan="1">Ploidy</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">20</td><td align="left" valign="top" rowspan="1" colspan="1">uint32</td><td align="left" valign="top" rowspan="1" colspan="1">Sparsity threshold</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">24</td><td align="left" valign="top" rowspan="1" colspan="1">uint64</td><td align="left" valign="top" rowspan="1" colspan="1">Number of variants</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">32</td><td align="left" valign="top" rowspan="1" colspan="1">uint32</td><td align="left" valign="top" rowspan="1" colspan="1">Number of individuals <inline-formula><mml:math id="M6" display="inline"><mml:mi>N</mml:mi></mml:math></inline-formula></td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">36</td><td align="left" valign="top" rowspan="1" colspan="1">uint32</td><td align="left" valign="top" rowspan="1" colspan="1">Reserved for future use</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">40</td><td align="left" valign="top" rowspan="1" colspan="1">uint64</td><td align="left" valign="top" rowspan="1" colspan="1">64 bits of flags.</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">48</td><td align="left" valign="top" rowspan="1" colspan="1">uint64</td><td align="left" valign="top" rowspan="1" colspan="1">File offset where the <bold>Index</bold> is located</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">56</td><td align="left" valign="top" rowspan="1" colspan="1">uint64</td><td align="left" valign="top" rowspan="1" colspan="1">File offset where the <bold>Allele strings</bold> are located</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">64</td><td align="left" valign="top" rowspan="1" colspan="1">uint64</td><td align="left" valign="top" rowspan="1" colspan="1">File offset where the <bold>Individual IDs</bold> are located</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">72</td><td align="left" valign="top" rowspan="1" colspan="1">uint64</td><td align="left" valign="top" rowspan="1" colspan="1">File offset where the <bold>Variant IDs</bold> are located</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">80</td><td align="left" valign="top" rowspan="1" colspan="1">48 bytes</td><td align="left" valign="top" rowspan="1" colspan="1">Reserved for future use</td></tr></tbody></table></table-wrap><table-wrap position="float" id="T2"><label>Table 2.</label><caption><p id="P48">Conversion times from <italic toggle="yes">.vcf.gz</italic></p></caption><table frame="hsides" rules="groups"><colgroup span="1"><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/></colgroup><thead><tr><th align="left" valign="top" rowspan="1" colspan="1">Dataset</th><th align="left" valign="top" rowspan="1" colspan="1">File Format</th><th align="left" valign="top" rowspan="1" colspan="1">Conversion time (hours)</th></tr></thead><tbody><tr><td align="left" valign="top" rowspan="1" colspan="1">UKB chr. 22 (N=200k)</td><td align="left" valign="top" rowspan="1" colspan="1">BCF</td><td align="left" valign="top" rowspan="1" colspan="1">32.5</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">UKB chr. 22 (N=200k)</td><td align="left" valign="top" rowspan="1" colspan="1">PGEN</td><td align="left" valign="top" rowspan="1" colspan="1">13.6</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">UKB chr. 22 (N=200k)</td><td align="left" valign="top" rowspan="1" colspan="1">IGD</td><td align="left" valign="top" rowspan="1" colspan="1">21.3</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">Simulated (N=500k)</td><td align="left" valign="top" rowspan="1" colspan="1">BCF</td><td align="left" valign="top" rowspan="1" colspan="1">29.9</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">Simulated (N=500k)</td><td align="left" valign="top" rowspan="1" colspan="1">PGEN</td><td align="left" valign="top" rowspan="1" colspan="1">9.3</td></tr><tr><td align="left" valign="top" rowspan="1" colspan="1">Simulated (N=500k)</td><td align="left" valign="top" rowspan="1" colspan="1">IGD</td><td align="left" valign="top" rowspan="1" colspan="1">23.6</td></tr></tbody></table></table-wrap></floats-group></article>