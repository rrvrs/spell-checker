<!DOCTYPE article
PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD with MathML3 v1.3 20210610//EN" "JATS-archivearticle1-3-mathml3.dtd">
<article xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" dtd-version="1.3" xml:lang="en" article-type="research-article"><?properties open_access?><processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats"><restricted-by>pmc</restricted-by></processing-meta><front><journal-meta><journal-id journal-id-type="nlm-ta">bioRxiv</journal-id><journal-id journal-id-type="publisher-id">BIORXIV</journal-id><journal-title-group><journal-title>bioRxiv</journal-title></journal-title-group><issn pub-type="epub">2692-8205</issn><publisher><publisher-name>Cold Spring Harbor Laboratory</publisher-name></publisher></journal-meta>
<article-meta><article-id pub-id-type="pmid">39975111</article-id><article-id pub-id-type="pmc">PMC11838588</article-id>
<article-id pub-id-type="doi">10.1101/2025.02.04.636479</article-id><article-version-alternatives><article-version article-version-type="status">preprint</article-version><article-version article-version-type="number">1</article-version></article-version-alternatives><article-categories><subj-group subj-group-type="heading"><subject>Article</subject></subj-group></article-categories><title-group><article-title>Dynamic <italic toggle="yes">&#x003bc;</italic>-PBWT: Dynamic Run-length Compressed PBWT for Biobank Scale Data</article-title></title-group><contrib-group><contrib contrib-type="author"><contrib-id contrib-id-type="orcid" authenticated="false">http://orcid.org/0000-0003-2708-9933</contrib-id><name><surname>Shakya</surname><given-names>Pramesh</given-names></name><xref rid="A1" ref-type="aff">1</xref></contrib><contrib contrib-type="author"><name><surname>Sanaullah</surname><given-names>Ahsan</given-names></name><xref rid="A1" ref-type="aff">1</xref></contrib><contrib contrib-type="author"><contrib-id contrib-id-type="orcid" authenticated="false">http://orcid.org/0000-0001-7754-1890</contrib-id><name><surname>Zhi</surname><given-names>Degui</given-names></name><xref rid="A2" ref-type="aff">2</xref></contrib><contrib contrib-type="author"><contrib-id contrib-id-type="orcid" authenticated="false">http://orcid.org/0000-0002-4051-5549</contrib-id><name><surname>Zhang</surname><given-names>Shaojie</given-names></name><xref rid="A1" ref-type="aff">1</xref></contrib></contrib-group><aff id="A1"><label>1</label>Department of Computer Science, University of Central Florida , Orlando, FL, USA</aff><aff id="A2"><label>2</label>McWilliams School of Biomedical Informatics, University of Texas Health Science Center at Houston, Houston, TX, USA</aff><author-notes><corresp id="CR1">
<email>pramesh.shakya@ucf.edu</email>
</corresp></author-notes><pub-date pub-type="epub"><day>08</day><month>2</month><year>2025</year></pub-date><elocation-id>2025.02.04.636479</elocation-id><permissions><license><ali:license_ref xmlns:ali="http://www.niso.org/schemas/ali/1.0/" specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref><license-p>This work is licensed under a <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</ext-link>, which allows reusers to distribute, remix, adapt, and build upon the material in any medium or format, so long as attribution is given to the creator. The license allows for commercial use.</license-p></license></permissions><self-uri content-type="pdf">nihpp-2025.02.04.636479.pdf</self-uri><abstract id="ABS1"><p id="P1">Durbin&#x02019;s positional Burrows-Wheeler transform (PBWT) supports efficient haplotype matching and queries given a panel of haplotypes. It has been widely used for statistical phasing, imputation and identity-by-descent (IBD) detection. However, the original PBWT panel doesn&#x02019;t support dynamic updates when haplotypes need to be added or deleted from the panel. Dynamic-PBWT (d-PBWT) solved this problem but it is not memory efficient. While the memory constraint problem of the PBWT has been tackled by Syllable-PBWT and <inline-formula><mml:math id="M1" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT, these are static data structures that do not allow updates. Additionally, Syllable-PBWT only supports long-match query and <inline-formula><mml:math id="M2" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT only supports set-maximal match query, limiting their functionality in the compressed form. In this paper, we present Dynamic <inline-formula><mml:math id="M3" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT (which can also be seen as compressed d-PBWT) that is memory efficient and supports dynamic updates. We run-length compress PBWT to achieve better compression rate and store the runs in the self-balancing trees to enable dynamic updates. We show that the number of updates per insertion or deletion in the tree at each site is constant regardless of the number of haplotypes in the panel and the updates can be made without decompressing the index. In addition, we use orders of magnitude less memory than d-PBWT. We also provide a long match query algorithm that can easily be extended back to the original <inline-formula><mml:math id="M4" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT. Overall, the flexibility and space-efficiency of Dynamic <inline-formula><mml:math id="M5" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT makes it a potential index data structure for biobank scale genetic data analyses. The source code for Dynamic <inline-formula><mml:math id="M6" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT is available at <ext-link xlink:href="https://github.com/ucfcbb/Dynamic-mu-PBWT" ext-link-type="uri">https://github.com/ucfcbb/Dynamic-mu-PBWT</ext-link>.</p></abstract><kwd-group><kwd>Biobank</kwd><kwd>Haplotype Matching</kwd><kwd>PBWT</kwd><kwd>d-PBWT</kwd><kwd>Syllable-PBWT</kwd><kwd><italic toggle="yes">&#x003bc;</italic>-PBWT</kwd><kwd>Dynamic <italic toggle="yes">&#x003bc;</italic>-PBWT</kwd><kwd>Run-Length Compression</kwd></kwd-group></article-meta></front><body><sec id="S1"><label>1</label><title>Introduction</title><p id="P2">The positional Burrows Wheeler transform (PBWT) by Durbin [<xref rid="R8" ref-type="bibr">8</xref>] supports efficient haplotype matching and queries given a panel of haplotypes. It stores the reverse prefix sorting of the panel of haplotypes at each site and supports haplotype matching within the panel in time linear to the size of the panel. It also supports queries between a query haplotype and the panel in time independent to the size of the panel (only linear to the length of the genome). These efficient query capabilities have been used in many applications such as phasing [<xref rid="R3" ref-type="bibr">3</xref>, <xref rid="R7" ref-type="bibr">7</xref>, <xref rid="R12" ref-type="bibr">12</xref>], imputation [<xref rid="R16" ref-type="bibr">16</xref>], identity-by-descent (IBD) detection and genealogical analysis [<xref rid="R13" ref-type="bibr">13</xref>, <xref rid="R20" ref-type="bibr">20</xref>], and ancestry estimation [<xref rid="R21" ref-type="bibr">21</xref>]. For all vs all haplotype matching, memory-efficient scanning algorithms exist. However, for one vs all query searches, the PBWT data structure has to be stored in memory. Hence, the memory efficiency is a bottleneck for fast queries on biobank-scale data.</p><p id="P3">Several works have been proposed to compress PBWT for efficient storage and to allow fast queries. Syllable-PBWT [<xref rid="R19" ref-type="bibr">19</xref>] divides the haplotypes into syllables and builds the PBWT on the compressed syllables reducing the memory usage. It uses a polynomial rolling hash function for string comparison to allow fast long match queries, i.e., identifying all matches longer than a specified length threshold between a query haplotype and the panel. Its compression rate is a function of the syllable size and it offers up to about 100 fold reduction of memory usage. <inline-formula><mml:math id="M18" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT [<xref rid="R5" ref-type="bibr">5</xref>] uses run length encoding to compress the PBWT columns, providing a memory efficient alternative for representing the PBWT. It supports set maximal match queries, i.e., all the longest matches between a query haplotype and the panel that are not encompassed by another match. Its compression rate is a function of the number of runs in PBWT columns and offers better compression on panels with sequencing data compared to array data. However, static data structures like PBWT, <inline-formula><mml:math id="M19" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT and Syllable-PBWT do not support adding new haplotypes or removing existing haplotypes from the panel&#x02019;s PBWT data structure. To update the static PBWT one would have to rebuild it at a cost linear to the size of the panel. This becomes cumbersome to maintain a PBWT data structure for biobank-scale panels for which updates may be frequent (e.g., new participants may be frequently recruited and existing participants may drop off) and rebuilding is expensive as the cost is linear to the size of the panel.</p><p id="P4">Dynamic PBWT (d-PBWT) [<xref rid="R17" ref-type="bibr">17</xref>] solved this problem by replacing the array-based data structures of PBWT with linked lists. d-PBWT provides efficient algorithms to insert and delete a haplotype in time independent of the size of the panel. The authors estimate the time to insert a haplotype into the d-PBWT for the full UK Biobank whole genome array data to be 0.42 seconds and the estimated time to rebuild the PBWT to be 31.25 hours. However, d-PBWT is not memory efficient. It is estimated to consume approximately 29.8 terabytes of memory for holding the UK Biobank (UKB) genotype data [<xref rid="R4" ref-type="bibr">4</xref>] with 974,818 haplotypes and 640,000 sites. To make genetic analyses of biobank-scale genotype panel efficient, a data structure that is memory-efficient, supporting frequent haplotype updates, and allowing haplotype matching in its compressed format is needed. The recent trend of moving biobanks to the cloud would further aggravate such needs. For instance, the All of Us Research Program is completely cloud-based [<xref rid="R2" ref-type="bibr">2</xref>] and UK Biobank is set to move to a cloud-only environment [<xref rid="R18" ref-type="bibr">18</xref>]. This requires analysis tools to be efficient on all aspects as the correlation between computational efficiency and the cost of computation in the cloud is further highlighted with increasing database sizes.</p><p id="P5">In this paper, we present Dynamic <inline-formula><mml:math id="M20" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT (can also be seen as compressed d-PBWT) that is memory efficient and supports dynamic updates. We bring the flexibility of d-PBWT and the memory efficiencies of the static compressed PBWT together (see <xref rid="F1" ref-type="fig">Figure 1</xref>). To achieve memory efficiency, we run-length compress the PBWT columns and store these run-lengths in self balancing trees to support dynamic updates. This idea of storing run-lengths in self-balancing trees has been used in a BWT context for efficient construction of FM-index for sequencing reads [<xref rid="R9" ref-type="bibr">9</xref>, <xref rid="R11" ref-type="bibr">11</xref>]. Here we store the run-lengths of PBWT columns in self balancing trees and show that at each column the number of updates in the tree per insertion and deletion is constant. This makes inserting and deleting a haplotype from the panel efficient. Dynamic <inline-formula><mml:math id="M21" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT consumes 27 to 37 times less memory than d-PBWT but has 11 to 60 times slower insertion time. This is because we do not have constant time access to the haplotype data in the compressed format. Meanwhile, Dynamic <inline-formula><mml:math id="M22" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT has comparable query time with <inline-formula><mml:math id="M23" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT. It consumes approximately 27 to 33 times more memory than <inline-formula><mml:math id="M24" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT but inserts a haplotype in one thousandth of the time it would take <inline-formula><mml:math id="M25" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT to reconstruct with the new haplotype. Overall, dynamic <inline-formula><mml:math id="M26" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT offers a balanced efficiency for biobank-scale genetic analyses.</p></sec><sec id="S2"><label>2</label><title>Preliminaries</title><sec id="S3"><label>2.1</label><title>Positional Burrows Wheeler Transform</title><p id="P6">Positional Burrows-Wheeler Transform (PBWT) is a data structure by Durbin that allows efficient haplotype matching and querying [<xref rid="R8" ref-type="bibr">8</xref>]. The data structure utilizes a bi-allelic haplotype panel <inline-formula><mml:math id="M27" display="inline"><mml:mi>X</mml:mi></mml:math></inline-formula> that consists of <inline-formula><mml:math id="M28" display="inline"><mml:mi>M</mml:mi></mml:math></inline-formula> haplotypes and <inline-formula><mml:math id="M29" display="inline"><mml:mi>N</mml:mi></mml:math></inline-formula> sites. Each haplotype <inline-formula><mml:math id="M30" display="inline"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>&#x02208;</mml:mo><mml:mi>X</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M31" display="inline"><mml:mrow><mml:mn>0</mml:mn><mml:mo>&#x02264;</mml:mo><mml:mi>i</mml:mi><mml:mo>&#x0003c;</mml:mo><mml:mi>M</mml:mi></mml:mrow></mml:math></inline-formula> can have two values at every site i.e. <inline-formula><mml:math id="M32" display="inline"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mi>k</mml:mi></mml:mfenced><mml:mo>&#x02208;</mml:mo><mml:mfenced close="}" open="{"><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> where <inline-formula><mml:math id="M33" display="inline"><mml:mrow><mml:mn>0</mml:mn><mml:mo>&#x02264;</mml:mo><mml:mi>k</mml:mi><mml:mo>&#x0003c;</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula>. We denote the sequence <inline-formula><mml:math id="M34" display="inline"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> as <inline-formula><mml:math id="M35" display="inline"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mfenced close=")" open="["><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> and its subsequence as <inline-formula><mml:math id="M36" display="inline"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mfenced close=")" open="["><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> where <inline-formula><mml:math id="M37" display="inline"><mml:mrow><mml:mn>0</mml:mn><mml:mo>&#x02264;</mml:mo><mml:mi>s</mml:mi><mml:mo>&#x0003c;</mml:mo><mml:mi>e</mml:mi><mml:mo>&#x02264;</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula>. This data structure makes efficient query and haplotype matches by sorting every column of the panel in reverse-prefix order. This sorting groups haplotypes with similar reverse-prefixes. It mainly utilizes two data structures at each column namely, positional-prefix array, <inline-formula><mml:math id="M38" display="inline"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, and divergence array, <inline-formula><mml:math id="M39" display="inline"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for <inline-formula><mml:math id="M40" display="inline"><mml:mrow><mml:mn>0</mml:mn><mml:mo>&#x02264;</mml:mo><mml:mi>k</mml:mi><mml:mo>&#x02264;</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula>. The positional-prefix array, <inline-formula><mml:math id="M41" display="inline"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, is the permutation of the haplotype indices as a result of co-lexicographic ordering of the prefixes of length <inline-formula><mml:math id="M42" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula>. Similarly, the divergence array, <inline-formula><mml:math id="M43" display="inline"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, stores the starting position of the longest common suffix between a pair of haplotypes in the prefix array. More precisely, <inline-formula><mml:math id="M44" display="inline"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mi>i</mml:mi></mml:mfenced></mml:mrow></mml:math></inline-formula> stores the starting position of the longest common suffix between the haplotype corresponding to <inline-formula><mml:math id="M45" display="inline"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mi>i</mml:mi></mml:mfenced></mml:mrow></mml:math></inline-formula> and the haplotype in the preceding row in <inline-formula><mml:math id="M46" display="inline"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mrow><mml:mi>i</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>. A match between two haplotype sequences exists if all the allele values match for a range of sites. A match exists between the haplotype sequence <inline-formula><mml:math id="M47" display="inline"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M48" display="inline"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M49" display="inline"><mml:mrow><mml:mi>i</mml:mi><mml:mo>&#x02260;</mml:mo><mml:mi>j</mml:mi></mml:mrow></mml:math></inline-formula> if <inline-formula><mml:math id="M50" display="inline"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mfenced close=")" open="["><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mfenced close=")" open="["><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="M51" display="inline"><mml:mrow><mml:mn>0</mml:mn><mml:mo>&#x02264;</mml:mo><mml:mi>s</mml:mi><mml:mo>&#x0003c;</mml:mo><mml:mi>e</mml:mi><mml:mo>&#x02264;</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M52" display="inline"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mrow><mml:mi>s</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>&#x02260;</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mrow><mml:mi>s</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> or <inline-formula><mml:math id="M53" display="inline"><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="M54" display="inline"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mi>e</mml:mi></mml:mfenced><mml:mo>&#x02260;</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mi>e</mml:mi></mml:mfenced></mml:mrow></mml:math></inline-formula> or <inline-formula><mml:math id="M55" display="inline"><mml:mrow><mml:mi>e</mml:mi><mml:mo>=</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula>. Similarly, a long match is defined as a match that is at least length <inline-formula><mml:math id="M56" display="inline"><mml:mi>L</mml:mi></mml:math></inline-formula>, i.e. <inline-formula><mml:math id="M57" display="inline"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mfenced close=")" open="["><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mfenced close=")" open="["><mml:mrow><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>e</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M58" display="inline"><mml:mrow><mml:mi>e</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>s</mml:mi><mml:mo>&#x02265;</mml:mo><mml:mi>L</mml:mi></mml:mrow></mml:math></inline-formula>. One of the reasons PBWT is efficient is that its data structures can be constructed for every column in a single scan of the haplotype panel. For a column <inline-formula><mml:math id="M59" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula>, <inline-formula><mml:math id="M60" display="inline"><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M61" display="inline"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are arrays of length <inline-formula><mml:math id="M62" display="inline"><mml:mi>M</mml:mi></mml:math></inline-formula> where <inline-formula><mml:math id="M63" display="inline"><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mi>i</mml:mi></mml:mfenced></mml:mrow></mml:math></inline-formula> stores the number of zeros before <inline-formula><mml:math id="M64" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> for <inline-formula><mml:math id="M65" display="inline"><mml:mrow><mml:mi>i</mml:mi><mml:mo>&#x0003c;</mml:mo><mml:mi>M</mml:mi></mml:mrow></mml:math></inline-formula> and, <inline-formula><mml:math id="M66" display="inline"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mi>i</mml:mi></mml:mfenced></mml:mrow></mml:math></inline-formula> stores the number of ones before <inline-formula><mml:math id="M67" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> for <inline-formula><mml:math id="M68" display="inline"><mml:mrow><mml:mi>i</mml:mi><mml:mo>&#x0003c;</mml:mo><mml:mi>M</mml:mi></mml:mrow></mml:math></inline-formula>. <inline-formula><mml:math id="M69" display="inline"><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> stores the total number of zeros in column <inline-formula><mml:math id="M70" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula>. This enables PBWT to map the position of the <inline-formula><mml:math id="M71" display="inline"><mml:mrow><mml:msup><mml:mi>i</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> haplotype from the <inline-formula><mml:math id="M72" display="inline"><mml:mrow><mml:msup><mml:mi>k</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> column to the <inline-formula><mml:math id="M73" display="inline"><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:msup><mml:mn>1</mml:mn><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> column with a simple FL mapping, <inline-formula><mml:math id="M74" display="inline"><mml:mrow><mml:mi>F</mml:mi><mml:msub><mml:mi>L</mml:mi><mml:mi>b</mml:mi></mml:msub><mml:mfenced><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> where <inline-formula><mml:math id="M75" display="inline"><mml:mi>b</mml:mi></mml:math></inline-formula> is the <inline-formula><mml:math id="M76" display="inline"><mml:mrow><mml:msup><mml:mi>i</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> value in column <inline-formula><mml:math id="M77" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> of PBWT. Therefore, <inline-formula><mml:math id="M78" display="inline"><mml:mrow><mml:mi>F</mml:mi><mml:msub><mml:mi>L</mml:mi><mml:mi>b</mml:mi></mml:msub><mml:mfenced><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msub><mml:mi>u</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mi>i</mml:mi></mml:mfenced></mml:mrow></mml:math></inline-formula> if <inline-formula><mml:math id="M79" display="inline"><mml:mrow><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M80" display="inline"><mml:mrow><mml:mi>F</mml:mi><mml:msub><mml:mi>L</mml:mi><mml:mi>b</mml:mi></mml:msub><mml:mfenced><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>v</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mi>i</mml:mi></mml:mfenced></mml:mrow></mml:math></inline-formula> if <inline-formula><mml:math id="M81" display="inline"><mml:mrow><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>.</p></sec><sec id="S4"><label>2.2</label><title><inline-formula><mml:math id="M82" display="inline"><mml:mrow><mml:mspace width="0.5em"/><mml:mi>&#x003bc;</mml:mi></mml:mrow></mml:math></inline-formula>-PBWT overview</title><p id="P7"><inline-formula><mml:math id="M83" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT is a compressed representation of PBWT where every column of PBWT is run-length compressed [<xref rid="R5" ref-type="bibr">5</xref>]. A column <inline-formula><mml:math id="M84" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> of PBWT is defined as the <inline-formula><mml:math id="M85" display="inline"><mml:mrow><mml:msup><mml:mi>k</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> column of the haplotype panel where the haplotypes are reverse prefix sorted until <inline-formula><mml:math id="M86" display="inline"><mml:mrow><mml:mi>k</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Since every column of PBWT is run-length compressed, <inline-formula><mml:math id="M87" display="inline"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> denotes the number of runs in column <inline-formula><mml:math id="M88" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> of the PBWT, <inline-formula><mml:math id="M89" display="inline"><mml:mrow><mml:mn>0</mml:mn><mml:mo>&#x02264;</mml:mo><mml:mi>k</mml:mi><mml:mo>&#x0003c;</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="M90" display="inline"><mml:mi>r</mml:mi></mml:math></inline-formula> denotes the total number of runs in the PBWT panel, <inline-formula><mml:math id="M91" display="inline"><mml:mrow><mml:mi>r</mml:mi><mml:mo>=</mml:mo><mml:msubsup><mml:mo mathsize="big">&#x02211;</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow><mml:mrow><mml:mi>N</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>. Each column of PBWT is summarized with a few data structures. The following are the <inline-formula><mml:math id="M92" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT data structures for the <inline-formula><mml:math id="M93" display="inline"><mml:mrow><mml:msup><mml:mi>k</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> column of PBWT: <inline-formula><mml:math id="M94" display="inline"><mml:mrow><mml:msub><mml:mi>p</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mi>i</mml:mi></mml:mfenced></mml:mrow></mml:math></inline-formula> is head of a run i.e. the first index in the <inline-formula><mml:math id="M95" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula>-th run of the <inline-formula><mml:math id="M96" display="inline"><mml:mrow><mml:msup><mml:mi>k</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> column, <inline-formula><mml:math id="M97" display="inline"><mml:mrow><mml:msub><mml:mi>c</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> stores the number of zeros in column <inline-formula><mml:math id="M98" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula>, <inline-formula><mml:math id="M99" display="inline"><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> stores the bit-value of the first run in column <inline-formula><mml:math id="M100" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="M101" display="inline"><mml:mrow><mml:mi>u</mml:mi><mml:msub><mml:mi>v</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mi>i</mml:mi></mml:mfenced></mml:mrow></mml:math></inline-formula> is the number of <inline-formula><mml:math id="M102" display="inline"><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> bits before the <inline-formula><mml:math id="M103" display="inline"><mml:mrow><mml:msup><mml:mi>i</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> run in column <inline-formula><mml:math id="M104" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> if <inline-formula><mml:math id="M105" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> is odd, otherwise it is the number of <inline-formula><mml:math id="M106" display="inline"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:msub><mml:mi>b</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">&#x000af;</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> bits before the <inline-formula><mml:math id="M107" display="inline"><mml:mrow><mml:msup><mml:mi>i</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> run in column <inline-formula><mml:math id="M108" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula>.</p><p id="P8">The above data structures called the mapping structure allow us to move from <inline-formula><mml:math id="M109" display="inline"><mml:mrow><mml:msup><mml:mi>k</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> column to <inline-formula><mml:math id="M110" display="inline"><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:msup><mml:mn>1</mml:mn><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> column in <inline-formula><mml:math id="M111" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT. It should be noted that <inline-formula><mml:math id="M112" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT only stores prefix array values at the beginning and end of each run at each column and stores divergence values at the beginning of each run at each column. It also stores thresholds at each column which gives the position of the first maximum divergence value (minimum divergence value if divergence value is defined as length as in <inline-formula><mml:math id="M113" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT) in each run. Hence, the authors describe a <inline-formula><mml:math id="M114" display="inline"><mml:mrow><mml:mi>&#x003d5;</mml:mi><mml:mfenced><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> function which returns the value preceding <inline-formula><mml:math id="M115" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> in <inline-formula><mml:math id="M116" display="inline"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. i.e. if <inline-formula><mml:math id="M117" display="inline"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mi>j</mml:mi></mml:mfenced><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M118" display="inline"><mml:mrow><mml:mi>&#x003d5;</mml:mi><mml:mfenced><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mrow><mml:mi>j</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>. Its inverse, <inline-formula><mml:math id="M119" display="inline"><mml:mrow><mml:msup><mml:mi>&#x003d5;</mml:mi><mml:mo>&#x02212;1</mml:mo></mml:msup><mml:mfenced><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> returns the value following <inline-formula><mml:math id="M120" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> in <inline-formula><mml:math id="M121" display="inline"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, therefore <inline-formula><mml:math id="M122" display="inline"><mml:mrow><mml:msup><mml:mi>&#x003d5;</mml:mi><mml:mo>&#x02212;1</mml:mo></mml:msup><mml:mfenced><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>.</p><p id="P9">In this paper, we define a function <inline-formula><mml:math id="M123" display="inline"><mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced><mml:mi>i</mml:mi></mml:mfenced></mml:mrow></mml:math></inline-formula> that returns the divergence value of haplotype <inline-formula><mml:math id="M124" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> in column <inline-formula><mml:math id="M125" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> where <inline-formula><mml:math id="M126" display="inline"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mi>j</mml:mi></mml:mfenced><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>. By definition, this is the starting position of the match between <inline-formula><mml:math id="M127" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="M128" display="inline"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mrow><mml:mi>j</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>. If <inline-formula><mml:math id="M129" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> is not at the beginning of a run in column <inline-formula><mml:math id="M130" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula>, we wouldn&#x02019;t have access to the divergence value. Since divergence values are only sampled at the beginning of each run, we take the first column after <inline-formula><mml:math id="M131" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> (inclusive) where haplotype <inline-formula><mml:math id="M132" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> is at the top of a run. Say, <inline-formula><mml:math id="M133" display="inline"><mml:mi>j</mml:mi></mml:math></inline-formula>, <inline-formula><mml:math id="M134" display="inline"><mml:mrow><mml:mn>0</mml:mn><mml:mo>&#x02264;</mml:mo><mml:mi>k</mml:mi><mml:mo>&#x02264;</mml:mo><mml:mi>j</mml:mi><mml:mo>&#x0003c;</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula>, is the first column after <inline-formula><mml:math id="M135" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> where haplotype <inline-formula><mml:math id="M136" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> is at the top of a run and <inline-formula><mml:math id="M137" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> maps to row <inline-formula><mml:math id="M138" display="inline"><mml:mrow><mml:mi>i</mml:mi><mml:mo>&#x02032;</mml:mo></mml:mrow></mml:math></inline-formula> in <inline-formula><mml:math id="M139" display="inline"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M140" display="inline"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mrow><mml:mi>i</mml:mi><mml:mo>&#x02032;</mml:mo></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>, then the divergence value sampled here would be the same for haplotype <inline-formula><mml:math id="M141" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> at column <inline-formula><mml:math id="M142" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula>. Therefore, <inline-formula><mml:math id="M143" display="inline"><mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced><mml:mi>i</mml:mi></mml:mfenced><mml:mo>=</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mrow><mml:mi>i</mml:mi><mml:mo>&#x02032;</mml:mo></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>. It should be noted that <inline-formula><mml:math id="M144" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT defines divergence value as the length of the match which is functionally equivalent to our definition as the starting position of the match. <inline-formula><mml:math id="M145" display="inline"><mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced><mml:mi>i</mml:mi></mml:mfenced></mml:mrow></mml:math></inline-formula> can be computed efficiently by having an array for each haplotype when it is at the top of a run. Then a binary search can be performed to find the column after <inline-formula><mml:math id="M146" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> (including) when <inline-formula><mml:math id="M147" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> is at the top of the run. An efficient implementation can use any predecessor/successor data structure, for example, a sparse-bit vector.</p></sec></sec><sec id="S5"><label>3</label><title>Methods</title><sec id="S6"><label>3.1</label><title>Dynamic <inline-formula><mml:math id="M148" display="inline"><mml:mrow><mml:mspace width="0.5em"/><mml:mi>&#x003bc;</mml:mi></mml:mrow></mml:math></inline-formula>-PBWT</title><p id="P10">The Dynamic <inline-formula><mml:math id="M149" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT transforms the <inline-formula><mml:math id="M150" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT into a dynamic compressed structure. First, we run-length compress the PBWT columns inspired by <inline-formula><mml:math id="M151" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT. Then, we make it dynamic by storing runs in a self-balancing tree in each column. Typically, dynamic bit vectors store the sequence of bits in the leaves of a self balancing tree [<xref rid="R14" ref-type="bibr">14</xref>, <xref rid="R15" ref-type="bibr">15</xref>]. However, in our case, we propose to store run-length compressed bits in the leaves of such trees. In theory, any self-balancing tree could be used for this purpose but we choose B+ tree for memory efficiency and better cache usage. The key idea here is to maintain a B+ tree at each column of PBWT to store the runs in its leaves to allow efficient insertion and deletion of a haplotype.</p><p id="P11">B+ trees are generalized binary search trees where each node can store multiple keys. A B+ tree consists of a root node, internal nodes and leaf nodes. Note that B+ trees only store data at the leaf nodes unlike B trees. It is defined by the minimum degree <inline-formula><mml:math id="M152" display="inline"><mml:mi>t</mml:mi></mml:math></inline-formula>, <inline-formula><mml:math id="M153" display="inline"><mml:mrow><mml:mi>t</mml:mi><mml:mo>&#x02265;</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula>, where each node can have at most <inline-formula><mml:math id="M154" display="inline"><mml:mrow><mml:mn>2</mml:mn><mml:mi>t</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> keys and each node should have at least <inline-formula><mml:math id="M155" display="inline"><mml:mrow><mml:mi>t</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> keys (except the root node). A node is considered full when it has the maximum number of keys. Each node <inline-formula><mml:math id="M156" display="inline"><mml:mi>x</mml:mi></mml:math></inline-formula> stores <inline-formula><mml:math id="M157" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> keys and have <inline-formula><mml:math id="M158" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>n</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> children. Each key in an internal node stores information about the number of bits in <inline-formula><mml:math id="M159" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>n</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula>, number of ones in <inline-formula><mml:math id="M160" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> and number of runs in <inline-formula><mml:math id="M161" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>r</mml:mi><mml:mi>u</mml:mi><mml:mi>n</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> for <inline-formula><mml:math id="M162" display="inline"><mml:mrow><mml:mn>1</mml:mn><mml:mo>&#x02264;</mml:mo><mml:mi>i</mml:mi><mml:mo>&#x02264;</mml:mo><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>. We define the number of bits in a tree rooted at <inline-formula><mml:math id="M163" display="inline"><mml:mi>y</mml:mi></mml:math></inline-formula> as the sum of the number of bits in all of its subtrees. Then, <inline-formula><mml:math id="M164" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>n</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula> stores the sum of the number of bits in all the subtrees to the left of it i.e. sum of the number of bits in all the subtrees rooted at <inline-formula><mml:math id="M165" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> where <inline-formula><mml:math id="M166" display="inline"><mml:mrow><mml:mn>1</mml:mn><mml:mo>&#x02264;</mml:mo><mml:mi>k</mml:mi><mml:mo>&#x02264;</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>. Similarly, <inline-formula><mml:math id="M167" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> stores the number of ones in all the subtrees rooted at <inline-formula><mml:math id="M168" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for <inline-formula><mml:math id="M169" display="inline"><mml:mrow><mml:mn>1</mml:mn><mml:mo>&#x02264;</mml:mo><mml:mi>k</mml:mi><mml:mo>&#x02264;</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M170" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>r</mml:mi><mml:mi>u</mml:mi><mml:mi>n</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> store the number of runs in all the subtrees rooted at <inline-formula><mml:math id="M171" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> for <inline-formula><mml:math id="M172" display="inline"><mml:mrow><mml:mn>1</mml:mn><mml:mo>&#x02264;</mml:mo><mml:mi>k</mml:mi><mml:mo>&#x02264;</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>. However, the keys in a leaf node store a pair of runs. The <inline-formula><mml:math id="M173" display="inline"><mml:mrow><mml:msup><mml:mi>i</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> key in a leaf node stores the number of bits in a run of zeros in <inline-formula><mml:math id="M174" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>f</mml:mi></mml:mrow></mml:math></inline-formula> and the number of bits in a run of ones in <inline-formula><mml:math id="M175" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> in this order. Here onwards, we use trees to refer to B+ trees for simplicity.</p><p id="P12"><xref rid="F2" ref-type="fig">Figure 2</xref> shows the tree representation of a run-length compressed PBWT column. <xref rid="F2" ref-type="fig">Figure 2A</xref> shows a haplotype panel of 20 haplotypes and 15 sites. This panel is reverse prefix sorted by the reversed prefixes of length <inline-formula><mml:math id="M176" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> for each column <inline-formula><mml:math id="M177" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> and those PBWT columns are shown in <xref rid="F2" ref-type="fig">Figure 2B</xref>. The light gray squares show the runs of zeros and the dark gray squares show the run of ones. Each PBWT column is then run-length compressed to obtain <xref rid="F2" ref-type="fig">Figure 2C</xref>. <xref rid="F2" ref-type="fig">Figure 2D</xref> shows the B+ tree of minimum degree <inline-formula><mml:math id="M178" display="inline"><mml:mrow><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> storing the runs of the second column of PBWT, i.e., 00001000010010110000. We observe that there are <inline-formula><mml:math id="M179" display="inline"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mn>9</mml:mn></mml:mrow></mml:math></inline-formula> runs in this PBWT column. Each key of the leaf stores a pair of runs distinguished by the light and dark gray bands below the leaves. The leftmost key of the root node shows that there are <inline-formula><mml:math id="M180" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>.</mml:mo><mml:mi>n</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>10</mml:mn></mml:mrow></mml:math></inline-formula> bits in leaves of all the subtrees to the left of it. Of the 10 bits <inline-formula><mml:math id="M181" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>.</mml:mo><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:math></inline-formula> are ones and they all together constitute <inline-formula><mml:math id="M182" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>.</mml:mo><mml:mi>r</mml:mi><mml:mi>u</mml:mi><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> runs. Note that the root&#x02019;s second key stores information about the runs in all the child subtrees to the left of it. Hence, <inline-formula><mml:math id="M183" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>.</mml:mo><mml:mi>n</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mo>=</mml:mo><mml:mn>16</mml:mn></mml:mrow></mml:math></inline-formula> as it stores the number of bits in the two leaves to the left of it. Similarly, <inline-formula><mml:math id="M184" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>.</mml:mo><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>5</mml:mn></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="M185" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mn>2</mml:mn></mml:msub><mml:mo>.</mml:mo><mml:mi>r</mml:mi><mml:mi>u</mml:mi><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>8</mml:mn></mml:mrow></mml:math></inline-formula>. The leftmost key in the leftmost leaf node stores the run of zeros with <inline-formula><mml:math id="M186" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>.</mml:mo><mml:mi>f</mml:mi><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> bits and the run of ones with <inline-formula><mml:math id="M187" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>.</mml:mo><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> bits. The rightmost key of the rightmost leaf node stores only the run of zeros as <inline-formula><mml:math id="M188" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>.</mml:mo><mml:mi>f</mml:mi><mml:mo>=</mml:mo><mml:mn>4</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M189" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>.</mml:mo><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>.</p><sec id="S7"><title>FL mapping</title><p id="P13">We require the primary functionality in PBWT of mapping <inline-formula><mml:math id="M190" display="inline"><mml:mrow><mml:msup><mml:mi>i</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> haplotype in column <inline-formula><mml:math id="M191" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> to column <inline-formula><mml:math id="M192" display="inline"><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. We need <inline-formula><mml:math id="M193" display="inline"><mml:mrow><mml:msub><mml:mi>u</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mi>i</mml:mi></mml:mfenced></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M194" display="inline"><mml:mrow><mml:msub><mml:mi>v</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mi>i</mml:mi></mml:mfenced></mml:mrow></mml:math></inline-formula> values for this. We compute this by traversing the tree at column <inline-formula><mml:math id="M195" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> from the root node to the leaf node tracking the number of zeros and number of ones that exist before <inline-formula><mml:math id="M196" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula>. Then, we find the respective key in the leaf node and calculate the <inline-formula><mml:math id="M197" display="inline"><mml:mi>u</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="M198" display="inline"><mml:mi>v</mml:mi></mml:math></inline-formula> values from the run lengths stored at the leaf nodes. We define <inline-formula><mml:math id="M199" display="inline"><mml:mrow><mml:mi>u</mml:mi><mml:mi>v</mml:mi><mml:mfenced><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>z</mml:mi><mml:mo>,</mml:mo><mml:mi>o</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> as a function that calculates the <inline-formula><mml:math id="M200" display="inline"><mml:mi>u</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="M201" display="inline"><mml:mi>v</mml:mi></mml:math></inline-formula> values before <inline-formula><mml:math id="M202" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> in the tree rooted at <inline-formula><mml:math id="M203" display="inline"><mml:mi>x</mml:mi></mml:math></inline-formula>. We track the number of zeros and ones we have seen so far with <inline-formula><mml:math id="M204" display="inline"><mml:mi>z</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="M205" display="inline"><mml:mi>o</mml:mi></mml:math></inline-formula>. For a given index <inline-formula><mml:math id="M206" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula>, we start at the root node and iterate through the keys to find the first key with <inline-formula><mml:math id="M207" display="inline"><mml:mrow><mml:mi>n</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula> greater than <inline-formula><mml:math id="M208" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula>. If <inline-formula><mml:math id="M209" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is the first key such that <inline-formula><mml:math id="M210" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>n</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mo>&#x0003e;</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M211" display="inline"><mml:mrow><mml:mn>1</mml:mn><mml:mo>&#x02264;</mml:mo><mml:mi>j</mml:mi><mml:mo>&#x02264;</mml:mo><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula>, we traverse down the corresponding child node <inline-formula><mml:math id="M212" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> with adjusted index <inline-formula><mml:math id="M213" display="inline"><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mi>i</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>&#x02212;1</mml:mo></mml:mrow></mml:msub><mml:mo>.</mml:mo><mml:mi>n</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M214" display="inline"><mml:mrow><mml:mi>j</mml:mi><mml:mo>&#x0003e;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. The number of zeros and ones seen so far is calculated from the preceding key as <inline-formula><mml:math id="M215" display="inline"><mml:mrow><mml:mi>z</mml:mi><mml:mo>=</mml:mo><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>&#x02212;1</mml:mo></mml:mrow></mml:msub><mml:mo>.</mml:mo><mml:mi>n</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>&#x02212;1</mml:mo></mml:mrow></mml:msub><mml:mo>.</mml:mo><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M216" display="inline"><mml:mrow><mml:mi>o</mml:mi><mml:mo>=</mml:mo><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mrow><mml:mi>j</mml:mi><mml:mo>&#x02212;1</mml:mo></mml:mrow></mml:msub><mml:mo>.</mml:mo><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>. When we are at the leaf node, we find the key and the run within the key where <inline-formula><mml:math id="M217" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> falls into. We do this by iterating over all the keys tracking the cumulative sum of the values of the keys in <inline-formula><mml:math id="M218" display="inline"><mml:mrow><mml:mi>s</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula>. The first key where the sum is greater than <inline-formula><mml:math id="M219" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> is our desired key. Next, we find if <inline-formula><mml:math id="M220" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> is in a run of zeros or a run of ones within the key. It is in a run of ones if the index is greater than or equal to the difference of the cumulative sum and the number of bits in the run of ones, i.e., <inline-formula><mml:math id="M221" display="inline"><mml:mrow><mml:mi>i</mml:mi><mml:mo>&#x02265;</mml:mo><mml:mi>s</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>. If not, it lies in the run of zeros. We can calculate the offset of <inline-formula><mml:math id="M222" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> from the head of run and get the number of zeros and ones before <inline-formula><mml:math id="M223" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> (see <xref rid="P39" ref-type="other">Algorithm 1</xref> in <xref rid="APP1" ref-type="app">Appendix</xref>). The time complexity to compute this is <inline-formula><mml:math id="M224" display="inline"><mml:mrow><mml:mi>O</mml:mi><mml:mfenced><mml:mrow><mml:mtext>log</mml:mtext><mml:mspace width="0.5em"/><mml:msub><mml:mi>r</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>. This enables us to successfully map the <inline-formula><mml:math id="M225" display="inline"><mml:mrow><mml:msup><mml:mi>i</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> haplotype from column <inline-formula><mml:math id="M226" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> to column <inline-formula><mml:math id="M227" display="inline"><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. We define this mapping functionality as an extension function <inline-formula><mml:math id="M228" display="inline"><mml:mrow><mml:mi>w</mml:mi><mml:mfenced><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M229" display="inline"><mml:mrow><mml:mi>v</mml:mi><mml:mo>&#x02208;</mml:mo><mml:mfenced close="}" open="{"><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> where it maps haplotype <inline-formula><mml:math id="M230" display="inline"><mml:mrow><mml:mi>i</mml:mi><mml:mi>d</mml:mi></mml:mrow></mml:math></inline-formula> at the <inline-formula><mml:math id="M232" display="inline"><mml:mrow><mml:msup><mml:mi>i</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> position in column <inline-formula><mml:math id="M233" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> with allele <inline-formula><mml:math id="M234" display="inline"><mml:mi>v</mml:mi></mml:math></inline-formula> to column <inline-formula><mml:math id="M235" display="inline"><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> and also returns the haplotype id in column <inline-formula><mml:math id="M236" display="inline"><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. <inline-formula><mml:math id="M237" display="inline"><mml:mi>x</mml:mi></mml:math></inline-formula> is the root node of the tree at column <inline-formula><mml:math id="M238" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> (see <xref rid="P40" ref-type="other">Algorithm 2</xref> in <xref rid="APP1" ref-type="app">Appendix</xref>). Note that we can also find the run index of <inline-formula><mml:math id="M239" display="inline"><mml:mrow><mml:msup><mml:mi>i</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> haplotype at a column by traversing the tree in a similar manner.</p></sec><sec id="S8"><title>B+ trees for Dynamic <inline-formula><mml:math id="M240" display="inline"><mml:mrow><mml:mspace width="0.5em"/><mml:mi>&#x003bc;</mml:mi></mml:mrow></mml:math></inline-formula>-PBWT</title><p id="P14">For each column of PBWT, we store the run lengths, prefix array samples at the start and end of each run, and the divergence values at the start of each run in B+ trees for efficient insertion and deletion of a haplotype in Dynamic <inline-formula><mml:math id="M241" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT. For each haplotype, we also maintain a B+ tree that stores the haplotypes above it for all the columns where it is at a start of a run. Similarly, for each haplotype, we maintain another B+ tree that stores the haplotypes below it for all the columns where it is at the bottom of a run. These haplotypes are stored in the B+ tree in order of the columns where they appear at the start or bottom of a run. This allows us to efficiently update the tree when a new haplotype is inserted in place of the other haplotype at either of the run boundaries. This enables the <inline-formula><mml:math id="M242" display="inline"><mml:mi>&#x003d5;</mml:mi></mml:math></inline-formula> functionality from <inline-formula><mml:math id="M243" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT in Dynamic <inline-formula><mml:math id="M244" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT. Additionally, we also store the total number of zeros in each column and the starting bit at each column.</p><p id="P15">There are some key differences in the way we update the B+ trees in Dynamic <inline-formula><mml:math id="M245" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT from general B+ trees. During insertion, we traverse the tree from the root node to the leaf node and find the right key of the leaf node to update. With each insertion, the appropriate keys (and their parameters) of the internal nodes in the path are also updated. Whenever a node is full, i.e. there are <inline-formula><mml:math id="M246" display="inline"><mml:mrow><mml:mn>2</mml:mn><mml:mi>t</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> keys, the node is split into two nodes. First, we explain how to split a full node <inline-formula><mml:math id="M247" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> with a non full parent node <inline-formula><mml:math id="M248" display="inline"><mml:mi>x</mml:mi></mml:math></inline-formula>. The splitting of a leaf node is handled differently from that of an internal node. When splitting a leaf node <inline-formula><mml:math id="M249" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, first we create a new leaf node. Then, <inline-formula><mml:math id="M250" display="inline"><mml:mrow><mml:mi>t</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> keys after the median key in <inline-formula><mml:math id="M251" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are moved to the new leaf node. The split leaf node <inline-formula><mml:math id="M252" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> will contain <inline-formula><mml:math id="M253" display="inline"><mml:mi>t</mml:mi></mml:math></inline-formula> keys instead of <inline-formula><mml:math id="M254" display="inline"><mml:mrow><mml:mi>t</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> keys. A new key is inserted in the parent node <inline-formula><mml:math id="M255" display="inline"><mml:mi>x</mml:mi></mml:math></inline-formula> as <inline-formula><mml:math id="M256" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> where <inline-formula><mml:math id="M257" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>n</mml:mi><mml:mi>u</mml:mi><mml:mi>m</mml:mi></mml:mrow></mml:math></inline-formula> is the number of bits in <inline-formula><mml:math id="M258" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M259" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> is the number of ones in <inline-formula><mml:math id="M260" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M261" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>r</mml:mi><mml:mi>u</mml:mi><mml:mi>n</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> is the number of runs in <inline-formula><mml:math id="M262" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>. Finally, all the keys following <inline-formula><mml:math id="M263" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (including <inline-formula><mml:math id="M264" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>) in <inline-formula><mml:math id="M265" display="inline"><mml:mi>x</mml:mi></mml:math></inline-formula> are updated to reflect the changes after insertion (see <xref rid="P41" ref-type="other">Algorithm 3</xref> in <xref rid="APP1" ref-type="app">Appendix</xref>).</p><p id="P16">If the parent node <inline-formula><mml:math id="M266" display="inline"><mml:mi>x</mml:mi></mml:math></inline-formula> is not full after inserting the new key <inline-formula><mml:math id="M267" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, we stop. However, if it is full, we split it following the rules of splitting an internal node. Here, we define <inline-formula><mml:math id="M268" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> as the full internal node and <inline-formula><mml:math id="M269" display="inline"><mml:mi>x</mml:mi></mml:math></inline-formula> as its non full parent node. To split <inline-formula><mml:math id="M270" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, first we create a new internal node. The <inline-formula><mml:math id="M271" display="inline"><mml:mrow><mml:mi>t</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> keys to the right of the median key of <inline-formula><mml:math id="M272" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:msub><mml:mi>c</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> are moved into the new node. For every key moved into the new node, its parameters are adjusted by subtracting its <italic toggle="yes">num</italic>, <italic toggle="yes">ones</italic>, and <italic toggle="yes">runs</italic> values from its preceding key. Then the median key is inserted into the parent node as <inline-formula><mml:math id="M273" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> and all the keys following <inline-formula><mml:math id="M274" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> (including <inline-formula><mml:math id="M275" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>) are updated (see <xref rid="P42" ref-type="other">Algorithm 4</xref> in <xref rid="APP1" ref-type="app">Appendix</xref>). As in B+ tree, the split is propagated upwards until a non-full internal node is found. If we do not find a non-full internal node and the split continues to the root node, a new root node as the parent of the existing root node is created. Then, the old root node is split. This would increase the height of the tree by one.</p></sec></sec><sec id="S9"><label>3.2</label><title>Insertion</title><sec id="S10"><title>Update insert positions and divergence values in PBWT</title><p id="P17">The insertion algorithm inserts a new haplotype <inline-formula><mml:math id="M276" display="inline"><mml:mi>z</mml:mi></mml:math></inline-formula> into the Dynamic <inline-formula><mml:math id="M277" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT. First, the insert positions in PBWT of the new haplotype are calculated at each column. We compute this by tracking the position of the haplotype that would be below the inserted haplotype at each column if <inline-formula><mml:math id="M278" display="inline"><mml:mi>z</mml:mi></mml:math></inline-formula> were in the PBWT. We define <inline-formula><mml:math id="M279" display="inline"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> as the haplotype that would be below the inserted haplotype at column <inline-formula><mml:math id="M280" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula>. <inline-formula><mml:math id="M281" display="inline"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> stores two parameters <inline-formula><mml:math id="M282" display="inline"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M283" display="inline"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>I</mml:mi><mml:mi>D</mml:mi></mml:mrow></mml:math></inline-formula>. <inline-formula><mml:math id="M284" display="inline"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> is the index of haplotype <inline-formula><mml:math id="M285" display="inline"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>I</mml:mi><mml:mi>D</mml:mi></mml:mrow></mml:math></inline-formula> in <inline-formula><mml:math id="M286" display="inline"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>, i.e., <inline-formula><mml:math id="M287" display="inline"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>I</mml:mi><mml:mi>D</mml:mi></mml:mrow></mml:math></inline-formula>. We map the position of this haplotype from column <inline-formula><mml:math id="M288" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> to column <inline-formula><mml:math id="M289" display="inline"><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> using the extension function as <inline-formula><mml:math id="M290" display="inline"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi>w</mml:mi><mml:mfenced><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi><mml:mo>,</mml:mo><mml:mi>z</mml:mi><mml:mfenced close="]" open="["><mml:mi>k</mml:mi></mml:mfenced><mml:mo>,</mml:mo><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>I</mml:mi><mml:mi>D</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>. This process is the same as computing the matching statistic of <inline-formula><mml:math id="M291" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT and the virtual insertion algorithm in d-PBWT.</p><p id="P18">The next step is to update the divergence values of the inserted haplotype, <inline-formula><mml:math id="M292" display="inline"><mml:mi>z</mml:mi></mml:math></inline-formula>, and the haplotype below it at every column. To compute this, we scan the panel from right to left and compute the arrays <inline-formula><mml:math id="M293" display="inline"><mml:mrow><mml:mi>z</mml:mi><mml:mi>S</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M294" display="inline"><mml:mrow><mml:mi>t</mml:mi><mml:mi>S</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:math></inline-formula>. We define <inline-formula><mml:math id="M295" display="inline"><mml:mrow><mml:mi>z</mml:mi><mml:mi>S</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M296" display="inline"><mml:mrow><mml:mi>t</mml:mi><mml:mi>S</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:math></inline-formula> as two arrays of length <inline-formula><mml:math id="M297" display="inline"><mml:mrow><mml:mi>N</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> that store the divergence values of <inline-formula><mml:math id="M298" display="inline"><mml:mi>z</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="M299" display="inline"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> at each column if <inline-formula><mml:math id="M300" display="inline"><mml:mi>z</mml:mi></mml:math></inline-formula> were in the PBWT. <inline-formula><mml:math id="M301" display="inline"><mml:mrow><mml:mi>z</mml:mi><mml:mi>S</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mi>t</mml:mi><mml:mfenced close="]" open="["><mml:mi>k</mml:mi></mml:mfenced></mml:mrow></mml:math></inline-formula> is the divergence value of <inline-formula><mml:math id="M302" display="inline"><mml:mi>z</mml:mi></mml:math></inline-formula> at column <inline-formula><mml:math id="M303" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="M304" display="inline"><mml:mrow><mml:mi>t</mml:mi><mml:mi>S</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mi>t</mml:mi><mml:mfenced close="]" open="["><mml:mi>k</mml:mi></mml:mfenced></mml:mrow></mml:math></inline-formula> is the divergence value of <inline-formula><mml:math id="M305" display="inline"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> at column <inline-formula><mml:math id="M306" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula>. Therefore, for <inline-formula><mml:math id="M307" display="inline"><mml:mrow><mml:mi>z</mml:mi><mml:mi>S</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mi>t</mml:mi><mml:mfenced close="]" open="["><mml:mi>k</mml:mi></mml:mfenced><mml:mo>:</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msub><mml:mfenced close=")" open="["><mml:mrow><mml:mi>z</mml:mi><mml:mi>S</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mi>t</mml:mi><mml:mfenced close="]" open="["><mml:mi>k</mml:mi></mml:mfenced><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>z</mml:mi><mml:mfenced close=")" open="["><mml:mrow><mml:mi>z</mml:mi><mml:mi>S</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mi>t</mml:mi><mml:mfenced close="]" open="["><mml:mi>k</mml:mi></mml:mfenced><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> where <inline-formula><mml:math id="M308" display="inline"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msub><mml:mfenced close="]" open="["><mml:mrow><mml:mi>z</mml:mi><mml:mi>S</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mi>t</mml:mi><mml:mfenced close="]" open="["><mml:mi>k</mml:mi></mml:mfenced><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>&#x02260;</mml:mo><mml:mi>z</mml:mi><mml:mfenced close="]" open="["><mml:mrow><mml:mi>z</mml:mi><mml:mi>S</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mi>t</mml:mi><mml:mfenced close="]" open="["><mml:mi>k</mml:mi></mml:mfenced><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> or <inline-formula><mml:math id="M309" display="inline"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> and, <inline-formula><mml:math id="M310" display="inline"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msub><mml:mfenced close="]" open="["><mml:mi>k</mml:mi></mml:mfenced><mml:mo>&#x02260;</mml:mo><mml:mi>z</mml:mi><mml:mfenced close="]" open="["><mml:mi>k</mml:mi></mml:mfenced></mml:mrow></mml:math></inline-formula> or <inline-formula><mml:math id="M311" display="inline"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula>. Similarly, for <inline-formula><mml:math id="M312" display="inline"><mml:mrow><mml:mi>t</mml:mi><mml:mi>S</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mi>t</mml:mi><mml:mfenced close="]" open="["><mml:mi>k</mml:mi></mml:mfenced><mml:mo>:</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msub><mml:mfenced close=")" open="["><mml:mrow><mml:mi>t</mml:mi><mml:mi>S</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mi>t</mml:mi><mml:mfenced close="]" open="["><mml:mi>k</mml:mi></mml:mfenced><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced><mml:mo>=</mml:mo><mml:mi>z</mml:mi><mml:mfenced close=")" open="["><mml:mrow><mml:mi>t</mml:mi><mml:mi>S</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mi>t</mml:mi><mml:mfenced close="]" open="["><mml:mi>k</mml:mi></mml:mfenced><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> where <inline-formula><mml:math id="M313" display="inline"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi><mml:mn>&#x02212;1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:msub><mml:mfenced close="]" open="["><mml:mrow><mml:mi>t</mml:mi><mml:mi>S</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mi>t</mml:mi><mml:mfenced close="]" open="["><mml:mi>k</mml:mi></mml:mfenced><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced><mml:mo>&#x02260;</mml:mo><mml:mi>z</mml:mi><mml:mfenced close="]" open="["><mml:mrow><mml:mi>t</mml:mi><mml:mi>S</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>r</mml:mi><mml:mi>t</mml:mi><mml:mfenced close="]" open="["><mml:mi>k</mml:mi></mml:mfenced><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> or <inline-formula><mml:math id="M314" display="inline"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M315" display="inline"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>p</mml:mi><mml:mi>o</mml:mi><mml:mi>s</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:msub><mml:mfenced close="]" open="["><mml:mi>k</mml:mi></mml:mfenced><mml:mo>&#x02260;</mml:mo><mml:mi>z</mml:mi><mml:mfenced close="]" open="["><mml:mi>k</mml:mi></mml:mfenced></mml:mrow></mml:math></inline-formula> or <inline-formula><mml:math id="M316" display="inline"><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula>. For haplotype <inline-formula><mml:math id="M317" display="inline"><mml:mi>z</mml:mi></mml:math></inline-formula>, we need to access the haplotype above it to compute the divergence values. We get this haplotype using <inline-formula><mml:math id="M318" display="inline"><mml:mrow><mml:mi>&#x003d5;</mml:mi><mml:mfenced><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>I</mml:mi><mml:mi>D</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>. We define <inline-formula><mml:math id="M319" display="inline"><mml:mrow><mml:mi>b</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>g</mml:mi><mml:mi>h</mml:mi></mml:msub><mml:mspace width="0.5em"/></mml:mrow></mml:math></inline-formula> as the number of times haplotype <inline-formula><mml:math id="M320" display="inline"><mml:mi>h</mml:mi></mml:math></inline-formula> is at the beginning of a run across all columns and, <inline-formula><mml:math id="M321" display="inline"><mml:mrow><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:msub><mml:mi>d</mml:mi><mml:mi>h</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> as the number of times haplotype <inline-formula><mml:math id="M322" display="inline"><mml:mi>h</mml:mi></mml:math></inline-formula> is at the end of a run across all columns. Then, the time complexity to compute <inline-formula><mml:math id="M323" display="inline"><mml:mrow><mml:mi>&#x003d5;</mml:mi><mml:mfenced><mml:mrow><mml:mi>h</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> is <inline-formula><mml:math id="M324" display="inline"><mml:mrow><mml:mi>O</mml:mi><mml:mfenced><mml:mrow><mml:mtext>log</mml:mtext><mml:mspace width="0.5em"/><mml:mi>b</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>g</mml:mi><mml:mi>h</mml:mi></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>. Similarly, the time complexity to compute <inline-formula><mml:math id="M325" display="inline"><mml:mrow><mml:msup><mml:mi>&#x003d5;</mml:mi><mml:mo>&#x02212;1</mml:mo></mml:msup><mml:mfenced><mml:mrow><mml:mi>h</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> is . Next, we compare the alleles between <inline-formula><mml:math id="M326" display="inline"><mml:mi>z</mml:mi></mml:math></inline-formula> and <inline-formula><mml:math id="M327" display="inline"><mml:mrow><mml:mi>&#x003d5;</mml:mi><mml:mfenced><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>I</mml:mi><mml:mi>D</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> until there&#x02019;s a mismatch. Similarly, the divergence value for <inline-formula><mml:math id="M328" display="inline"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> is also computed by comparing the alleles between <inline-formula><mml:math id="M329" display="inline"><mml:mrow><mml:msub><mml:mi>t</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>I</mml:mi><mml:mi>D</mml:mi></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M330" display="inline"><mml:mi>z</mml:mi></mml:math></inline-formula> until there&#x02019;s a mismatch (see <xref rid="P43" ref-type="other">Algorithm 5</xref> in <xref rid="APP1" ref-type="app">Appendix</xref>). It should be noted that the divergence value at any column <inline-formula><mml:math id="M331" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> for any haplotype is at least the divergence value at <inline-formula><mml:math id="M332" display="inline"><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> column, i.e., <inline-formula><mml:math id="M333" display="inline"><mml:mrow><mml:msub><mml:mi>d</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mi>i</mml:mi></mml:mfenced><mml:mo>&#x02264;</mml:mo><mml:msub><mml:mi>d</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mfenced close="]" open="["><mml:mi>i</mml:mi></mml:mfenced></mml:mrow></mml:math></inline-formula> [<xref rid="R17" ref-type="bibr">17</xref>]. Therefore, the divergence values should be updated in <inline-formula><mml:math id="M334" display="inline"><mml:mrow><mml:mi>O</mml:mi><mml:mfenced><mml:mi>N</mml:mi></mml:mfenced></mml:mrow></mml:math></inline-formula> runtime if we have constant time access to any haplotype. However, we do not have constant time access to this information as we only store prefix array samples at the start and end of each run at each column and only store the divergence values at the start of each run at each column. Hence, the computation of divergence values is worst case <inline-formula><mml:math id="M335" display="inline"><mml:mrow><mml:mi>O</mml:mi><mml:mfenced><mml:mrow><mml:msup><mml:mi>N</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mspace width="0.5em"/><mml:mtext>log</mml:mtext><mml:mspace width="0.5em"/><mml:mi>a</mml:mi><mml:mo>+</mml:mo><mml:mi>N</mml:mi><mml:mspace width="0.5em"/><mml:mtext>log</mml:mtext><mml:mspace width="0.5em"/><mml:mi>b</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>. Here, <inline-formula><mml:math id="M336" display="inline"><mml:mi>a</mml:mi></mml:math></inline-formula> is the maximum number of runs across all columns, i.e., <inline-formula><mml:math id="M337" display="inline"><mml:mrow><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:mtext>max</mml:mtext><mml:mfenced><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mi>k</mml:mi></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>, <inline-formula><mml:math id="M338" display="inline"><mml:mrow><mml:mn>0</mml:mn><mml:mo>&#x02264;</mml:mo><mml:mi>k</mml:mi><mml:mo>&#x0003c;</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:math></inline-formula> and, <inline-formula><mml:math id="M339" display="inline"><mml:mi>b</mml:mi></mml:math></inline-formula> is the maximum number of times any haplotype is at the start or end of a run, i.e., <inline-formula><mml:math id="M340" display="inline"><mml:mrow><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mtext>max</mml:mtext><mml:mfenced><mml:mrow><mml:mtext>max</mml:mtext><mml:mfenced><mml:mrow><mml:mi>b</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>g</mml:mi><mml:mi>h</mml:mi></mml:msub></mml:mrow></mml:mfenced><mml:mo>,</mml:mo><mml:mtext>max</mml:mtext><mml:mfenced><mml:mrow><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:msub><mml:mi>d</mml:mi><mml:mi>h</mml:mi></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> for <inline-formula><mml:math id="M341" display="inline"><mml:mrow><mml:mn>0</mml:mn><mml:mspace width="0.5em"/><mml:mo>&#x02264;</mml:mo><mml:mi>h</mml:mi><mml:mo>&#x0003c;</mml:mo><mml:mi>M</mml:mi></mml:mrow></mml:math></inline-formula>.</p></sec><sec id="S11"><title>Update B+ trees</title><p id="P19">The final step is to update all Dynamic <inline-formula><mml:math id="M342" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT B+ trees one column at a time in a forward sweep. Here, we explain the process of updating the runs stored in a B+ tree at a single column. This process will be the same to update all other B+ trees of Dynamic <inline-formula><mml:math id="M343" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT.</p><p id="P20">The insertion in a column can result in three scenarios, namely, updating the existing run, inserting a new run or splitting the existing run to insert a new run. We define the insertion operation at a column as <inline-formula><mml:math id="M344" display="inline"><mml:mrow><mml:mi>I</mml:mi><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>t</mml:mi><mml:mn>0</mml:mn><mml:mfenced><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> when we&#x02019;re inserting 0 at index <inline-formula><mml:math id="M345" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> in a tree rooted at <inline-formula><mml:math id="M346" display="inline"><mml:mi>x</mml:mi></mml:math></inline-formula>. Similarly, we define <inline-formula><mml:math id="M347" display="inline"><mml:mrow><mml:mi>I</mml:mi><mml:mi>n</mml:mi><mml:mi>s</mml:mi><mml:mi>e</mml:mi><mml:mi>r</mml:mi><mml:mi>t</mml:mi><mml:mn>1</mml:mn><mml:mfenced><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> as insertion of 1 at index <inline-formula><mml:math id="M348" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> in a tree rooted at <inline-formula><mml:math id="M349" display="inline"><mml:mi>x</mml:mi></mml:math></inline-formula>. The simplest case is when the inserted bit matches the bit-value of the run at the insert location. Here, the existing run is incremented by 1. The equivalent tree operation is to traverse the tree down to the leaf node to increment the value in the corresponding key of the leaf node by 1. Note that all the keys and their parameters are updated to reflect the change on the path from the leaf node back to the root node (see <xref rid="P44" ref-type="other">Algorithms 6</xref> and <xref rid="P45" ref-type="other">7</xref> in <xref rid="APP1" ref-type="app">Appendix</xref>).</p><p id="P21">The second case of inserting a new run only happens when inserting at the top or bottom of a column and the inserted bit does not match the bit-value of the run. The equivalent tree operation would be to insert a new key in the leftmost or rightmost leaf node. We traverse the tree from the root node to the leaf node and insert the new run as a key. If the leaf node becomes full, it is split and the split is propagated upwards to the root. A special case is inserting a new run of one at the top of a column that starts with a run of zeros. This is equivalent to inserting a key with value [0, 1] in the left-most leaf node. We traverse the tree down to the leftmost leaf node. When we&#x02019;re at the leftmost leaf node, we shift all the existing keys to the right by one position and insert the new key at the leftmost position as <inline-formula><mml:math id="M350" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>.</mml:mo><mml:mi>f</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M351" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>.</mml:mo><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. If the leaf node becomes full, we split it as discussed before. Note that, if we&#x02019;re inserting at run boundaries (except when it&#x02019;s at the top or bottom of a column) and the inserted bit does not match the bit-value of the run, the neighboring run is updated.</p><p id="P22">Finally, the third case of a run being split happens when we insert a bit that does not match the bit-value of the run and it is not at a run boundary. For example, if we insert a 1 in a run of zeros or vice-versa, the existing run would be split to insert the bit. This is equivalent to inserting the new key in the leaf node. If <inline-formula><mml:math id="M352" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>j</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula> contains the run to be split, we move all the keys from <inline-formula><mml:math id="M353" display="inline"><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula> to <inline-formula><mml:math id="M354" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:math></inline-formula> to the right by one position. We then insert a new key in <inline-formula><mml:math id="M355" display="inline"><mml:mrow><mml:mi>j</mml:mi><mml:mo>+</mml:mo><mml:msup><mml:mn>1</mml:mn><mml:mrow><mml:mi>t</mml:mi><mml:mi>h</mml:mi></mml:mrow></mml:msup></mml:mrow></mml:math></inline-formula> position. If a run of zeros is being split, we move the run of ones at <inline-formula><mml:math id="M356" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula> to the new key i.e., <inline-formula><mml:math id="M357" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:msub><mml:mi>key</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>.</mml:mo><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></inline-formula>. Then, we calculate the left half of the split and the right half of the split. The left half of the split is assigned to <inline-formula><mml:math id="M358" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>f</mml:mi></mml:mrow></mml:math></inline-formula>. The new inserted bit is updated at <inline-formula><mml:math id="M359" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. Then, the right half of the split is updated at <inline-formula><mml:math id="M360" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:msub><mml:mi mathvariant="italic">key</mml:mi><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>.</mml:mo><mml:mi>f</mml:mi></mml:mrow></mml:math></inline-formula>. If inserting this new key makes the leaf node full, it is split and the split is propagated upwards (see <xref rid="P46" ref-type="other">Algorithm 8</xref> in the <xref rid="APP1" ref-type="app">Appendix</xref>). We observe that for each of these cases, the number of updates made in the tree is constant however, the time complexity for each of these updates is a function of the number of runs in the tree.</p><p id="P23"><xref rid="F3" ref-type="fig">Figure 3</xref> shows the different cases when a new haplotype <inline-formula><mml:math id="M361" display="inline"><mml:mi>z</mml:mi></mml:math></inline-formula> is inserted. <xref rid="F3" ref-type="fig">Figure 3A</xref> shows the run-length compressed panel before and after insertion. The black boxes show the insert positions of the new haplotype <inline-formula><mml:math id="M362" display="inline"><mml:mi>z</mml:mi></mml:math></inline-formula> in each column. The figure on the right shows the updated panel after insertion. The existing runs being updated after insertion are shown by the orange boxes. A new run is being inserted at the bottom of column 7 as the inserted bit 1 does not match the bit-value of the last run i.e. 0. The new runs created are shown by blue boxes. Columns 3 and 6 show the runs being split after inserting a 1 in a run of zeros. The run that was split is shown by a dotted orange box. Note that every time a run is split, the total number of runs in a column increases by two. <xref rid="F3" ref-type="fig">Figure 3B</xref> shows how the tree corresponding to column 3 is updated during insertion. The bold letters show the values that are to be updated or have been updated. The leftmost tree is the initial tree where the leaf node with the pair of values [<xref rid="R8" ref-type="bibr">8</xref>, <xref rid="R3" ref-type="bibr">3</xref>] is about to be updated. Since the run of eight zeros is being split, a new key [<xref rid="R4" ref-type="bibr">4</xref>, <xref rid="R3" ref-type="bibr">3</xref>] is inserted into the leaf node as shown in the middle tree. As this leads to the leaf node to become full, we split the leaf node as shown in the rightmost tree. Here, a new key is added to the root node (shown by the bold letters) which show the number of bits, number of ones and number of runs in the leaves of all the subtrees to the left of it.</p><p id="P24">So far, we explained the process of updating the runs stored in a B+ tree. Since we also store the prefix array samples and divergence value samples in B+ trees, these are also updated during insertion. The prefix array samples are only updated when the new haplotype is inserted at the start or end of a run. This is equivalent to updating the leaf of a tree to replace the old start or end of a run with the new haplotype. The prefix array samples are also updated when an existing run is split. In this case, the inserted haplotype and the haplotype below it become the new start of runs. Hence, these haplotypes are inserted into the tree. Similarly, the divergence values are also updated when the new haplotype is inserted at the start or the end of a run. If the new haplotype is inserted at the start of a run, the divergence value of the old start of run is replaced by the divergence value of the newly inserted haplotype (except when it is at the top of a column). However, if the new haplotype is inserted at the end of a run, the divergence value of the haplotype below is updated (except when it is at the bottom of the column). The <inline-formula><mml:math id="M363" display="inline"><mml:mi>&#x003d5;</mml:mi></mml:math></inline-formula> data structure is also updated to store a B+ tree for the newly inserted haplotype to contain all the haplotypes above it and below it for any column where it is at the start or end of a run. Additionally, for any haplotype when the haplotypes above and below change at the run boundaries because of the inserted haplotype, those are also updated accordingly. The time complexity to update the trees across all columns is <inline-formula><mml:math id="M364" display="inline"><mml:mrow><mml:mi>O</mml:mi><mml:mfenced><mml:mrow><mml:mi>N</mml:mi><mml:mspace width="0.5em"/><mml:mtext>log</mml:mtext><mml:mspace width="0.5em"/><mml:mi>a</mml:mi><mml:mo>+</mml:mo><mml:mi>N</mml:mi><mml:mspace width="0.5em"/><mml:mtext>log</mml:mtext><mml:mspace width="0.5em"/><mml:mi>b</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>. Hence, the overall time complexity of insertion is <inline-formula><mml:math id="M365" display="inline"><mml:mrow><mml:mi>O</mml:mi><mml:mfenced><mml:mrow><mml:msup><mml:mi>N</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mspace width="0.5em"/><mml:mtext>log</mml:mtext><mml:mspace width="0.5em"/><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="M366" display="inline"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mtext>max</mml:mtext><mml:mfenced><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>.</p></sec></sec><sec id="S12"><label>3.3</label><title>Deletion</title><p id="P25">To delete a haplotype from Dynamic <inline-formula><mml:math id="M367" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT, first we find the positions of the haplotype to be deleted in PBWT and its respective bit values in all the columns. This can easily be computed using the extension function. Then we delete a single bit at each position one column at a time. We define <inline-formula><mml:math id="M368" display="inline"><mml:mrow><mml:mi>D</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mi>e</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mn>0</mml:mn><mml:mfenced><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> as deletion of a 0 bit at index <inline-formula><mml:math id="M369" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> in a tree rooted at <inline-formula><mml:math id="M370" display="inline"><mml:mi>x</mml:mi></mml:math></inline-formula> in a column. Similarly, we define <inline-formula><mml:math id="M371" display="inline"><mml:mrow><mml:mi>D</mml:mi><mml:mi>e</mml:mi><mml:mi>l</mml:mi><mml:mi>e</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mn>1</mml:mn><mml:mfenced><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> as deletion of 1 at index <inline-formula><mml:math id="M372" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> in a tree rooted at <inline-formula><mml:math id="M373" display="inline"><mml:mi>x</mml:mi></mml:math></inline-formula> in a column. We delete a bit by traversing the tree from the root node to the leaf node as before. When we are at the leaf node, we locate the right key and decrement the run value by one. The special case of deletion occurs when we delete a run. In this case, if we delete a run of ones, then the two flanking runs of zeros will be merged and vice-versa (except when the deleted run is at the top or bottom of a column). If a run of zeros is deleted from a leaf node <inline-formula><mml:math id="M374" display="inline"><mml:mi>x</mml:mi></mml:math></inline-formula> at the key index <inline-formula><mml:math id="M375" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula>, this would result in <inline-formula><mml:math id="M376" display="inline"><mml:mrow><mml:mi>x</mml:mi><mml:mo>.</mml:mo><mml:mi>k</mml:mi><mml:mi>e</mml:mi><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>.</mml:mo><mml:mi>f</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:math></inline-formula>. Then, we would merge the run of ones of the current key with a predecessor key within the same node. If the predecessor key within the same node does not exist we merge it with the last key of a predecessor leaf node. Similarly, if a run of ones would be deleted, the current key&#x02019;s run of zeros is merged with a successor key in the same node or the first key in the successor leaf node. After merging the values of the current key and updating the internal nodes&#x02019; keys (and their parameters) appropriately we can delete the key from the tree following B+ tree deletion. If leaf node has less than the minimum number of keys after deletion, the tree will be rebalanced to maintain B+ tree properties (see <xref rid="P47" ref-type="other">Algorithms 9</xref> and <xref rid="P48" ref-type="other">10</xref> in <xref rid="APP1" ref-type="app">Appendix</xref>). Similar to the insertion process, we also update the prefix array samples, divergence samples and the <inline-formula><mml:math id="M377" display="inline"><mml:mi>&#x003d5;</mml:mi></mml:math></inline-formula> data structure. The overall time complexity for deletion operation is <inline-formula><mml:math id="M378" display="inline"><mml:mrow><mml:mi>O</mml:mi><mml:mfenced><mml:mrow><mml:mi>N</mml:mi><mml:mspace width="0.5em"/><mml:mtext>log</mml:mtext><mml:mspace width="0.5em"/><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>.</p></sec><sec id="S13"><label>3.4</label><title>Long match query</title><p id="P26">The haplotype long match query problem is to find all matches that are at least length <inline-formula><mml:math id="M379" display="inline"><mml:mi>L</mml:mi></mml:math></inline-formula> between a query haplotype <inline-formula><mml:math id="M380" display="inline"><mml:mi>z</mml:mi></mml:math></inline-formula> and the Dynamic <inline-formula><mml:math id="M381" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT (or static <inline-formula><mml:math id="M382" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT) index of haplotype panel X. To find all long matches, we virtually insert the query haplotype, compute the divergence values and find the matches that satisfy the length cutoff.</p><p id="P27">We virtually insert the query haplotype <inline-formula><mml:math id="M383" display="inline"><mml:mi>z</mml:mi></mml:math></inline-formula> into the panel by tracking the haplotype that would be below <inline-formula><mml:math id="M384" display="inline"><mml:mi>z</mml:mi></mml:math></inline-formula> if it was inserted into the panel. Then, we calculate the divergence values for the query haplotype and the haplotype below it if <inline-formula><mml:math id="M385" display="inline"><mml:mi>z</mml:mi></mml:math></inline-formula> would be in the panel. This process is similar to the insertion process described in <xref rid="S9" ref-type="sec">section 3.2</xref>. Once the divergence values are updated, the <inline-formula><mml:math id="M386" display="inline"><mml:mi>L</mml:mi></mml:math></inline-formula>-long matches are found by tracking the matching blocks. Matching blocks are the block of sequences that match with <inline-formula><mml:math id="M387" display="inline"><mml:mi>z</mml:mi></mml:math></inline-formula> at least length <inline-formula><mml:math id="M388" display="inline"><mml:mi>L</mml:mi></mml:math></inline-formula>. Here, we adapt the long match query algorithm from d-PBWT [<xref rid="R17" ref-type="bibr">17</xref>] to Dynamic <inline-formula><mml:math id="M389" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT data structures. <xref rid="P49" ref-type="other">Algorithm 11</xref> describes the details of using Dynamic <inline-formula><mml:math id="M390" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT data structures. We use <inline-formula><mml:math id="M391" display="inline"><mml:mrow><mml:msub><mml:mi>D</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced><mml:mi>i</mml:mi></mml:mfenced></mml:mrow></mml:math></inline-formula> to access the divergence value for haplotype <inline-formula><mml:math id="M392" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula>, <inline-formula><mml:math id="M393" display="inline"><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mi>k</mml:mi></mml:msub><mml:mfenced close="]" open="["><mml:mi>j</mml:mi></mml:mfenced><mml:mo>=</mml:mo><mml:mi>i</mml:mi></mml:mrow></mml:math></inline-formula>, and <inline-formula><mml:math id="M394" display="inline"><mml:mrow><mml:mi>&#x003d5;</mml:mi><mml:mfenced><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced><mml:mfenced><mml:mrow><mml:msup><mml:mi>&#x003d5;</mml:mi><mml:mo>&#x02212;1</mml:mo></mml:msup><mml:mfenced><mml:mrow><mml:mi>i</mml:mi><mml:mo>,</mml:mo><mml:mi>k</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> to access the haplotype preceding (or following) haplotype <inline-formula><mml:math id="M395" display="inline"><mml:mi>i</mml:mi></mml:math></inline-formula> in column <inline-formula><mml:math id="M396" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> (see <xref rid="P49" ref-type="other">Algorithm 11</xref> in <xref rid="APP1" ref-type="app">Appendix</xref>). The time complexity of virtually inserting the haplotype and calculating the divergence values is <inline-formula><mml:math id="M397" display="inline"><mml:mrow><mml:mi>O</mml:mi><mml:mfenced><mml:mrow><mml:msup><mml:mi>N</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mspace width="0.5em"/><mml:mtext>log</mml:mtext><mml:mspace width="0.5em"/><mml:mi>a</mml:mi><mml:mo>+</mml:mo><mml:mi>N</mml:mi><mml:mspace width="0.5em"/><mml:mtext>log</mml:mtext><mml:mspace width="0.5em"/><mml:mi>b</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> where <inline-formula><mml:math id="M398" display="inline"><mml:mi>a</mml:mi></mml:math></inline-formula> is the maximum number of runs across all columns and <inline-formula><mml:math id="M399" display="inline"><mml:mi>b</mml:mi></mml:math></inline-formula> is the maximum number of times any haplotype is at the top or bottom of a run. The time complexity of the query algorithm is <inline-formula><mml:math id="M400" display="inline"><mml:mrow><mml:mi>O</mml:mi><mml:mfenced><mml:mrow><mml:mfenced close="|" open="|"><mml:mrow><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi><mml:mi>p</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfenced><mml:mtext>log</mml:mtext><mml:mspace width="0.5em"/><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>, where <inline-formula><mml:math id="M401" display="inline"><mml:mrow><mml:mfenced close="|" open="|"><mml:mrow><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi><mml:mi>p</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> is the total number of matches outputted and <inline-formula><mml:math id="M402" display="inline"><mml:mrow><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mtext>max</mml:mtext><mml:mfenced><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>. Hence, the overall long match query algorithm is <inline-formula><mml:math id="M403" display="inline"><mml:mrow><mml:mi>O</mml:mi><mml:mfenced><mml:mrow><mml:msup><mml:mi>N</mml:mi><mml:mn>2</mml:mn></mml:msup><mml:mspace width="0.5em"/><mml:mtext>log</mml:mtext><mml:mspace width="0.5em"/><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mfenced close="|" open="|"><mml:mrow><mml:mi>o</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi><mml:mi>p</mml:mi><mml:mi>u</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mfenced><mml:mtext>log</mml:mtext><mml:mspace width="0.5em"/><mml:msub><mml:mi>r</mml:mi><mml:mrow><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>. It should be noted that the process of virtual insertion and divergence value calculation is similar to the computation of the matching statistic data structure, <inline-formula><mml:math id="M404" display="inline"><mml:mi>A</mml:mi></mml:math></inline-formula>, in <inline-formula><mml:math id="M405" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT [<xref rid="R5" ref-type="bibr">5</xref>]. Hence, this algorithm can be easily extended to support long match query in <inline-formula><mml:math id="M406" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT.</p></sec></sec><sec id="S14"><label>4</label><title>Results</title><sec id="S15"><label>4.1</label><title>Data</title><p id="P28">We tested Dynamic <inline-formula><mml:math id="M407" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT on datasets of UK Biobank (UKB) [<xref rid="R4" ref-type="bibr">4</xref>] and 1000 Genomes Project (1KGP) [<xref rid="R1" ref-type="bibr">1</xref>]. The 1KGP dataset is filtered to retain only bi-allelic SNPs using bcftools [<xref rid="R6" ref-type="bibr">6</xref>] with the command &#x0201c;bcftools view -m2 -M2 -vSNPS". The UKB dataset has 974,818 haplotypes (487,409 individuals) and approximately 700,000 sites. Similarly, the 1KGP dataset has 5008 haplotypes (2504 individuals) and 77,818,346 sites after filtering. We use the DYNAMIC [<xref rid="R15" ref-type="bibr">15</xref>] library to implement B+ trees and implement the Dynamic <inline-formula><mml:math id="M408" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT data structures.</p></sec><sec id="S16"><label>4.2</label><title>Construction time and memory</title><p id="P29">We compared the construction time and memory consumption of Dynamic <inline-formula><mml:math id="M409" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT with <inline-formula><mml:math id="M410" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT, Syllable-PBWT and d-PBWT. For the comparison on UKB data, we randomly sample 50,000 haplotypes for each chromsome. For 1KGP data, we use 5008 haplotypes across all autosomes. We compared the construction time between Dynamic <inline-formula><mml:math id="M411" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT, <inline-formula><mml:math id="M412" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT and Syllable-PBWT on both datasets. We do not compare construction time with d-PBWT as it does not have a separate construction method. The construction time of Dynamic <inline-formula><mml:math id="M413" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT is comparable to <inline-formula><mml:math id="M414" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT on both datasets whereas Syllable-PBWT is roughly 5&#x02013;7 times faster than both Dynamic <inline-formula><mml:math id="M415" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT and static <inline-formula><mml:math id="M416" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT as shown in <xref rid="F4" ref-type="fig">Figure 4</xref>.</p><p id="P30"><xref rid="F5" ref-type="fig">Figure 5A</xref> shows the memory comparison on 1KGP data and <xref rid="F5" ref-type="fig">Figure 5B</xref> shows the memory comparison on the subsetted panel of UKB data. The gray + sign in both figures show the estimated d-PBWT memory usage. We estimated d-PBWT memory usage on these data using 48 bytes per site per haplotype estimate from the authors [<xref rid="R17" ref-type="bibr">17</xref>]. We observe that Dynamic <inline-formula><mml:math id="M417" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT consumes approximately 26 times less memory than d-PBWT on all the autosomes of 1KGP data but it consumes roughly 27 to 33 times more memory than <inline-formula><mml:math id="M418" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT and Syllable-PBWT. On the subsetted UKB data, Dynamic <inline-formula><mml:math id="M419" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT consumes approximately 2.5 times more memory than <inline-formula><mml:math id="M420" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT and 8&#x02013;12 times more memory than Syllable-PBWT but it consumes 36 times less memory than d-PBWT. We show that Dynamic <inline-formula><mml:math id="M421" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT consumes more memory than its static compressed counterparts to support dynamic updates. However, it consumes significantly less memory compared to d-PBWT.</p></sec><sec id="S17"><label>4.3</label><title>Insertion and deletion</title><p id="P31">We tested the insertion and deletion time of Dynamic <inline-formula><mml:math id="M422" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT on chromosome 21 of 1KGP data with 1,054,447 sites and on a subpanel of chromosome 21 of UKB data with 9793 sites. For the UKB data, we randomly sampled 100,000 haplotypes from 974,818 haplotypes. We test the insertion time by inserting one haplotype at a time into the Dynamic <inline-formula><mml:math id="M423" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT in random order. We test the deletion time by first building the Dynamic <inline-formula><mml:math id="M424" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT and deleting one haplotype at a time in random order. Each insertion and deletion was timed. The insertion times and deletion times per haplotype were averaged every 100 haplotypes and those 1000 points are plotted in <xref rid="F6" ref-type="fig">Figure 6</xref>. <xref rid="F6" ref-type="fig">Figure 6A</xref> shows the average insertion time per haplotype for 1KGP data in relation to the database size respectively. <xref rid="F6" ref-type="fig">Figure 6B</xref> shows the average deletion time per haplotype on 1KGP data. <xref rid="F6" ref-type="fig">Figure 6</xref> (<xref rid="F6" ref-type="fig">C</xref>, <xref rid="F6" ref-type="fig">D</xref>) shows the average insertion and deletion time for UKB data in relation to the database size respectively. We observe that it takes approximately 1500 milliseconds to insert a single haplotype and approximately 3000 milliseconds to delete a single haplotype for chromosome 21 of 1KGP data. For the subsetted chromosome 21 panel of UKB data, it takes approximately 150 milliseconds to insert and approximately 350 milliseconds to delete a single haplotype. The insertion and deletion time increases sublinearly to the number of haplotypes for the UKB data. This is expected as the insertion and deletion times are a function of the number of runs in the PBWT. However, this relationship is as not as distinct for 1KGP data. This may be due to the smaller panel size of 1KGP data. The deletion time is roughly two times that of insertion time because we reinsert the bottom haplotype inplace of the deleted haplotype when the haplotype is deleted from the middle of the panel. We reinsert the bottom haplotype so that the haplotype indices in the panel remain in the range <inline-formula><mml:math id="M425" display="inline"><mml:mrow><mml:mfenced close=")" open="["><mml:mrow><mml:mn>0</mml:mn><mml:mo>,</mml:mo><mml:mi>M</mml:mi></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula>.</p><p id="P32">The average insertion time of d-PBWT for chromosome 21 of 1KGP was 0.27 seconds and the average deletion time was 0.21 seconds. The average insertion time of d-PBWT on the subpanel of UKB data was 0.0025 seconds and the average deletion time was 0.0022 seconds. Dynamic <inline-formula><mml:math id="M426" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT consumed 9.09 GB and d-PBWT consumed 241.43 GB for 1KGP data. Dynamic <inline-formula><mml:math id="M427" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT consumed 1.31 GB and d-PBWT consumed 44.83 GB on the subpanel of UKB data. For 1KGP data Dynamic <inline-formula><mml:math id="M428" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT is roughly 5&#x02013;14 times as slow as d-PBWT but takes 27 times less memory than d-PBWT. For the subpanel of UKB data, Dynamic <inline-formula><mml:math id="M429" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT is roughly 60&#x02013;160 times slower than d-PBWT but consumes approximately 37 times more memory than d-PBWT. Therefore, Dynamic <inline-formula><mml:math id="M430" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT consumes approximately 1.84 bytes per site per haplotype for 1KGP data and approximately 1.5 bytes per site per haplotype for UKB data.</p></sec><sec id="S18"><label>4.4</label><title>Long match query</title><p id="P33">We also tested the long match query algorithm on chromosome 21 of UK Biobank data. For this experiment, we queried 400 haplotypes against reference panels with 1000, 5000, 10000, 50000 and 100000 haplotypes for a length cutoff of 2000 sites. <xref rid="T1" ref-type="table">Table 1</xref> shows the average query time per haplotype for different reference panel sizes. We observe that the query time per haplotype on Dynamic <inline-formula><mml:math id="M431" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT and <inline-formula><mml:math id="M432" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT is comparable. We also observe that the query time per haplotype increases sublinearly with the size of the panel.</p></sec></sec><sec id="S19"><label>5</label><title>Discussion</title><p id="P34">In this work, we introduced Dynamic <inline-formula><mml:math id="M433" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT (which can also be seen as compressed d-PBWT), a dynamic and space-efficient variation of the PBWT data structure for fast haplotype matching. We used run-length compressed PBWT to achieve better compression rate and stored the runs in the B+ trees to enable dynamic updates. We developed algorithms to insert or delete a haplotype into/from the the Dynamic <inline-formula><mml:math id="M434" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT without decompressing it. The number of updates per site per insertion or deletion in the B+ trees is constant regardless of the number of haplotypes in the Dynamic <inline-formula><mml:math id="M435" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT. We showed that Dynamic <inline-formula><mml:math id="M436" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT uses significantly less memory than d-PBWT. For example, for insertion, while Dynamic <inline-formula><mml:math id="M437" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT is 60 times slower than d-PBWT, it consumes 37 times less memory than d-PBWT on a subsetted panel of UK Biobank data with 50000 haplotypes making it a space efficient choice for dynamic updates at biobank scale. We also provided a long match query algorithm on Dynamic <inline-formula><mml:math id="M438" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT (missing in <inline-formula><mml:math id="M439" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT) and showed that this algorithm can easily be extended back to the original static <inline-formula><mml:math id="M440" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT.</p><p id="P35">While our algorithms are designed to be efficient, there is room for improvement in our current implementation. Dynamic <inline-formula><mml:math id="M441" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT currently consumes roughly 33 times more memory than its static compressed counterparts. One way we could improve the memory consumption is to maintain a single B+ tree storing run length information of all the PBWT columns. This should improve our current compression rates as the overhead of maintaining multiple trees per column is reduced. Also, we used the DYNAMIC library in our current implementation of B+ trees but we believe a better implementation more specific to our use and appropriate for genetic data is possible. These improvements should make the compression rates comparable to static compressed PBWT and maintain similar or better insertion and deletion times.</p><p id="P36">The memory efficiency and flexibility of Dynamic <inline-formula><mml:math id="M442" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT makes it a possible candidate data structure for biobank-scale genetic data. In response to the urgent need for efficient indexing and storage of large population data, Durbin noted PBWT as an efficient way to store haplotype data. Similarly, Li [<xref rid="R10" ref-type="bibr">10</xref>] mentions PBWT&#x02019;s potential to be the primary way to share genetic data on which we can easily run analytic tasks. With the added functionalities of compression and dynamic updates above and beyond the original PBWT, we believe Dynamic <inline-formula><mml:math id="M443" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT could be a potential common data format for biobank-scale genetic analysis ecosystem. Of course, further works are warranted to develop algorithms, codes, and use cases to cover all needed genetic analyses.</p></sec></body><back><ack id="S20"><title>Acknowledgement</title><p id="P37">This work was supported by the National Institutes of Health under award numbers R01HG010086 and R01AG081398. This research has been conducted using the UK Biobank Resource under Application Number 24247.</p></ack><fn-group><fn id="FN1"><p id="P50">Availability</p><p id="P51">The source code for Dynamic <inline-formula><mml:math id="M453" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT is available at <ext-link xlink:href="https://github.com/ucfcbb/Dynamic-mu-PBWT" ext-link-type="uri">https://github.com/ucfcbb/Dynamic-mu-PBWT</ext-link>.</p></fn></fn-group><app-group><app id="APP1"><title>Appendix</title><p id="P38">The following algorithms explain the FL mapping, insertion and deletion in Dynamic <inline-formula><mml:math id="M444" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT and long match query on Dynamic <inline-formula><mml:math id="M445" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT. <xref rid="P40" ref-type="other">Algorithm 2</xref> uses <xref rid="P39" ref-type="other">Algorithm 1</xref> as a subroutine to map a haplotype from column <inline-formula><mml:math id="M446" display="inline"><mml:mi>k</mml:mi></mml:math></inline-formula> to column <inline-formula><mml:math id="M447" display="inline"><mml:mrow><mml:mi>k</mml:mi><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></inline-formula>. <xref rid="P41" ref-type="other">Algorithms 3</xref>, <xref rid="P42" ref-type="other">4</xref> and <xref rid="P46" ref-type="other">8</xref> are used as subroutines in the insertion algorithms defined in <xref rid="P44" ref-type="other">Algorithms 6</xref> and <xref rid="P45" ref-type="other">7</xref>. <xref rid="P43" ref-type="other">Algorithm 5</xref> virtually inserts the new haplotype and calculates the divergence values of the new haplotype and the haplotype below it if the new haplotype were in the Dynamic <inline-formula><mml:math id="M448" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT. <xref rid="P44" ref-type="other">Algorithms 6</xref> and <xref rid="P45" ref-type="other">7</xref> insert the new haplotype into the Dynamic <inline-formula><mml:math id="M449" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT one column at a time. <xref rid="P47" ref-type="other">Algorithms 9</xref> and <xref rid="P48" ref-type="other">10</xref> delete the haplotype at a single column. For the long match query, <xref rid="P43" ref-type="other">Algorithm 5</xref> is used to virtually insert the query haplotype <inline-formula><mml:math id="M450" display="inline"><mml:mi>z</mml:mi></mml:math></inline-formula> and <xref rid="F1" ref-type="fig">Algorithm 11</xref> finds all the long matches between query haplotype <inline-formula><mml:math id="M451" display="inline"><mml:mi>z</mml:mi></mml:math></inline-formula> and the haplotypes in Dynamic <inline-formula><mml:math id="M452" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT.</p><p id="P39">
<graphic xlink:href="nihpp-2025.02.04.636479v1-f0001.jpg" position="float"/>
</p><p id="P40">
<graphic xlink:href="nihpp-2025.02.04.636479v1-f0002.jpg" position="float"/>
</p><p id="P41">
<graphic xlink:href="nihpp-2025.02.04.636479v1-f0003.jpg" position="float"/>
</p><p id="P42">
<graphic xlink:href="nihpp-2025.02.04.636479v1-f0004.jpg" position="float"/>
</p><p id="P43">
<graphic xlink:href="nihpp-2025.02.04.636479v1-f0005.jpg" position="float"/>
</p><p id="P44">
<graphic xlink:href="nihpp-2025.02.04.636479v1-f0006.jpg" position="float"/>
</p><p id="P45">
<graphic xlink:href="nihpp-2025.02.04.636479v1-f0007.jpg" position="float"/>
</p><p id="P46">
<graphic xlink:href="nihpp-2025.02.04.636479v1-f0008.jpg" position="float"/>
</p><p id="P47">
<graphic xlink:href="nihpp-2025.02.04.636479v1-f0009.jpg" position="float"/>
</p><p id="P48">
<graphic xlink:href="nihpp-2025.02.04.636479v1-f0010.jpg" position="float"/>
</p><p id="P49">
<graphic xlink:href="nihpp-2025.02.04.636479v1-f0011.jpg" position="float"/>
</p></app></app-group><ref-list><title>References</title><ref id="R1"><label>1.</label><mixed-citation publication-type="journal"><collab>1000 Genomes Project Consortium</collab>, <etal/>: <article-title>A global reference for human genetic variation</article-title>. <source>Nature</source>
<volume>526</volume>(<issue>7571</issue>), <fpage>68</fpage>&#x02013;<lpage>74</lpage> (<year>2015</year>). <pub-id pub-id-type="doi">10.1038/nature15393</pub-id><pub-id pub-id-type="pmid">26432245</pub-id>
</mixed-citation></ref><ref id="R2"><label>2.</label><mixed-citation publication-type="journal"><name><surname>Bick</surname><given-names>A.G.</given-names></name>, <etal/>: <article-title>Genomic data in the All of Us Research Program</article-title>. <source>Nature</source>
<volume>627</volume>(<issue>8003</issue>), <fpage>340</fpage>&#x02013;<lpage>346</lpage> (<year>2024</year>). <pub-id pub-id-type="doi">10.1038/s41586-023-06957-x</pub-id><pub-id pub-id-type="pmid">38374255</pub-id>
</mixed-citation></ref><ref id="R3"><label>3.</label><mixed-citation publication-type="journal"><name><surname>Browning</surname><given-names>B.L.</given-names></name>, <name><surname>Tian</surname><given-names>X.</given-names></name>, <name><surname>Zhou</surname><given-names>Y.</given-names></name>, <name><surname>Browning</surname><given-names>S.R.</given-names></name>: <article-title>Fast two-stage phasing of large-scale sequence data</article-title>. <source>The American Journal of Human Genetics</source>
<volume>108</volume>(<issue>10</issue>), <fpage>1880</fpage>&#x02013;<lpage>1890</lpage> (<year>2021</year>). <pub-id pub-id-type="doi">10.1016/j.ajhg.2021.08.005</pub-id><pub-id pub-id-type="pmid">34478634</pub-id>
</mixed-citation></ref><ref id="R4"><label>4.</label><mixed-citation publication-type="journal"><name><surname>Bycroft</surname><given-names>C.</given-names></name>, <name><surname>Freeman</surname><given-names>C.</given-names></name>, <name><surname>Petkova</surname><given-names>D.</given-names></name>, <name><surname>Band</surname><given-names>G.</given-names></name>, <name><surname>Elliott</surname><given-names>L.T.</given-names></name>, <name><surname>Sharp</surname><given-names>K.</given-names></name>, <name><surname>Motyer</surname><given-names>A.</given-names></name>, <name><surname>Vukcevic</surname><given-names>D.</given-names></name>, <name><surname>Delaneau</surname><given-names>O.</given-names></name>, <name><surname>O&#x02019;Connell</surname><given-names>J.</given-names></name>, <etal/>: <article-title>The UK Biobank resource with deep phenotyping and genomic data</article-title>. <source>Nature</source>
<volume>562</volume>(<issue>7726</issue>), <fpage>203</fpage>&#x02013;<lpage>209</lpage> (<year>2018</year>). <pub-id pub-id-type="doi">10.1038/s41586-018-0579-z</pub-id><pub-id pub-id-type="pmid">30305743</pub-id>
</mixed-citation></ref><ref id="R5"><label>5.</label><mixed-citation publication-type="journal"><name><surname>Cozzi</surname><given-names>D.</given-names></name>, <name><surname>Rossi</surname><given-names>M.</given-names></name>, <name><surname>Rubinacci</surname><given-names>S.</given-names></name>, <name><surname>Gagie</surname><given-names>T.</given-names></name>, <name><surname>K&#x000f6;ppl</surname><given-names>D.</given-names></name>, <name><surname>Boucher</surname><given-names>C.</given-names></name>, <name><surname>Bonizzoni</surname><given-names>P.</given-names></name>: <article-title>&#x003bc;-PBWT: a lightweight r-indexing of the PBWT for storing and querying UK Biobank data</article-title>. <source>Bioinformatics</source>
<volume>39</volume>(<issue>9</issue>), <fpage>btad552</fpage> (<month>09</month>
<year>2023</year>). <pub-id pub-id-type="doi">10.1093/bioinformatics/btad552</pub-id><pub-id pub-id-type="pmid">37688560</pub-id>
</mixed-citation></ref><ref id="R6"><label>6.</label><mixed-citation publication-type="journal"><name><surname>Danecek</surname><given-names>P.</given-names></name>, <name><surname>Bonfield</surname><given-names>J.K.</given-names></name>, <name><surname>Liddle</surname><given-names>J.</given-names></name>, <name><surname>Marshall</surname><given-names>J.</given-names></name>, <name><surname>Ohan</surname><given-names>V.</given-names></name>, <name><surname>Pollard</surname><given-names>M.O.</given-names></name>, <name><surname>Whitwham</surname><given-names>A.</given-names></name>, <name><surname>Keane</surname><given-names>T.</given-names></name>, <name><surname>Mc-Carthy</surname><given-names>S.A.</given-names></name>, <name><surname>Davies</surname><given-names>R.M.</given-names></name>, <name><surname>Li</surname><given-names>H.</given-names></name>: <article-title>Twelve years of SAMtools and BCFtools</article-title>. <source>GigaScience</source>
<volume>10</volume>(<issue>2</issue>), <fpage>giab008</fpage> (<year>2021</year>). <pub-id pub-id-type="doi">10.1093/gigascience/giab008</pub-id><pub-id pub-id-type="pmid">33590861</pub-id>
</mixed-citation></ref><ref id="R7"><label>7.</label><mixed-citation publication-type="journal"><name><surname>Delaneau</surname><given-names>O.</given-names></name>, <name><surname>Zagury</surname><given-names>J.F.</given-names></name>, <name><surname>Robinson</surname><given-names>M.R.</given-names></name>, <name><surname>Marchini</surname><given-names>J.L.</given-names></name>, <name><surname>Dermitzakis</surname><given-names>E.T.</given-names></name>: <article-title>Accurate, scalable and integrative haplotype estimation</article-title>. <source>Nature Communications</source>
<volume>10</volume>(<issue>1</issue>), <fpage>5436</fpage> (<year>2019</year>). <comment>https://doi.org/0.1038/s41467-019-13225-y</comment></mixed-citation></ref><ref id="R8"><label>8.</label><mixed-citation publication-type="journal"><name><surname>Durbin</surname><given-names>R.</given-names></name>: <article-title>Efficient haplotype matching and storage using the positional Burrows&#x02013;Wheeler transform (PBWT)</article-title>. <source>Bioinformatics</source>
<volume>30</volume>(<issue>9</issue>), <fpage>1266</fpage>&#x02013;<lpage>1272</lpage> (<month>01</month>
<year>2014</year>). <pub-id pub-id-type="doi">10.1093/bioinformatics/btu014</pub-id><pub-id pub-id-type="pmid">24413527</pub-id>
</mixed-citation></ref><ref id="R9"><label>9.</label><mixed-citation publication-type="journal"><name><surname>Li</surname><given-names>H.</given-names></name>: <article-title>Fast construction of FM-index for long sequence reads</article-title>. <source>Bioinformatics</source>
<volume>30</volume>(<issue>22</issue>), <fpage>3274</fpage>&#x02013;<lpage>3275</lpage> (<month>08</month>
<year>2014</year>). <pub-id pub-id-type="doi">10.1093/bioinformatics/btu541</pub-id><pub-id pub-id-type="pmid">25107872</pub-id>
</mixed-citation></ref><ref id="R10"><label>10.</label><mixed-citation publication-type="journal"><name><surname>Li</surname><given-names>H.</given-names></name>: <article-title>BGT: efficient and flexible genotype query across many samples</article-title>. <source>Bioinformatics</source>
<volume>32</volume>(<issue>4</issue>), <fpage>590</fpage>&#x02013;<lpage>592</lpage> (<month>10</month>
<year>2015</year>). <pub-id pub-id-type="doi">10.1093/bioinformatics/btv613</pub-id><pub-id pub-id-type="pmid">26500154</pub-id>
</mixed-citation></ref><ref id="R11"><label>11.</label><mixed-citation publication-type="journal"><name><surname>Li</surname><given-names>H.</given-names></name>: <article-title>BWT construction and search at the terabase scale</article-title>. <source>Bioinformatics</source>
<volume>40</volume>(<issue>12</issue>), <fpage>btae717</fpage> (<month>11</month>
<year>2024</year>). <pub-id pub-id-type="doi">10.1093/bioinformatics/btae717</pub-id><pub-id pub-id-type="pmid">39607778</pub-id>
</mixed-citation></ref><ref id="R12"><label>12.</label><mixed-citation publication-type="journal"><name><surname>Loh</surname><given-names>P.R.</given-names></name>, <name><surname>Palamara</surname><given-names>P.F.</given-names></name>, <name><surname>Price</surname><given-names>A.L.</given-names></name>: <article-title>Fast and accurate long-range phasing in a UK Biobank cohort</article-title>. <source>Nature Genetics</source>
<volume>48</volume>(<issue>7</issue>), <fpage>811</fpage>&#x02013;<lpage>816</lpage> (<year>2016</year>). <pub-id pub-id-type="doi">10.1038/ng.3571</pub-id><pub-id pub-id-type="pmid">27270109</pub-id>
</mixed-citation></ref><ref id="R13"><label>13.</label><mixed-citation publication-type="journal"><name><surname>Naseri</surname><given-names>A.</given-names></name>, <name><surname>Holzhauser</surname><given-names>E.</given-names></name>, <name><surname>Zhi</surname><given-names>D.</given-names></name>, <name><surname>Zhang</surname><given-names>S.</given-names></name>: <article-title>Efficient haplotype matching between a query and a panel for genealogical search</article-title>. <source>Bioinformatics</source>
<volume>35</volume>(<issue>14</issue>), <fpage>i233</fpage>&#x02013;<lpage>i241</lpage> (<month>07</month>
<year>2019</year>). <pub-id pub-id-type="doi">10.1093/bioinformatics/btz347</pub-id><pub-id pub-id-type="pmid">31510689</pub-id>
</mixed-citation></ref><ref id="R14"><label>14.</label><mixed-citation publication-type="book"><name><surname>Navarro</surname><given-names>G.</given-names></name>: <source>Compact Data Structures: A Practical Approach</source>. <publisher-name>Cambridge University Press</publisher-name>, <publisher-loc>USA</publisher-loc>, <edition>1st edn</edition>. (<year>2016</year>)</mixed-citation></ref><ref id="R15"><label>15.</label><mixed-citation publication-type="book"><name><surname>Prezza</surname><given-names>N.</given-names></name>: <part-title>A Framework of Dynamic Data Structures for String Processing</part-title>. In: <name><surname>Iliopoulos</surname><given-names>C.S.</given-names></name>, <name><surname>Pissis</surname><given-names>S.P.</given-names></name>, <name><surname>Puglisi</surname><given-names>S.J.</given-names></name>, <name><surname>Raman</surname><given-names>R.</given-names></name> (eds.) <source>16th International Symposium on Experimental Algorithms (SEA 2017). Leibniz International Proceedings in Informatics (LIPIcs)</source>, vol. <volume>75</volume>, pp. <fpage>11:1</fpage>&#x02013;<lpage>11:15</lpage>. <publisher-name>Schloss Dagstuhl &#x02013; Leibniz-Zentrum f&#x000fc;r Informatik</publisher-name>, <publisher-loc>Dagstuhl, Germany</publisher-loc> (<year>2017</year>). <pub-id pub-id-type="doi">10.4230/LIPIcs.SEA.2017.11</pub-id></mixed-citation></ref><ref id="R16"><label>16.</label><mixed-citation publication-type="journal"><name><surname>Rubinacci</surname><given-names>S.</given-names></name>, <name><surname>Delaneau</surname><given-names>O.</given-names></name>, <name><surname>Marchini</surname><given-names>J.</given-names></name>: <article-title>Genotype imputation using the Positional Burrows Wheeler Transform</article-title>. <source>PLOS Genetics</source>
<volume>16</volume>(<issue>11</issue>), <fpage>e1009049</fpage> (<year>2020</year>). <pub-id pub-id-type="doi">10.1371/journal.pgen.1009049</pub-id><pub-id pub-id-type="pmid">33196638</pub-id>
</mixed-citation></ref><ref id="R17"><label>17.</label><mixed-citation publication-type="journal"><name><surname>Sanaullah</surname><given-names>A.</given-names></name>, <name><surname>Zhi</surname><given-names>D.</given-names></name>, <name><surname>Zhang</surname><given-names>S.</given-names></name>: <article-title>d-PBWT: dynamic positional Burrows&#x02013;Wheeler transform</article-title>. <source>Bioinformatics</source>
<volume>37</volume>(<issue>16</issue>), <fpage>2390</fpage>&#x02013;<lpage>2397</lpage> (<month>02</month>
<year>2021</year>). <pub-id pub-id-type="doi">10.1093/bioinformatics/btab117</pub-id><pub-id pub-id-type="pmid">33624749</pub-id>
</mixed-citation></ref><ref id="R18"><label>18.</label><mixed-citation publication-type="journal"><source>UKBiobank: Nearly &#x000a3;50 million unlocked for world-leading uk biobank following new industry backing</source> (<year>2025</year>), <comment><ext-link xlink:href="https://www.ukbiobank.ac.uk/learn-more-about-uk-biobank/news/nearly-50-million-unlocked-for-world-leading-uk-biobank-following-new-industry-backing" ext-link-type="uri">https://www.ukbiobank.ac.uk/learn-more-about-uk-biobank/news/nearly-50-million-unlocked-for-world-leading-uk-biobank-following-new-industry-backing</ext-link></comment></mixed-citation></ref><ref id="R19"><label>19.</label><mixed-citation publication-type="journal"><name><surname>Wang</surname><given-names>V.</given-names></name>, <name><surname>Naseri</surname><given-names>A.</given-names></name>, <name><surname>Zhang</surname><given-names>S.</given-names></name>, <name><surname>Zhi</surname><given-names>D.</given-names></name>: <article-title>Syllable-PBWT for space-efficient haplotype long-match query</article-title>. <source>Bioinformatics</source>
<volume>39</volume>(<issue>1</issue>), <fpage>btac734</fpage> (<month>11</month>
<year>2022</year>). <pub-id pub-id-type="doi">10.1093/bioinformatics/btac734</pub-id></mixed-citation></ref><ref id="R20"><label>20.</label><mixed-citation publication-type="journal"><name><surname>Wei</surname><given-names>Y.</given-names></name>, <name><surname>Naseri</surname><given-names>A.</given-names></name>, <name><surname>Zhi</surname><given-names>D.</given-names></name>, <name><surname>Zhang</surname><given-names>S.</given-names></name>: <article-title>RaPID-Query for fast identity by descent search and genealogical analysis</article-title>. <source>Bioinformatics</source>
<volume>39</volume>(<issue>6</issue>), <fpage>btad312</fpage> (<month>05</month>
<year>2023</year>). <pub-id pub-id-type="doi">10.1093/bioinformatics/btad312</pub-id><pub-id pub-id-type="pmid">37166451</pub-id>
</mixed-citation></ref><ref id="R21"><label>21.</label><mixed-citation publication-type="journal"><name><surname>Yang</surname><given-names>Y.</given-names></name>, <name><surname>Durbin</surname><given-names>R.</given-names></name>, <name><surname>Iversen</surname><given-names>A.K.N.</given-names></name>, <name><surname>Lawson</surname><given-names>D.J.</given-names></name>: <article-title>Sparse haplotype-based fine-scale local ancestry inference at scale reveals recent selection on immune responses</article-title>. <source>medRxiv</source> (<year>2024</year>). <pub-id pub-id-type="doi">10.1101/2024.03.13.24304206</pub-id></mixed-citation></ref></ref-list></back><floats-group><fig position="float" id="F1"><label>Fig. 1.</label><caption><p id="P52">Relationship between PBWT, d-PBWT, compressed static PBWT and Dynamic <inline-formula><mml:math id="M7" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT.</p></caption><graphic xlink:href="nihpp-2025.02.04.636479v1-f0012" position="float"/></fig><fig position="float" id="F2"><label>Fig. 2.</label><caption><p id="P53">Dynamic run-length compressed representation of the PBWT panel of haplotypes. (A) A bi-allelic panel consisting of 20 haplotypes (rows) and 15 sites (columns). (B) PBWT of the input panel of haplotypes. Light gray and dark gray squares show a run of zeros and ones respectively. (C) Run-length encoded representation of PBWT columns. (D) B+ tree <inline-formula><mml:math id="M8" display="inline"><mml:mrow><mml:mfenced><mml:mrow><mml:mi>t</mml:mi><mml:mo>=</mml:mo><mml:mn>2</mml:mn></mml:mrow></mml:mfenced></mml:mrow></mml:math></inline-formula> representation of the second column of PBWT. The light and dark bands below the leaves show runs of zero and ones respectively.</p></caption><graphic xlink:href="nihpp-2025.02.04.636479v1-f0013" position="float"/></fig><fig position="float" id="F3"><label>Fig. 3.</label><caption><p id="P54">Insertion of a new haplotype in Dynamic <inline-formula><mml:math id="M9" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT. (A) Dynamic <inline-formula><mml:math id="M10" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT run lengths before and after insertion of the new haplotype. New haplotype <inline-formula><mml:math id="M11" display="inline"><mml:mi>z</mml:mi></mml:math></inline-formula> is shown at the bottom of the left figure. The haplotype&#x02019;s insert locations are shown by bold black boxes. The right figure shows the panel after insertion. Orange boxes show the existing runs that were updated after insertion. Blue boxes show new runs being inserted and dotted orange boxes show the existing run being split to insert a new run. (B) The corresponding B+ tree operation when updating column 3.</p></caption><graphic xlink:href="nihpp-2025.02.04.636479v1-f0014" position="float"/></fig><fig position="float" id="F4"><label>Fig. 4.</label><caption><p id="P55">Construction time comparison between Dynamic <inline-formula><mml:math id="M12" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT, <inline-formula><mml:math id="M13" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT and Syllable-PBWT. (A) Construction time comparison on all autosomes of 1KGP data (B) Construction time comparison on all autosomes of UKB data with randomly sampled 50000 haplotypes.</p></caption><graphic xlink:href="nihpp-2025.02.04.636479v1-f0015" position="float"/></fig><fig position="float" id="F5"><label>Fig. 5.</label><caption><p id="P56">Memory comparison between Dynamic <inline-formula><mml:math id="M14" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT, <inline-formula><mml:math id="M15" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT, Syllable-PBWT and d-PBWT. (A) Memory comparison on all autosomes of 1KGP data (B) Memory comparison on all autosomes of UKB data with randomly sampled 50000 haplotypes.</p></caption><graphic xlink:href="nihpp-2025.02.04.636479v1-f0016" position="float"/></fig><fig position="float" id="F6"><label>Fig. 6.</label><caption><p id="P57">Time for insertion and deletion of haplotypes. (A, B) Average insertion and deletion time of 5008 haplotypes of chromosome 21 of 1KGP. (C, D) Average insertion and deletion time of 100,000 haplotypes of chromosome 21 of UK Biobank data.</p></caption><graphic xlink:href="nihpp-2025.02.04.636479v1-f0017" position="float"/></fig><table-wrap position="float" id="T1"><label>Table 1.</label><caption><p id="P58">Long match query time per query haplotype</p></caption><table frame="box" rules="groups"><colgroup span="1"><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/><col align="left" valign="middle" span="1"/></colgroup><thead><tr><th rowspan="2" align="center" valign="middle" colspan="1">Panel Size</th><th colspan="2" align="center" valign="middle" rowspan="1">Dynamic <inline-formula><mml:math id="M16" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT</th><th colspan="2" align="center" valign="middle" rowspan="1"><inline-formula><mml:math id="M17" display="inline"><mml:mi>&#x003bc;</mml:mi></mml:math></inline-formula>-PBWT</th></tr><tr><th align="center" valign="middle" rowspan="1" colspan="1">Avg. Time (in sec)</th><th align="center" valign="middle" rowspan="1" colspan="1">Std. Dev</th><th align="center" valign="middle" rowspan="1" colspan="1">Avg. Time (in sec)</th><th align="center" valign="middle" rowspan="1" colspan="1">Std. dev</th></tr></thead><tbody><tr><td align="left" valign="middle" rowspan="1" colspan="1">1000</td><td align="left" valign="middle" rowspan="1" colspan="1">0.029470</td><td align="left" valign="middle" rowspan="1" colspan="1">0.000840</td><td align="left" valign="middle" rowspan="1" colspan="1">0.026313</td><td align="left" valign="middle" rowspan="1" colspan="1">0.004631</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">5000</td><td align="left" valign="middle" rowspan="1" colspan="1">0.089743</td><td align="left" valign="middle" rowspan="1" colspan="1">0.003145</td><td align="left" valign="middle" rowspan="1" colspan="1">0.088879</td><td align="left" valign="middle" rowspan="1" colspan="1">0.005594</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">10000</td><td align="left" valign="middle" rowspan="1" colspan="1">0.125642</td><td align="left" valign="middle" rowspan="1" colspan="1">0.004762</td><td align="left" valign="middle" rowspan="1" colspan="1">0.160786</td><td align="left" valign="middle" rowspan="1" colspan="1">0.012228</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">50000</td><td align="left" valign="middle" rowspan="1" colspan="1">0.208166</td><td align="left" valign="middle" rowspan="1" colspan="1">0.010068</td><td align="left" valign="middle" rowspan="1" colspan="1">0.598709</td><td align="left" valign="middle" rowspan="1" colspan="1">0.067909</td></tr><tr><td align="left" valign="middle" rowspan="1" colspan="1">100000</td><td align="left" valign="middle" rowspan="1" colspan="1">0.232464</td><td align="left" valign="middle" rowspan="1" colspan="1">0.013217</td><td align="left" valign="middle" rowspan="1" colspan="1">1.077350</td><td align="left" valign="middle" rowspan="1" colspan="1">0.146789</td></tr></tbody></table></table-wrap></floats-group></article>